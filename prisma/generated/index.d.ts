
/**
 * Client
**/


declare global {
  namespace PrismaJson {
    // This namespace will always be empty. Definitions should be done by
    // you manually, and merged automatically by typescript. Make sure that
    // your declaration merging file is included in your tsconfig.json
    //
    // Learn more: https://github.com/arthurfiorette/prisma-json-types-generator/issues/143
    // Declaration Merging: https://www.typescriptlang.org/docs/handbook/declaration-merging.html
  }
}

/** A filter to be used against nullable List types. */
export type NullableListFilter<T> = {
  equals?: T | T[] | null;
  has?: T | null;
  hasEvery?: T[];
  hasSome?: T[];
  isEmpty?: boolean;
};

/** A type to determine how to update a json field */
export type UpdateInput<T> = T extends object ? { [P in keyof T]?: UpdateInput<T[P]> } : T;

/** A type to determine how to update a json[] field */
export type UpdateManyInput<T> = T | T[] | { set?: T[]; push?: T | T[] };

/** A type to determine how to create a json[] input */
export type CreateManyInput<T> = T | T[] | { set?: T[] };

/**
 * A typed version of NestedStringFilter, allowing narrowing of string types to
 * discriminated unions.
 */
export type TypedNestedStringFilter<S extends string> =
  //@ts-ignore - When Prisma.StringFilter is not present, this type is not used
  Prisma.StringFilter & {
    equals?: S;
    in?: S[];
    notIn?: S[];
    not?: TypedNestedStringFilter<S> | S;
  };

/**
 * A typed version of StringFilter, allowing narrowing of string types to discriminated
 * unions.
 */
export type TypedStringFilter<S extends string> =
  //@ts-ignore - When Prisma.StringFilter is not present, this type is not used
  Prisma.StringFilter & {
    equals?: S;
    in?: S[];
    notIn?: S[];
    not?: TypedNestedStringFilter<S> | S;
  };

/**
 * A typed version of NestedStringNullableFilter, allowing narrowing of string types to
 * discriminated unions.
 */
export type TypedNestedStringNullableFilter<S extends string> =
  //@ts-ignore - When Prisma.StringNullableFilter is not present, this type is not used
  Prisma.StringNullableFilter & {
    equals?: S | null;
    in?: S[] | null;
    notIn?: S[] | null;
    not?: TypedNestedStringNullableFilter<S> | S | null;
  };

/**
 * A typed version of StringNullableFilter, allowing narrowing of string types to
 * discriminated unions.
 */
export type TypedStringNullableFilter<S extends string> =
  //@ts-ignore - When Prisma.StringNullableFilter is not present, this type is not used
  Prisma.StringNullableFilter & {
    equals?: S | null;
    in?: S[] | null;
    notIn?: S[] | null;
    not?: TypedNestedStringNullableFilter<S> | S | null;
  };

/**
 * A typed version of NestedStringWithAggregatesFilter, allowing narrowing of string types
 * to discriminated unions.
 */
export type TypedNestedStringWithAggregatesFilter<S extends string> =
  //@ts-ignore - When Prisma.NestedStringWithAggregatesFilter is not present, this type is not used
  Prisma.NestedStringWithAggregatesFilter & {
    equals?: S;
    in?: S[];
    notIn?: S[];
    not?: TypedNestedStringWithAggregatesFilter<S> | S;
  };

/**
 * A typed version of StringWithAggregatesFilter, allowing narrowing of string types to
 * discriminated unions.
 */
export type TypedStringWithAggregatesFilter<S extends string> =
  //@ts-ignore - When Prisma.StringWithAggregatesFilter is not present, this type is not used
  Prisma.StringWithAggregatesFilter & {
    equals?: S;
    in?: S[];
    notIn?: S[];
    not?: TypedNestedStringWithAggregatesFilter<S> | S;
  };

/**
 * A typed version of NestedStringNullableWithAggregatesFilter, allowing narrowing of
 * string types to discriminated unions.
 */
export type TypedNestedStringNullableWithAggregatesFilter<S extends string> =
  //@ts-ignore - When Prisma.NestedStringNullableWithAggregatesFilter is not present, this type is not used
  Prisma.NestedStringNullableWithAggregatesFilter & {
    equals?: S | null;
    in?: S[] | null;
    notIn?: S[] | null;
    not?: TypedNestedStringNullableWithAggregatesFilter<S> | S | null;
  };

/**
 * A typed version of StringNullableWithAggregatesFilter, allowing narrowing of string
 * types to discriminated unions.
 */
export type TypedStringNullableWithAggregatesFilter<S extends string> =
  //@ts-ignore - When Prisma.StringNullableWithAggregatesFilter is not present, this type is not used
  Prisma.StringNullableWithAggregatesFilter & {
    equals?: S | null;
    in?: S[] | null;
    notIn?: S[] | null;
    not?: TypedNestedStringNullableWithAggregatesFilter<S> | S | null;
  };

/**
 * A typed version of StringFieldUpdateOperationsInput, allowing narrowing of string types
 * to discriminated unions.
 */
export type TypedStringFieldUpdateOperationsInput<S extends string> =
  //@ts-ignore - When Prisma.StringFieldUpdateOperationsInput is not present, this type is not used
  Prisma.StringFieldUpdateOperationsInput & {
    set?: S;
  };

/**
 * A typed version of NullableStringFieldUpdateOperationsInput, allowing narrowing of
 * string types to discriminated unions.
 */
export type TypedNullableStringFieldUpdateOperationsInput<S extends string> =
  //@ts-ignore - When Prisma.NullableStringFieldUpdateOperationsInput is not present, this type is not used
  Prisma.NullableStringFieldUpdateOperationsInput & {
    set?: S | null;
  };

/**
 * A typed version of StringNullableListFilter, allowing narrowing of string types to
 * discriminated unions.
 */
export type TypedStringNullableListFilter<S extends string> =
  //@ts-ignore - When Prisma.StringNullableListFilter is not present, this type is not used
  Prisma.StringNullableListFilter & {
    equals?: S[] | null;
    has?: S | null;
    hasEvery?: S[];
    hasSome?: S[];
  };

/**
 * A typed version of the input type to update a string[] field, allowing narrowing of
 * string types to discriminated unions.
 */
export type UpdateStringArrayInput<S extends string> = {
  set?: S[];
  push?: S | S[];
};

/**
 * A typed version of the input type to create a string[] field, allowing narrowing of
 * string types to discriminated unions.
 */
export type CreateStringArrayInput<S extends string> = {
  set?: S[];
};
import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Language
 * 
 */
export type Language = $Result.DefaultSelection<Prisma.$LanguagePayload>
/**
 * Model Settings
 * 
 */
export type Settings = $Result.DefaultSelection<Prisma.$SettingsPayload>
/**
 * Model Widget
 * 
 */
export type Widget = $Result.DefaultSelection<Prisma.$WidgetPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>
/**
 * Model Seo
 * 
 */
export type Seo = $Result.DefaultSelection<Prisma.$SeoPayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model PostAuthor
 * 
 */
export type PostAuthor = $Result.DefaultSelection<Prisma.$PostAuthorPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model PostCategory
 * 
 */
export type PostCategory = $Result.DefaultSelection<Prisma.$PostCategoryPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model EmailSetting
 * 
 */
export type EmailSetting = $Result.DefaultSelection<Prisma.$EmailSettingPayload>
/**
 * Model EmailTemplate
 * 
 */
export type EmailTemplate = $Result.DefaultSelection<Prisma.$EmailTemplatePayload>
/**
 * Model EmailAudience
 * 
 */
export type EmailAudience = $Result.DefaultSelection<Prisma.$EmailAudiencePayload>
/**
 * Model EmailContact
 * 
 */
export type EmailContact = $Result.DefaultSelection<Prisma.$EmailContactPayload>
/**
 * Model EmailContactInteraction
 * 
 */
export type EmailContactInteraction = $Result.DefaultSelection<Prisma.$EmailContactInteractionPayload>
/**
 * Model EmailSingleSend
 * 
 */
export type EmailSingleSend = $Result.DefaultSelection<Prisma.$EmailSingleSendPayload>
/**
 * Model EmailSubscriptionToken
 * 
 */
export type EmailSubscriptionToken = $Result.DefaultSelection<Prisma.$EmailSubscriptionTokenPayload>
/**
 * Model EmailSendLog
 * 
 */
export type EmailSendLog = $Result.DefaultSelection<Prisma.$EmailSendLogPayload>
/**
 * Model EmailSingleSendLog
 * 
 */
export type EmailSingleSendLog = $Result.DefaultSelection<Prisma.$EmailSingleSendLogPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductCategory
 * 
 */
export type ProductCategory = $Result.DefaultSelection<Prisma.$ProductCategoryPayload>
/**
 * Model ProductGallery
 * 
 */
export type ProductGallery = $Result.DefaultSelection<Prisma.$ProductGalleryPayload>
/**
 * Model ProductExtra
 * 
 */
export type ProductExtra = $Result.DefaultSelection<Prisma.$ProductExtraPayload>
/**
 * Model ProductFAQ
 * 
 */
export type ProductFAQ = $Result.DefaultSelection<Prisma.$ProductFAQPayload>
/**
 * Model AdCampaign
 * 
 */
export type AdCampaign = $Result.DefaultSelection<Prisma.$AdCampaignPayload>
/**
 * Model AdBlock
 * 
 */
export type AdBlock = $Result.DefaultSelection<Prisma.$AdBlockPayload>
/**
 * Model AdItem
 * 
 */
export type AdItem = $Result.DefaultSelection<Prisma.$AdItemPayload>
/**
 * Model Purchase
 * 
 */
export type Purchase = $Result.DefaultSelection<Prisma.$PurchasePayload>
/**
 * Model ContactForm
 * 
 */
export type ContactForm = $Result.DefaultSelection<Prisma.$ContactFormPayload>
/**
 * Model Form
 * 
 */
export type Form = $Result.DefaultSelection<Prisma.$FormPayload>
/**
 * Model FormSubmission
 * 
 */
export type FormSubmission = $Result.DefaultSelection<Prisma.$FormSubmissionPayload>
/**
 * Model Format
 * 
 */
export type Format = $Result.DefaultSelection<Prisma.$FormatPayload>
/**
 * Model Genre
 * 
 */
export type Genre = $Result.DefaultSelection<Prisma.$GenrePayload>
/**
 * Model Impression
 * 
 */
export type Impression = $Result.DefaultSelection<Prisma.$ImpressionPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model SocialChannel
 * 
 */
export type SocialChannel = $Result.DefaultSelection<Prisma.$SocialChannelPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const WidgetSection: {
  HERO: 'HERO',
  MODAL_POPUP: 'MODAL_POPUP',
  POST_SIDEBAR: 'POST_SIDEBAR',
  POST_BOTTOM: 'POST_BOTTOM'
};

export type WidgetSection = (typeof WidgetSection)[keyof typeof WidgetSection]


export const WidgetType: {
  SEARCH_BOX: 'SEARCH_BOX',
  POST: 'POST',
  CATEGORY: 'CATEGORY',
  TAG: 'TAG',
  PRODUCT: 'PRODUCT',
  NEWSLETTER: 'NEWSLETTER',
  AUTHOR: 'AUTHOR',
  SOCIAL: 'SOCIAL',
  PRODUCT_POP: 'PRODUCT_POP',
  NEWSLETTER_POP: 'NEWSLETTER_POP'
};

export type WidgetType = (typeof WidgetType)[keyof typeof WidgetType]


export const UserRole: {
  USER: 'USER',
  EDITOR: 'EDITOR',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const MediaType: {
  AUDIO: 'AUDIO',
  FILE: 'FILE',
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]


export const ContentStatus: {
  DRAFT: 'DRAFT',
  CHANGED: 'CHANGED',
  PUBLISHED: 'PUBLISHED'
};

export type ContentStatus = (typeof ContentStatus)[keyof typeof ContentStatus]


export const EditorType: {
  SLATE: 'SLATE',
  TIPTAP: 'TIPTAP'
};

export type EditorType = (typeof EditorType)[keyof typeof EditorType]


export const EmailProvider: {
  SENDGRID: 'SENDGRID'
};

export type EmailProvider = (typeof EmailProvider)[keyof typeof EmailProvider]


export const AudienceType: {
  GLOBAL: 'GLOBAL',
  LIST: 'LIST'
};

export type AudienceType = (typeof AudienceType)[keyof typeof AudienceType]


export const ProductType: {
  EBOOK: 'EBOOK',
  SERVICE: 'SERVICE',
  AFFILIATE: 'AFFILIATE',
  WEBINAR: 'WEBINAR'
};

export type ProductType = (typeof ProductType)[keyof typeof ProductType]


export const ProductAcquisitionMode: {
  FREE: 'FREE',
  PAID: 'PAID',
  FORM: 'FORM',
  AFFILIATE: 'AFFILIATE'
};

export type ProductAcquisitionMode = (typeof ProductAcquisitionMode)[keyof typeof ProductAcquisitionMode]


export const AdLayoutType: {
  SINGLE: 'SINGLE',
  GRID: 'GRID',
  CAROUSEL: 'CAROUSEL'
};

export type AdLayoutType = (typeof AdLayoutType)[keyof typeof AdLayoutType]


export const AdItemSourceType: {
  STATIC: 'STATIC',
  POST: 'POST',
  PRODUCT: 'PRODUCT'
};

export type AdItemSourceType = (typeof AdItemSourceType)[keyof typeof AdItemSourceType]


export const AdPositionPlacement: {
  BEFORE: 'BEFORE',
  AFTER: 'AFTER'
};

export type AdPositionPlacement = (typeof AdPositionPlacement)[keyof typeof AdPositionPlacement]


export const AdPositionReference: {
  HEADING: 'HEADING',
  HEADING_2: 'HEADING_2',
  HEADING_3: 'HEADING_3',
  HEADING_4: 'HEADING_4',
  PARAGRAPH: 'PARAGRAPH',
  IMAGE: 'IMAGE'
};

export type AdPositionReference = (typeof AdPositionReference)[keyof typeof AdPositionReference]


export const SocialKey: {
  FACEBOOK: 'FACEBOOK',
  TWITTER: 'TWITTER',
  INSTAGRAM: 'INSTAGRAM',
  LINKEDIN: 'LINKEDIN',
  PINTEREST: 'PINTEREST',
  YOUTUBE: 'YOUTUBE'
};

export type SocialKey = (typeof SocialKey)[keyof typeof SocialKey]


export const SocialEntityType: {
  SITE: 'SITE',
  USER: 'USER'
};

export type SocialEntityType = (typeof SocialEntityType)[keyof typeof SocialEntityType]

}

export type WidgetSection = $Enums.WidgetSection

export const WidgetSection: typeof $Enums.WidgetSection

export type WidgetType = $Enums.WidgetType

export const WidgetType: typeof $Enums.WidgetType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

export type ContentStatus = $Enums.ContentStatus

export const ContentStatus: typeof $Enums.ContentStatus

export type EditorType = $Enums.EditorType

export const EditorType: typeof $Enums.EditorType

export type EmailProvider = $Enums.EmailProvider

export const EmailProvider: typeof $Enums.EmailProvider

export type AudienceType = $Enums.AudienceType

export const AudienceType: typeof $Enums.AudienceType

export type ProductType = $Enums.ProductType

export const ProductType: typeof $Enums.ProductType

export type ProductAcquisitionMode = $Enums.ProductAcquisitionMode

export const ProductAcquisitionMode: typeof $Enums.ProductAcquisitionMode

export type AdLayoutType = $Enums.AdLayoutType

export const AdLayoutType: typeof $Enums.AdLayoutType

export type AdItemSourceType = $Enums.AdItemSourceType

export const AdItemSourceType: typeof $Enums.AdItemSourceType

export type AdPositionPlacement = $Enums.AdPositionPlacement

export const AdPositionPlacement: typeof $Enums.AdPositionPlacement

export type AdPositionReference = $Enums.AdPositionReference

export const AdPositionReference: typeof $Enums.AdPositionReference

export type SocialKey = $Enums.SocialKey

export const SocialKey: typeof $Enums.SocialKey

export type SocialEntityType = $Enums.SocialEntityType

export const SocialEntityType: typeof $Enums.SocialEntityType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Languages
 * const languages = await prisma.language.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Languages
   * const languages = await prisma.language.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/orm/prisma-client/queries/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.language`: Exposes CRUD operations for the **Language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languages
    * const languages = await prisma.language.findMany()
    * ```
    */
  get language(): Prisma.LanguageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settings`: Exposes CRUD operations for the **Settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.SettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.widget`: Exposes CRUD operations for the **Widget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Widgets
    * const widgets = await prisma.widget.findMany()
    * ```
    */
  get widget(): Prisma.WidgetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seo`: Exposes CRUD operations for the **Seo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seos
    * const seos = await prisma.seo.findMany()
    * ```
    */
  get seo(): Prisma.SeoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postAuthor`: Exposes CRUD operations for the **PostAuthor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostAuthors
    * const postAuthors = await prisma.postAuthor.findMany()
    * ```
    */
  get postAuthor(): Prisma.PostAuthorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postCategory`: Exposes CRUD operations for the **PostCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostCategories
    * const postCategories = await prisma.postCategory.findMany()
    * ```
    */
  get postCategory(): Prisma.PostCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailSetting`: Exposes CRUD operations for the **EmailSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailSettings
    * const emailSettings = await prisma.emailSetting.findMany()
    * ```
    */
  get emailSetting(): Prisma.EmailSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailTemplate`: Exposes CRUD operations for the **EmailTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailTemplates
    * const emailTemplates = await prisma.emailTemplate.findMany()
    * ```
    */
  get emailTemplate(): Prisma.EmailTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailAudience`: Exposes CRUD operations for the **EmailAudience** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailAudiences
    * const emailAudiences = await prisma.emailAudience.findMany()
    * ```
    */
  get emailAudience(): Prisma.EmailAudienceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailContact`: Exposes CRUD operations for the **EmailContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailContacts
    * const emailContacts = await prisma.emailContact.findMany()
    * ```
    */
  get emailContact(): Prisma.EmailContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailContactInteraction`: Exposes CRUD operations for the **EmailContactInteraction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailContactInteractions
    * const emailContactInteractions = await prisma.emailContactInteraction.findMany()
    * ```
    */
  get emailContactInteraction(): Prisma.EmailContactInteractionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailSingleSend`: Exposes CRUD operations for the **EmailSingleSend** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailSingleSends
    * const emailSingleSends = await prisma.emailSingleSend.findMany()
    * ```
    */
  get emailSingleSend(): Prisma.EmailSingleSendDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailSubscriptionToken`: Exposes CRUD operations for the **EmailSubscriptionToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailSubscriptionTokens
    * const emailSubscriptionTokens = await prisma.emailSubscriptionToken.findMany()
    * ```
    */
  get emailSubscriptionToken(): Prisma.EmailSubscriptionTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailSendLog`: Exposes CRUD operations for the **EmailSendLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailSendLogs
    * const emailSendLogs = await prisma.emailSendLog.findMany()
    * ```
    */
  get emailSendLog(): Prisma.EmailSendLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailSingleSendLog`: Exposes CRUD operations for the **EmailSingleSendLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailSingleSendLogs
    * const emailSingleSendLogs = await prisma.emailSingleSendLog.findMany()
    * ```
    */
  get emailSingleSendLog(): Prisma.EmailSingleSendLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productCategory`: Exposes CRUD operations for the **ProductCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCategories
    * const productCategories = await prisma.productCategory.findMany()
    * ```
    */
  get productCategory(): Prisma.ProductCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productGallery`: Exposes CRUD operations for the **ProductGallery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductGalleries
    * const productGalleries = await prisma.productGallery.findMany()
    * ```
    */
  get productGallery(): Prisma.ProductGalleryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productExtra`: Exposes CRUD operations for the **ProductExtra** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductExtras
    * const productExtras = await prisma.productExtra.findMany()
    * ```
    */
  get productExtra(): Prisma.ProductExtraDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productFAQ`: Exposes CRUD operations for the **ProductFAQ** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductFAQS
    * const productFAQS = await prisma.productFAQ.findMany()
    * ```
    */
  get productFAQ(): Prisma.ProductFAQDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adCampaign`: Exposes CRUD operations for the **AdCampaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdCampaigns
    * const adCampaigns = await prisma.adCampaign.findMany()
    * ```
    */
  get adCampaign(): Prisma.AdCampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adBlock`: Exposes CRUD operations for the **AdBlock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdBlocks
    * const adBlocks = await prisma.adBlock.findMany()
    * ```
    */
  get adBlock(): Prisma.AdBlockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adItem`: Exposes CRUD operations for the **AdItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdItems
    * const adItems = await prisma.adItem.findMany()
    * ```
    */
  get adItem(): Prisma.AdItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchase`: Exposes CRUD operations for the **Purchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchases
    * const purchases = await prisma.purchase.findMany()
    * ```
    */
  get purchase(): Prisma.PurchaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactForm`: Exposes CRUD operations for the **ContactForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactForms
    * const contactForms = await prisma.contactForm.findMany()
    * ```
    */
  get contactForm(): Prisma.ContactFormDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.form`: Exposes CRUD operations for the **Form** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Forms
    * const forms = await prisma.form.findMany()
    * ```
    */
  get form(): Prisma.FormDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.formSubmission`: Exposes CRUD operations for the **FormSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormSubmissions
    * const formSubmissions = await prisma.formSubmission.findMany()
    * ```
    */
  get formSubmission(): Prisma.FormSubmissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.format`: Exposes CRUD operations for the **Format** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Formats
    * const formats = await prisma.format.findMany()
    * ```
    */
  get format(): Prisma.FormatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.genre`: Exposes CRUD operations for the **Genre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Genres
    * const genres = await prisma.genre.findMany()
    * ```
    */
  get genre(): Prisma.GenreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.impression`: Exposes CRUD operations for the **Impression** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Impressions
    * const impressions = await prisma.impression.findMany()
    * ```
    */
  get impression(): Prisma.ImpressionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.socialChannel`: Exposes CRUD operations for the **SocialChannel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialChannels
    * const socialChannels = await prisma.socialChannel.findMany()
    * ```
    */
  get socialChannel(): Prisma.SocialChannelDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.4.1
   * Query Engine version: 55ae170b1ced7fc6ed07a15f110549408c501bb3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Language: 'Language',
    Settings: 'Settings',
    Widget: 'Widget',
    Session: 'Session',
    Verification: 'Verification',
    User: 'User',
    Account: 'Account',
    VerificationToken: 'VerificationToken',
    PasswordResetToken: 'PasswordResetToken',
    Media: 'Media',
    Seo: 'Seo',
    Post: 'Post',
    PostAuthor: 'PostAuthor',
    Category: 'Category',
    PostCategory: 'PostCategory',
    Tag: 'Tag',
    EmailSetting: 'EmailSetting',
    EmailTemplate: 'EmailTemplate',
    EmailAudience: 'EmailAudience',
    EmailContact: 'EmailContact',
    EmailContactInteraction: 'EmailContactInteraction',
    EmailSingleSend: 'EmailSingleSend',
    EmailSubscriptionToken: 'EmailSubscriptionToken',
    EmailSendLog: 'EmailSendLog',
    EmailSingleSendLog: 'EmailSingleSendLog',
    Product: 'Product',
    ProductCategory: 'ProductCategory',
    ProductGallery: 'ProductGallery',
    ProductExtra: 'ProductExtra',
    ProductFAQ: 'ProductFAQ',
    AdCampaign: 'AdCampaign',
    AdBlock: 'AdBlock',
    AdItem: 'AdItem',
    Purchase: 'Purchase',
    ContactForm: 'ContactForm',
    Form: 'Form',
    FormSubmission: 'FormSubmission',
    Format: 'Format',
    Genre: 'Genre',
    Impression: 'Impression',
    Notification: 'Notification',
    SocialChannel: 'SocialChannel'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "language" | "settings" | "widget" | "session" | "verification" | "user" | "account" | "verificationToken" | "passwordResetToken" | "media" | "seo" | "post" | "postAuthor" | "category" | "postCategory" | "tag" | "emailSetting" | "emailTemplate" | "emailAudience" | "emailContact" | "emailContactInteraction" | "emailSingleSend" | "emailSubscriptionToken" | "emailSendLog" | "emailSingleSendLog" | "product" | "productCategory" | "productGallery" | "productExtra" | "productFAQ" | "adCampaign" | "adBlock" | "adItem" | "purchase" | "contactForm" | "form" | "formSubmission" | "format" | "genre" | "impression" | "notification" | "socialChannel"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Language: {
        payload: Prisma.$LanguagePayload<ExtArgs>
        fields: Prisma.LanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findFirst: {
            args: Prisma.LanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findMany: {
            args: Prisma.LanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          create: {
            args: Prisma.LanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          createMany: {
            args: Prisma.LanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LanguageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          delete: {
            args: Prisma.LanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          update: {
            args: Prisma.LanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          deleteMany: {
            args: Prisma.LanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LanguageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          upsert: {
            args: Prisma.LanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          aggregate: {
            args: Prisma.LanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanguage>
          }
          groupBy: {
            args: Prisma.LanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LanguageCountArgs<ExtArgs>
            result: $Utils.Optional<LanguageCountAggregateOutputType> | number
          }
        }
      }
      Settings: {
        payload: Prisma.$SettingsPayload<ExtArgs>
        fields: Prisma.SettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findFirst: {
            args: Prisma.SettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findMany: {
            args: Prisma.SettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          create: {
            args: Prisma.SettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          createMany: {
            args: Prisma.SettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          delete: {
            args: Prisma.SettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          update: {
            args: Prisma.SettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          deleteMany: {
            args: Prisma.SettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          upsert: {
            args: Prisma.SettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.SettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
      Widget: {
        payload: Prisma.$WidgetPayload<ExtArgs>
        fields: Prisma.WidgetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WidgetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WidgetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>
          }
          findFirst: {
            args: Prisma.WidgetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WidgetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>
          }
          findMany: {
            args: Prisma.WidgetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>[]
          }
          create: {
            args: Prisma.WidgetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>
          }
          createMany: {
            args: Prisma.WidgetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WidgetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>[]
          }
          delete: {
            args: Prisma.WidgetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>
          }
          update: {
            args: Prisma.WidgetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>
          }
          deleteMany: {
            args: Prisma.WidgetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WidgetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WidgetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>[]
          }
          upsert: {
            args: Prisma.WidgetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>
          }
          aggregate: {
            args: Prisma.WidgetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWidget>
          }
          groupBy: {
            args: Prisma.WidgetGroupByArgs<ExtArgs>
            result: $Utils.Optional<WidgetGroupByOutputType>[]
          }
          count: {
            args: Prisma.WidgetCountArgs<ExtArgs>
            result: $Utils.Optional<WidgetCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      Media: {
        payload: Prisma.$MediaPayload<ExtArgs>
        fields: Prisma.MediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findFirst: {
            args: Prisma.MediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findMany: {
            args: Prisma.MediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          create: {
            args: Prisma.MediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          createMany: {
            args: Prisma.MediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          delete: {
            args: Prisma.MediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          update: {
            args: Prisma.MediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          deleteMany: {
            args: Prisma.MediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          upsert: {
            args: Prisma.MediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.MediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
      Seo: {
        payload: Prisma.$SeoPayload<ExtArgs>
        fields: Prisma.SeoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoPayload>
          }
          findFirst: {
            args: Prisma.SeoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoPayload>
          }
          findMany: {
            args: Prisma.SeoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoPayload>[]
          }
          create: {
            args: Prisma.SeoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoPayload>
          }
          createMany: {
            args: Prisma.SeoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoPayload>[]
          }
          delete: {
            args: Prisma.SeoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoPayload>
          }
          update: {
            args: Prisma.SeoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoPayload>
          }
          deleteMany: {
            args: Prisma.SeoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SeoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoPayload>[]
          }
          upsert: {
            args: Prisma.SeoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoPayload>
          }
          aggregate: {
            args: Prisma.SeoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeo>
          }
          groupBy: {
            args: Prisma.SeoGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeoGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeoCountArgs<ExtArgs>
            result: $Utils.Optional<SeoCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      PostAuthor: {
        payload: Prisma.$PostAuthorPayload<ExtArgs>
        fields: Prisma.PostAuthorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostAuthorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAuthorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostAuthorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAuthorPayload>
          }
          findFirst: {
            args: Prisma.PostAuthorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAuthorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostAuthorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAuthorPayload>
          }
          findMany: {
            args: Prisma.PostAuthorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAuthorPayload>[]
          }
          create: {
            args: Prisma.PostAuthorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAuthorPayload>
          }
          createMany: {
            args: Prisma.PostAuthorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostAuthorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAuthorPayload>[]
          }
          delete: {
            args: Prisma.PostAuthorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAuthorPayload>
          }
          update: {
            args: Prisma.PostAuthorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAuthorPayload>
          }
          deleteMany: {
            args: Prisma.PostAuthorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostAuthorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostAuthorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAuthorPayload>[]
          }
          upsert: {
            args: Prisma.PostAuthorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAuthorPayload>
          }
          aggregate: {
            args: Prisma.PostAuthorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostAuthor>
          }
          groupBy: {
            args: Prisma.PostAuthorGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostAuthorGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostAuthorCountArgs<ExtArgs>
            result: $Utils.Optional<PostAuthorCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      PostCategory: {
        payload: Prisma.$PostCategoryPayload<ExtArgs>
        fields: Prisma.PostCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCategoryPayload>
          }
          findFirst: {
            args: Prisma.PostCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCategoryPayload>
          }
          findMany: {
            args: Prisma.PostCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCategoryPayload>[]
          }
          create: {
            args: Prisma.PostCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCategoryPayload>
          }
          createMany: {
            args: Prisma.PostCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCategoryPayload>[]
          }
          delete: {
            args: Prisma.PostCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCategoryPayload>
          }
          update: {
            args: Prisma.PostCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCategoryPayload>
          }
          deleteMany: {
            args: Prisma.PostCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCategoryPayload>[]
          }
          upsert: {
            args: Prisma.PostCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCategoryPayload>
          }
          aggregate: {
            args: Prisma.PostCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostCategory>
          }
          groupBy: {
            args: Prisma.PostCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<PostCategoryCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      EmailSetting: {
        payload: Prisma.$EmailSettingPayload<ExtArgs>
        fields: Prisma.EmailSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSettingPayload>
          }
          findFirst: {
            args: Prisma.EmailSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSettingPayload>
          }
          findMany: {
            args: Prisma.EmailSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSettingPayload>[]
          }
          create: {
            args: Prisma.EmailSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSettingPayload>
          }
          createMany: {
            args: Prisma.EmailSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSettingPayload>[]
          }
          delete: {
            args: Prisma.EmailSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSettingPayload>
          }
          update: {
            args: Prisma.EmailSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSettingPayload>
          }
          deleteMany: {
            args: Prisma.EmailSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSettingPayload>[]
          }
          upsert: {
            args: Prisma.EmailSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSettingPayload>
          }
          aggregate: {
            args: Prisma.EmailSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailSetting>
          }
          groupBy: {
            args: Prisma.EmailSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailSettingCountArgs<ExtArgs>
            result: $Utils.Optional<EmailSettingCountAggregateOutputType> | number
          }
        }
      }
      EmailTemplate: {
        payload: Prisma.$EmailTemplatePayload<ExtArgs>
        fields: Prisma.EmailTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findFirst: {
            args: Prisma.EmailTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findMany: {
            args: Prisma.EmailTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          create: {
            args: Prisma.EmailTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          createMany: {
            args: Prisma.EmailTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          delete: {
            args: Prisma.EmailTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          update: {
            args: Prisma.EmailTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          deleteMany: {
            args: Prisma.EmailTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          upsert: {
            args: Prisma.EmailTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          aggregate: {
            args: Prisma.EmailTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailTemplate>
          }
          groupBy: {
            args: Prisma.EmailTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<EmailTemplateCountAggregateOutputType> | number
          }
        }
      }
      EmailAudience: {
        payload: Prisma.$EmailAudiencePayload<ExtArgs>
        fields: Prisma.EmailAudienceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailAudienceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAudiencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailAudienceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAudiencePayload>
          }
          findFirst: {
            args: Prisma.EmailAudienceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAudiencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailAudienceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAudiencePayload>
          }
          findMany: {
            args: Prisma.EmailAudienceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAudiencePayload>[]
          }
          create: {
            args: Prisma.EmailAudienceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAudiencePayload>
          }
          createMany: {
            args: Prisma.EmailAudienceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailAudienceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAudiencePayload>[]
          }
          delete: {
            args: Prisma.EmailAudienceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAudiencePayload>
          }
          update: {
            args: Prisma.EmailAudienceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAudiencePayload>
          }
          deleteMany: {
            args: Prisma.EmailAudienceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailAudienceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailAudienceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAudiencePayload>[]
          }
          upsert: {
            args: Prisma.EmailAudienceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAudiencePayload>
          }
          aggregate: {
            args: Prisma.EmailAudienceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailAudience>
          }
          groupBy: {
            args: Prisma.EmailAudienceGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailAudienceGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailAudienceCountArgs<ExtArgs>
            result: $Utils.Optional<EmailAudienceCountAggregateOutputType> | number
          }
        }
      }
      EmailContact: {
        payload: Prisma.$EmailContactPayload<ExtArgs>
        fields: Prisma.EmailContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactPayload>
          }
          findFirst: {
            args: Prisma.EmailContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactPayload>
          }
          findMany: {
            args: Prisma.EmailContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactPayload>[]
          }
          create: {
            args: Prisma.EmailContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactPayload>
          }
          createMany: {
            args: Prisma.EmailContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactPayload>[]
          }
          delete: {
            args: Prisma.EmailContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactPayload>
          }
          update: {
            args: Prisma.EmailContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactPayload>
          }
          deleteMany: {
            args: Prisma.EmailContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactPayload>[]
          }
          upsert: {
            args: Prisma.EmailContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactPayload>
          }
          aggregate: {
            args: Prisma.EmailContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailContact>
          }
          groupBy: {
            args: Prisma.EmailContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailContactCountArgs<ExtArgs>
            result: $Utils.Optional<EmailContactCountAggregateOutputType> | number
          }
        }
      }
      EmailContactInteraction: {
        payload: Prisma.$EmailContactInteractionPayload<ExtArgs>
        fields: Prisma.EmailContactInteractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailContactInteractionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactInteractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailContactInteractionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactInteractionPayload>
          }
          findFirst: {
            args: Prisma.EmailContactInteractionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactInteractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailContactInteractionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactInteractionPayload>
          }
          findMany: {
            args: Prisma.EmailContactInteractionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactInteractionPayload>[]
          }
          create: {
            args: Prisma.EmailContactInteractionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactInteractionPayload>
          }
          createMany: {
            args: Prisma.EmailContactInteractionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailContactInteractionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactInteractionPayload>[]
          }
          delete: {
            args: Prisma.EmailContactInteractionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactInteractionPayload>
          }
          update: {
            args: Prisma.EmailContactInteractionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactInteractionPayload>
          }
          deleteMany: {
            args: Prisma.EmailContactInteractionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailContactInteractionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailContactInteractionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactInteractionPayload>[]
          }
          upsert: {
            args: Prisma.EmailContactInteractionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailContactInteractionPayload>
          }
          aggregate: {
            args: Prisma.EmailContactInteractionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailContactInteraction>
          }
          groupBy: {
            args: Prisma.EmailContactInteractionGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailContactInteractionGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailContactInteractionCountArgs<ExtArgs>
            result: $Utils.Optional<EmailContactInteractionCountAggregateOutputType> | number
          }
        }
      }
      EmailSingleSend: {
        payload: Prisma.$EmailSingleSendPayload<ExtArgs>
        fields: Prisma.EmailSingleSendFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailSingleSendFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSingleSendPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailSingleSendFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSingleSendPayload>
          }
          findFirst: {
            args: Prisma.EmailSingleSendFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSingleSendPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailSingleSendFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSingleSendPayload>
          }
          findMany: {
            args: Prisma.EmailSingleSendFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSingleSendPayload>[]
          }
          create: {
            args: Prisma.EmailSingleSendCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSingleSendPayload>
          }
          createMany: {
            args: Prisma.EmailSingleSendCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailSingleSendCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSingleSendPayload>[]
          }
          delete: {
            args: Prisma.EmailSingleSendDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSingleSendPayload>
          }
          update: {
            args: Prisma.EmailSingleSendUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSingleSendPayload>
          }
          deleteMany: {
            args: Prisma.EmailSingleSendDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailSingleSendUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailSingleSendUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSingleSendPayload>[]
          }
          upsert: {
            args: Prisma.EmailSingleSendUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSingleSendPayload>
          }
          aggregate: {
            args: Prisma.EmailSingleSendAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailSingleSend>
          }
          groupBy: {
            args: Prisma.EmailSingleSendGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailSingleSendGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailSingleSendCountArgs<ExtArgs>
            result: $Utils.Optional<EmailSingleSendCountAggregateOutputType> | number
          }
        }
      }
      EmailSubscriptionToken: {
        payload: Prisma.$EmailSubscriptionTokenPayload<ExtArgs>
        fields: Prisma.EmailSubscriptionTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailSubscriptionTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSubscriptionTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailSubscriptionTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSubscriptionTokenPayload>
          }
          findFirst: {
            args: Prisma.EmailSubscriptionTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSubscriptionTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailSubscriptionTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSubscriptionTokenPayload>
          }
          findMany: {
            args: Prisma.EmailSubscriptionTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSubscriptionTokenPayload>[]
          }
          create: {
            args: Prisma.EmailSubscriptionTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSubscriptionTokenPayload>
          }
          createMany: {
            args: Prisma.EmailSubscriptionTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailSubscriptionTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSubscriptionTokenPayload>[]
          }
          delete: {
            args: Prisma.EmailSubscriptionTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSubscriptionTokenPayload>
          }
          update: {
            args: Prisma.EmailSubscriptionTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSubscriptionTokenPayload>
          }
          deleteMany: {
            args: Prisma.EmailSubscriptionTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailSubscriptionTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailSubscriptionTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSubscriptionTokenPayload>[]
          }
          upsert: {
            args: Prisma.EmailSubscriptionTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSubscriptionTokenPayload>
          }
          aggregate: {
            args: Prisma.EmailSubscriptionTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailSubscriptionToken>
          }
          groupBy: {
            args: Prisma.EmailSubscriptionTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailSubscriptionTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailSubscriptionTokenCountArgs<ExtArgs>
            result: $Utils.Optional<EmailSubscriptionTokenCountAggregateOutputType> | number
          }
        }
      }
      EmailSendLog: {
        payload: Prisma.$EmailSendLogPayload<ExtArgs>
        fields: Prisma.EmailSendLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailSendLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSendLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailSendLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSendLogPayload>
          }
          findFirst: {
            args: Prisma.EmailSendLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSendLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailSendLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSendLogPayload>
          }
          findMany: {
            args: Prisma.EmailSendLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSendLogPayload>[]
          }
          create: {
            args: Prisma.EmailSendLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSendLogPayload>
          }
          createMany: {
            args: Prisma.EmailSendLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailSendLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSendLogPayload>[]
          }
          delete: {
            args: Prisma.EmailSendLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSendLogPayload>
          }
          update: {
            args: Prisma.EmailSendLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSendLogPayload>
          }
          deleteMany: {
            args: Prisma.EmailSendLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailSendLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailSendLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSendLogPayload>[]
          }
          upsert: {
            args: Prisma.EmailSendLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSendLogPayload>
          }
          aggregate: {
            args: Prisma.EmailSendLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailSendLog>
          }
          groupBy: {
            args: Prisma.EmailSendLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailSendLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailSendLogCountArgs<ExtArgs>
            result: $Utils.Optional<EmailSendLogCountAggregateOutputType> | number
          }
        }
      }
      EmailSingleSendLog: {
        payload: Prisma.$EmailSingleSendLogPayload<ExtArgs>
        fields: Prisma.EmailSingleSendLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailSingleSendLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSingleSendLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailSingleSendLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSingleSendLogPayload>
          }
          findFirst: {
            args: Prisma.EmailSingleSendLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSingleSendLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailSingleSendLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSingleSendLogPayload>
          }
          findMany: {
            args: Prisma.EmailSingleSendLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSingleSendLogPayload>[]
          }
          create: {
            args: Prisma.EmailSingleSendLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSingleSendLogPayload>
          }
          createMany: {
            args: Prisma.EmailSingleSendLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailSingleSendLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSingleSendLogPayload>[]
          }
          delete: {
            args: Prisma.EmailSingleSendLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSingleSendLogPayload>
          }
          update: {
            args: Prisma.EmailSingleSendLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSingleSendLogPayload>
          }
          deleteMany: {
            args: Prisma.EmailSingleSendLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailSingleSendLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailSingleSendLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSingleSendLogPayload>[]
          }
          upsert: {
            args: Prisma.EmailSingleSendLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSingleSendLogPayload>
          }
          aggregate: {
            args: Prisma.EmailSingleSendLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailSingleSendLog>
          }
          groupBy: {
            args: Prisma.EmailSingleSendLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailSingleSendLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailSingleSendLogCountArgs<ExtArgs>
            result: $Utils.Optional<EmailSingleSendLogCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductCategory: {
        payload: Prisma.$ProductCategoryPayload<ExtArgs>
        fields: Prisma.ProductCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findFirst: {
            args: Prisma.ProductCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findMany: {
            args: Prisma.ProductCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          create: {
            args: Prisma.ProductCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          createMany: {
            args: Prisma.ProductCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          delete: {
            args: Prisma.ProductCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          update: {
            args: Prisma.ProductCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ProductCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProductCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCategory>
          }
          groupBy: {
            args: Prisma.ProductCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryCountAggregateOutputType> | number
          }
        }
      }
      ProductGallery: {
        payload: Prisma.$ProductGalleryPayload<ExtArgs>
        fields: Prisma.ProductGalleryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductGalleryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGalleryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductGalleryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGalleryPayload>
          }
          findFirst: {
            args: Prisma.ProductGalleryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGalleryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductGalleryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGalleryPayload>
          }
          findMany: {
            args: Prisma.ProductGalleryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGalleryPayload>[]
          }
          create: {
            args: Prisma.ProductGalleryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGalleryPayload>
          }
          createMany: {
            args: Prisma.ProductGalleryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductGalleryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGalleryPayload>[]
          }
          delete: {
            args: Prisma.ProductGalleryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGalleryPayload>
          }
          update: {
            args: Prisma.ProductGalleryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGalleryPayload>
          }
          deleteMany: {
            args: Prisma.ProductGalleryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductGalleryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductGalleryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGalleryPayload>[]
          }
          upsert: {
            args: Prisma.ProductGalleryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGalleryPayload>
          }
          aggregate: {
            args: Prisma.ProductGalleryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductGallery>
          }
          groupBy: {
            args: Prisma.ProductGalleryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGalleryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductGalleryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductGalleryCountAggregateOutputType> | number
          }
        }
      }
      ProductExtra: {
        payload: Prisma.$ProductExtraPayload<ExtArgs>
        fields: Prisma.ProductExtraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductExtraFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductExtraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductExtraFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductExtraPayload>
          }
          findFirst: {
            args: Prisma.ProductExtraFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductExtraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductExtraFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductExtraPayload>
          }
          findMany: {
            args: Prisma.ProductExtraFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductExtraPayload>[]
          }
          create: {
            args: Prisma.ProductExtraCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductExtraPayload>
          }
          createMany: {
            args: Prisma.ProductExtraCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductExtraCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductExtraPayload>[]
          }
          delete: {
            args: Prisma.ProductExtraDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductExtraPayload>
          }
          update: {
            args: Prisma.ProductExtraUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductExtraPayload>
          }
          deleteMany: {
            args: Prisma.ProductExtraDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductExtraUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductExtraUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductExtraPayload>[]
          }
          upsert: {
            args: Prisma.ProductExtraUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductExtraPayload>
          }
          aggregate: {
            args: Prisma.ProductExtraAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductExtra>
          }
          groupBy: {
            args: Prisma.ProductExtraGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductExtraGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductExtraCountArgs<ExtArgs>
            result: $Utils.Optional<ProductExtraCountAggregateOutputType> | number
          }
        }
      }
      ProductFAQ: {
        payload: Prisma.$ProductFAQPayload<ExtArgs>
        fields: Prisma.ProductFAQFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFAQFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFAQPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFAQFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFAQPayload>
          }
          findFirst: {
            args: Prisma.ProductFAQFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFAQPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFAQFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFAQPayload>
          }
          findMany: {
            args: Prisma.ProductFAQFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFAQPayload>[]
          }
          create: {
            args: Prisma.ProductFAQCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFAQPayload>
          }
          createMany: {
            args: Prisma.ProductFAQCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductFAQCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFAQPayload>[]
          }
          delete: {
            args: Prisma.ProductFAQDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFAQPayload>
          }
          update: {
            args: Prisma.ProductFAQUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFAQPayload>
          }
          deleteMany: {
            args: Prisma.ProductFAQDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductFAQUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductFAQUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFAQPayload>[]
          }
          upsert: {
            args: Prisma.ProductFAQUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFAQPayload>
          }
          aggregate: {
            args: Prisma.ProductFAQAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductFAQ>
          }
          groupBy: {
            args: Prisma.ProductFAQGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductFAQGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductFAQCountArgs<ExtArgs>
            result: $Utils.Optional<ProductFAQCountAggregateOutputType> | number
          }
        }
      }
      AdCampaign: {
        payload: Prisma.$AdCampaignPayload<ExtArgs>
        fields: Prisma.AdCampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdCampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdCampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdCampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdCampaignPayload>
          }
          findFirst: {
            args: Prisma.AdCampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdCampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdCampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdCampaignPayload>
          }
          findMany: {
            args: Prisma.AdCampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdCampaignPayload>[]
          }
          create: {
            args: Prisma.AdCampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdCampaignPayload>
          }
          createMany: {
            args: Prisma.AdCampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdCampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdCampaignPayload>[]
          }
          delete: {
            args: Prisma.AdCampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdCampaignPayload>
          }
          update: {
            args: Prisma.AdCampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdCampaignPayload>
          }
          deleteMany: {
            args: Prisma.AdCampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdCampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdCampaignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdCampaignPayload>[]
          }
          upsert: {
            args: Prisma.AdCampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdCampaignPayload>
          }
          aggregate: {
            args: Prisma.AdCampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdCampaign>
          }
          groupBy: {
            args: Prisma.AdCampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdCampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdCampaignCountArgs<ExtArgs>
            result: $Utils.Optional<AdCampaignCountAggregateOutputType> | number
          }
        }
      }
      AdBlock: {
        payload: Prisma.$AdBlockPayload<ExtArgs>
        fields: Prisma.AdBlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdBlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdBlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdBlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdBlockPayload>
          }
          findFirst: {
            args: Prisma.AdBlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdBlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdBlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdBlockPayload>
          }
          findMany: {
            args: Prisma.AdBlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdBlockPayload>[]
          }
          create: {
            args: Prisma.AdBlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdBlockPayload>
          }
          createMany: {
            args: Prisma.AdBlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdBlockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdBlockPayload>[]
          }
          delete: {
            args: Prisma.AdBlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdBlockPayload>
          }
          update: {
            args: Prisma.AdBlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdBlockPayload>
          }
          deleteMany: {
            args: Prisma.AdBlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdBlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdBlockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdBlockPayload>[]
          }
          upsert: {
            args: Prisma.AdBlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdBlockPayload>
          }
          aggregate: {
            args: Prisma.AdBlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdBlock>
          }
          groupBy: {
            args: Prisma.AdBlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdBlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdBlockCountArgs<ExtArgs>
            result: $Utils.Optional<AdBlockCountAggregateOutputType> | number
          }
        }
      }
      AdItem: {
        payload: Prisma.$AdItemPayload<ExtArgs>
        fields: Prisma.AdItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdItemPayload>
          }
          findFirst: {
            args: Prisma.AdItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdItemPayload>
          }
          findMany: {
            args: Prisma.AdItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdItemPayload>[]
          }
          create: {
            args: Prisma.AdItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdItemPayload>
          }
          createMany: {
            args: Prisma.AdItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdItemPayload>[]
          }
          delete: {
            args: Prisma.AdItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdItemPayload>
          }
          update: {
            args: Prisma.AdItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdItemPayload>
          }
          deleteMany: {
            args: Prisma.AdItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdItemPayload>[]
          }
          upsert: {
            args: Prisma.AdItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdItemPayload>
          }
          aggregate: {
            args: Prisma.AdItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdItem>
          }
          groupBy: {
            args: Prisma.AdItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdItemCountArgs<ExtArgs>
            result: $Utils.Optional<AdItemCountAggregateOutputType> | number
          }
        }
      }
      Purchase: {
        payload: Prisma.$PurchasePayload<ExtArgs>
        fields: Prisma.PurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findFirst: {
            args: Prisma.PurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findMany: {
            args: Prisma.PurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          create: {
            args: Prisma.PurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          createMany: {
            args: Prisma.PurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          delete: {
            args: Prisma.PurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          update: {
            args: Prisma.PurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          upsert: {
            args: Prisma.PurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          aggregate: {
            args: Prisma.PurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchase>
          }
          groupBy: {
            args: Prisma.PurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseCountAggregateOutputType> | number
          }
        }
      }
      ContactForm: {
        payload: Prisma.$ContactFormPayload<ExtArgs>
        fields: Prisma.ContactFormFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFormFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFormFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormPayload>
          }
          findFirst: {
            args: Prisma.ContactFormFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFormFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormPayload>
          }
          findMany: {
            args: Prisma.ContactFormFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormPayload>[]
          }
          create: {
            args: Prisma.ContactFormCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormPayload>
          }
          createMany: {
            args: Prisma.ContactFormCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactFormCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormPayload>[]
          }
          delete: {
            args: Prisma.ContactFormDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormPayload>
          }
          update: {
            args: Prisma.ContactFormUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormPayload>
          }
          deleteMany: {
            args: Prisma.ContactFormDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactFormUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactFormUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormPayload>[]
          }
          upsert: {
            args: Prisma.ContactFormUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormPayload>
          }
          aggregate: {
            args: Prisma.ContactFormAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactForm>
          }
          groupBy: {
            args: Prisma.ContactFormGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactFormCountArgs<ExtArgs>
            result: $Utils.Optional<ContactFormCountAggregateOutputType> | number
          }
        }
      }
      Form: {
        payload: Prisma.$FormPayload<ExtArgs>
        fields: Prisma.FormFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          findFirst: {
            args: Prisma.FormFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          findMany: {
            args: Prisma.FormFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>[]
          }
          create: {
            args: Prisma.FormCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          createMany: {
            args: Prisma.FormCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>[]
          }
          delete: {
            args: Prisma.FormDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          update: {
            args: Prisma.FormUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          deleteMany: {
            args: Prisma.FormDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FormUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>[]
          }
          upsert: {
            args: Prisma.FormUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          aggregate: {
            args: Prisma.FormAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForm>
          }
          groupBy: {
            args: Prisma.FormGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormCountArgs<ExtArgs>
            result: $Utils.Optional<FormCountAggregateOutputType> | number
          }
        }
      }
      FormSubmission: {
        payload: Prisma.$FormSubmissionPayload<ExtArgs>
        fields: Prisma.FormSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          findFirst: {
            args: Prisma.FormSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          findMany: {
            args: Prisma.FormSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>[]
          }
          create: {
            args: Prisma.FormSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          createMany: {
            args: Prisma.FormSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormSubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>[]
          }
          delete: {
            args: Prisma.FormSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          update: {
            args: Prisma.FormSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.FormSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FormSubmissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>[]
          }
          upsert: {
            args: Prisma.FormSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          aggregate: {
            args: Prisma.FormSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormSubmission>
          }
          groupBy: {
            args: Prisma.FormSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<FormSubmissionCountAggregateOutputType> | number
          }
        }
      }
      Format: {
        payload: Prisma.$FormatPayload<ExtArgs>
        fields: Prisma.FormatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormatPayload>
          }
          findFirst: {
            args: Prisma.FormatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormatPayload>
          }
          findMany: {
            args: Prisma.FormatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormatPayload>[]
          }
          create: {
            args: Prisma.FormatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormatPayload>
          }
          createMany: {
            args: Prisma.FormatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormatPayload>[]
          }
          delete: {
            args: Prisma.FormatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormatPayload>
          }
          update: {
            args: Prisma.FormatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormatPayload>
          }
          deleteMany: {
            args: Prisma.FormatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FormatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormatPayload>[]
          }
          upsert: {
            args: Prisma.FormatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormatPayload>
          }
          aggregate: {
            args: Prisma.FormatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormat>
          }
          groupBy: {
            args: Prisma.FormatGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormatGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormatCountArgs<ExtArgs>
            result: $Utils.Optional<FormatCountAggregateOutputType> | number
          }
        }
      }
      Genre: {
        payload: Prisma.$GenrePayload<ExtArgs>
        fields: Prisma.GenreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GenreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GenreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          findFirst: {
            args: Prisma.GenreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GenreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          findMany: {
            args: Prisma.GenreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          create: {
            args: Prisma.GenreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          createMany: {
            args: Prisma.GenreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GenreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          delete: {
            args: Prisma.GenreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          update: {
            args: Prisma.GenreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          deleteMany: {
            args: Prisma.GenreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GenreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GenreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          upsert: {
            args: Prisma.GenreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          aggregate: {
            args: Prisma.GenreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGenre>
          }
          groupBy: {
            args: Prisma.GenreGroupByArgs<ExtArgs>
            result: $Utils.Optional<GenreGroupByOutputType>[]
          }
          count: {
            args: Prisma.GenreCountArgs<ExtArgs>
            result: $Utils.Optional<GenreCountAggregateOutputType> | number
          }
        }
      }
      Impression: {
        payload: Prisma.$ImpressionPayload<ExtArgs>
        fields: Prisma.ImpressionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImpressionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpressionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImpressionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpressionPayload>
          }
          findFirst: {
            args: Prisma.ImpressionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpressionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImpressionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpressionPayload>
          }
          findMany: {
            args: Prisma.ImpressionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpressionPayload>[]
          }
          create: {
            args: Prisma.ImpressionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpressionPayload>
          }
          createMany: {
            args: Prisma.ImpressionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImpressionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpressionPayload>[]
          }
          delete: {
            args: Prisma.ImpressionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpressionPayload>
          }
          update: {
            args: Prisma.ImpressionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpressionPayload>
          }
          deleteMany: {
            args: Prisma.ImpressionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImpressionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImpressionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpressionPayload>[]
          }
          upsert: {
            args: Prisma.ImpressionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpressionPayload>
          }
          aggregate: {
            args: Prisma.ImpressionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImpression>
          }
          groupBy: {
            args: Prisma.ImpressionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImpressionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImpressionCountArgs<ExtArgs>
            result: $Utils.Optional<ImpressionCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      SocialChannel: {
        payload: Prisma.$SocialChannelPayload<ExtArgs>
        fields: Prisma.SocialChannelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialChannelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialChannelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialChannelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialChannelPayload>
          }
          findFirst: {
            args: Prisma.SocialChannelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialChannelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialChannelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialChannelPayload>
          }
          findMany: {
            args: Prisma.SocialChannelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialChannelPayload>[]
          }
          create: {
            args: Prisma.SocialChannelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialChannelPayload>
          }
          createMany: {
            args: Prisma.SocialChannelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SocialChannelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialChannelPayload>[]
          }
          delete: {
            args: Prisma.SocialChannelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialChannelPayload>
          }
          update: {
            args: Prisma.SocialChannelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialChannelPayload>
          }
          deleteMany: {
            args: Prisma.SocialChannelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialChannelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SocialChannelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialChannelPayload>[]
          }
          upsert: {
            args: Prisma.SocialChannelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialChannelPayload>
          }
          aggregate: {
            args: Prisma.SocialChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialChannel>
          }
          groupBy: {
            args: Prisma.SocialChannelGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialChannelGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialChannelCountArgs<ExtArgs>
            result: $Utils.Optional<SocialChannelCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    language?: LanguageOmit
    settings?: SettingsOmit
    widget?: WidgetOmit
    session?: SessionOmit
    verification?: VerificationOmit
    user?: UserOmit
    account?: AccountOmit
    verificationToken?: VerificationTokenOmit
    passwordResetToken?: PasswordResetTokenOmit
    media?: MediaOmit
    seo?: SeoOmit
    post?: PostOmit
    postAuthor?: PostAuthorOmit
    category?: CategoryOmit
    postCategory?: PostCategoryOmit
    tag?: TagOmit
    emailSetting?: EmailSettingOmit
    emailTemplate?: EmailTemplateOmit
    emailAudience?: EmailAudienceOmit
    emailContact?: EmailContactOmit
    emailContactInteraction?: EmailContactInteractionOmit
    emailSingleSend?: EmailSingleSendOmit
    emailSubscriptionToken?: EmailSubscriptionTokenOmit
    emailSendLog?: EmailSendLogOmit
    emailSingleSendLog?: EmailSingleSendLogOmit
    product?: ProductOmit
    productCategory?: ProductCategoryOmit
    productGallery?: ProductGalleryOmit
    productExtra?: ProductExtraOmit
    productFAQ?: ProductFAQOmit
    adCampaign?: AdCampaignOmit
    adBlock?: AdBlockOmit
    adItem?: AdItemOmit
    purchase?: PurchaseOmit
    contactForm?: ContactFormOmit
    form?: FormOmit
    formSubmission?: FormSubmissionOmit
    format?: FormatOmit
    genre?: GenreOmit
    impression?: ImpressionOmit
    notification?: NotificationOmit
    socialChannel?: SocialChannelOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    posts: number
    postAuthors: number
    notifications: number
    products: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    posts?: boolean | UserCountOutputTypeCountPostsArgs
    postAuthors?: boolean | UserCountOutputTypeCountPostAuthorsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    products?: boolean | UserCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostAuthorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostAuthorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type MediaCountOutputType
   */

  export type MediaCountOutputType = {
    post: number
    seo: number
    product: number
    products: number
    user: number
  }

  export type MediaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | MediaCountOutputTypeCountPostArgs
    seo?: boolean | MediaCountOutputTypeCountSeoArgs
    product?: boolean | MediaCountOutputTypeCountProductArgs
    products?: boolean | MediaCountOutputTypeCountProductsArgs
    user?: boolean | MediaCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCountOutputType
     */
    select?: MediaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountSeoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeoWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductGalleryWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type SeoCountOutputType
   */

  export type SeoCountOutputType = {
    rootChildren: number
    settings: number
    posts: number
    categories: number
    tags: number
    products: number
    productCategories: number
  }

  export type SeoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rootChildren?: boolean | SeoCountOutputTypeCountRootChildrenArgs
    settings?: boolean | SeoCountOutputTypeCountSettingsArgs
    posts?: boolean | SeoCountOutputTypeCountPostsArgs
    categories?: boolean | SeoCountOutputTypeCountCategoriesArgs
    tags?: boolean | SeoCountOutputTypeCountTagsArgs
    products?: boolean | SeoCountOutputTypeCountProductsArgs
    productCategories?: boolean | SeoCountOutputTypeCountProductCategoriesArgs
  }

  // Custom InputTypes
  /**
   * SeoCountOutputType without action
   */
  export type SeoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoCountOutputType
     */
    select?: SeoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeoCountOutputType without action
   */
  export type SeoCountOutputTypeCountRootChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeoWhereInput
  }

  /**
   * SeoCountOutputType without action
   */
  export type SeoCountOutputTypeCountSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsWhereInput
  }

  /**
   * SeoCountOutputType without action
   */
  export type SeoCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * SeoCountOutputType without action
   */
  export type SeoCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * SeoCountOutputType without action
   */
  export type SeoCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * SeoCountOutputType without action
   */
  export type SeoCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * SeoCountOutputType without action
   */
  export type SeoCountOutputTypeCountProductCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    rootChildren: number
    postCategories: number
    tags: number
    postAuthors: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rootChildren?: boolean | PostCountOutputTypeCountRootChildrenArgs
    postCategories?: boolean | PostCountOutputTypeCountPostCategoriesArgs
    tags?: boolean | PostCountOutputTypeCountTagsArgs
    postAuthors?: boolean | PostCountOutputTypeCountPostAuthorsArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountRootChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountPostCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostCategoryWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountPostAuthorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostAuthorWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    rootChildren: number
    postCategories: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rootChildren?: boolean | CategoryCountOutputTypeCountRootChildrenArgs
    postCategories?: boolean | CategoryCountOutputTypeCountPostCategoriesArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountRootChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountPostCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostCategoryWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    rootChildren: number
    posts: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rootChildren?: boolean | TagCountOutputTypeCountRootChildrenArgs
    posts?: boolean | TagCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountRootChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }


  /**
   * Count Type EmailTemplateCountOutputType
   */

  export type EmailTemplateCountOutputType = {
    emailSettingSubscription: number
    emailSettingFreeEbook: number
    emailSettingWebinar: number
  }

  export type EmailTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailSettingSubscription?: boolean | EmailTemplateCountOutputTypeCountEmailSettingSubscriptionArgs
    emailSettingFreeEbook?: boolean | EmailTemplateCountOutputTypeCountEmailSettingFreeEbookArgs
    emailSettingWebinar?: boolean | EmailTemplateCountOutputTypeCountEmailSettingWebinarArgs
  }

  // Custom InputTypes
  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplateCountOutputType
     */
    select?: EmailTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeCountEmailSettingSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailSettingWhereInput
  }

  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeCountEmailSettingFreeEbookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailSettingWhereInput
  }

  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeCountEmailSettingWebinarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailSettingWhereInput
  }


  /**
   * Count Type EmailAudienceCountOutputType
   */

  export type EmailAudienceCountOutputType = {
    contacts: number
    emailSingleSends: number
  }

  export type EmailAudienceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | EmailAudienceCountOutputTypeCountContactsArgs
    emailSingleSends?: boolean | EmailAudienceCountOutputTypeCountEmailSingleSendsArgs
  }

  // Custom InputTypes
  /**
   * EmailAudienceCountOutputType without action
   */
  export type EmailAudienceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAudienceCountOutputType
     */
    select?: EmailAudienceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailAudienceCountOutputType without action
   */
  export type EmailAudienceCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailContactWhereInput
  }

  /**
   * EmailAudienceCountOutputType without action
   */
  export type EmailAudienceCountOutputTypeCountEmailSingleSendsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailSingleSendWhereInput
  }


  /**
   * Count Type EmailContactCountOutputType
   */

  export type EmailContactCountOutputType = {
    audiences: number
    interactions: number
    emailSingleSendLogs: number
  }

  export type EmailContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audiences?: boolean | EmailContactCountOutputTypeCountAudiencesArgs
    interactions?: boolean | EmailContactCountOutputTypeCountInteractionsArgs
    emailSingleSendLogs?: boolean | EmailContactCountOutputTypeCountEmailSingleSendLogsArgs
  }

  // Custom InputTypes
  /**
   * EmailContactCountOutputType without action
   */
  export type EmailContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContactCountOutputType
     */
    select?: EmailContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailContactCountOutputType without action
   */
  export type EmailContactCountOutputTypeCountAudiencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAudienceWhereInput
  }

  /**
   * EmailContactCountOutputType without action
   */
  export type EmailContactCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailContactInteractionWhereInput
  }

  /**
   * EmailContactCountOutputType without action
   */
  export type EmailContactCountOutputTypeCountEmailSingleSendLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailSingleSendLogWhereInput
  }


  /**
   * Count Type EmailSingleSendCountOutputType
   */

  export type EmailSingleSendCountOutputType = {
    audiences: number
    emailSingleSendLogs: number
  }

  export type EmailSingleSendCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audiences?: boolean | EmailSingleSendCountOutputTypeCountAudiencesArgs
    emailSingleSendLogs?: boolean | EmailSingleSendCountOutputTypeCountEmailSingleSendLogsArgs
  }

  // Custom InputTypes
  /**
   * EmailSingleSendCountOutputType without action
   */
  export type EmailSingleSendCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSendCountOutputType
     */
    select?: EmailSingleSendCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailSingleSendCountOutputType without action
   */
  export type EmailSingleSendCountOutputTypeCountAudiencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAudienceWhereInput
  }

  /**
   * EmailSingleSendCountOutputType without action
   */
  export type EmailSingleSendCountOutputTypeCountEmailSingleSendLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailSingleSendLogWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    extras: number
    rootChildren: number
    gallery: number
    faqs: number
    purchases: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    extras?: boolean | ProductCountOutputTypeCountExtrasArgs
    rootChildren?: boolean | ProductCountOutputTypeCountRootChildrenArgs
    gallery?: boolean | ProductCountOutputTypeCountGalleryArgs
    faqs?: boolean | ProductCountOutputTypeCountFaqsArgs
    purchases?: boolean | ProductCountOutputTypeCountPurchasesArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountExtrasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductExtraWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountRootChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountGalleryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductGalleryWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountFaqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductFAQWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }


  /**
   * Count Type ProductCategoryCountOutputType
   */

  export type ProductCategoryCountOutputType = {
    rootChildren: number
    products: number
  }

  export type ProductCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rootChildren?: boolean | ProductCategoryCountOutputTypeCountRootChildrenArgs
    products?: boolean | ProductCategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategoryCountOutputType
     */
    select?: ProductCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountRootChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type AdCampaignCountOutputType
   */

  export type AdCampaignCountOutputType = {
    blocks: number
  }

  export type AdCampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocks?: boolean | AdCampaignCountOutputTypeCountBlocksArgs
  }

  // Custom InputTypes
  /**
   * AdCampaignCountOutputType without action
   */
  export type AdCampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdCampaignCountOutputType
     */
    select?: AdCampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdCampaignCountOutputType without action
   */
  export type AdCampaignCountOutputTypeCountBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdBlockWhereInput
  }


  /**
   * Count Type AdBlockCountOutputType
   */

  export type AdBlockCountOutputType = {
    items: number
  }

  export type AdBlockCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | AdBlockCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * AdBlockCountOutputType without action
   */
  export type AdBlockCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdBlockCountOutputType
     */
    select?: AdBlockCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdBlockCountOutputType without action
   */
  export type AdBlockCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdItemWhereInput
  }


  /**
   * Count Type FormCountOutputType
   */

  export type FormCountOutputType = {
    products: number
    submissions: number
  }

  export type FormCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | FormCountOutputTypeCountProductsArgs
    submissions?: boolean | FormCountOutputTypeCountSubmissionsArgs
  }

  // Custom InputTypes
  /**
   * FormCountOutputType without action
   */
  export type FormCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormCountOutputType
     */
    select?: FormCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FormCountOutputType without action
   */
  export type FormCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * FormCountOutputType without action
   */
  export type FormCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormSubmissionWhereInput
  }


  /**
   * Count Type FormatCountOutputType
   */

  export type FormatCountOutputType = {
    Impression: number
  }

  export type FormatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Impression?: boolean | FormatCountOutputTypeCountImpressionArgs
  }

  // Custom InputTypes
  /**
   * FormatCountOutputType without action
   */
  export type FormatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormatCountOutputType
     */
    select?: FormatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FormatCountOutputType without action
   */
  export type FormatCountOutputTypeCountImpressionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImpressionWhereInput
  }


  /**
   * Count Type GenreCountOutputType
   */

  export type GenreCountOutputType = {
    Impression: number
  }

  export type GenreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Impression?: boolean | GenreCountOutputTypeCountImpressionArgs
  }

  // Custom InputTypes
  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreCountOutputType
     */
    select?: GenreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeCountImpressionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImpressionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Language
   */

  export type AggregateLanguage = {
    _count: LanguageCountAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  export type LanguageMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    slug: string | null
    isActive: boolean | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LanguageMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    slug: string | null
    isActive: boolean | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LanguageCountAggregateOutputType = {
    id: number
    code: number
    name: number
    slug: number
    isActive: number
    isDefault: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LanguageMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    slug?: true
    isActive?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LanguageMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    slug?: true
    isActive?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LanguageCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    slug?: true
    isActive?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Language to aggregate.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Languages
    **/
    _count?: true | LanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageMaxAggregateInputType
  }

  export type GetLanguageAggregateType<T extends LanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguage[P]>
      : GetScalarType<T[P], AggregateLanguage[P]>
  }




  export type LanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageWhereInput
    orderBy?: LanguageOrderByWithAggregationInput | LanguageOrderByWithAggregationInput[]
    by: LanguageScalarFieldEnum[] | LanguageScalarFieldEnum
    having?: LanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageCountAggregateInputType | true
    _min?: LanguageMinAggregateInputType
    _max?: LanguageMaxAggregateInputType
  }

  export type LanguageGroupByOutputType = {
    id: string
    code: string
    name: string
    slug: string | null
    isActive: boolean
    isDefault: boolean
    createdAt: Date
    updatedAt: Date
    _count: LanguageCountAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  type GetLanguageGroupByPayload<T extends LanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageGroupByOutputType[P]>
        }
      >
    >


  export type LanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    slug?: boolean
    isActive?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    slug?: boolean
    isActive?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    slug?: boolean
    isActive?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    slug?: boolean
    isActive?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LanguageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "slug" | "isActive" | "isDefault" | "createdAt" | "updatedAt", ExtArgs["result"]["language"]>

  export type $LanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Language"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      slug: string | null
      isActive: boolean
      isDefault: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["language"]>
    composites: {}
  }

  type LanguageGetPayload<S extends boolean | null | undefined | LanguageDefaultArgs> = $Result.GetResult<Prisma.$LanguagePayload, S>

  type LanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LanguageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LanguageCountAggregateInputType | true
    }

  export interface LanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Language'], meta: { name: 'Language' } }
    /**
     * Find zero or one Language that matches the filter.
     * @param {LanguageFindUniqueArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LanguageFindUniqueArgs>(args: SelectSubset<T, LanguageFindUniqueArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Language that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LanguageFindUniqueOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, LanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LanguageFindFirstArgs>(args?: SelectSubset<T, LanguageFindFirstArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Language that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, LanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.language.findMany()
     * 
     * // Get first 10 Languages
     * const languages = await prisma.language.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const languageWithIdOnly = await prisma.language.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LanguageFindManyArgs>(args?: SelectSubset<T, LanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Language.
     * @param {LanguageCreateArgs} args - Arguments to create a Language.
     * @example
     * // Create one Language
     * const Language = await prisma.language.create({
     *   data: {
     *     // ... data to create a Language
     *   }
     * })
     * 
     */
    create<T extends LanguageCreateArgs>(args: SelectSubset<T, LanguageCreateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Languages.
     * @param {LanguageCreateManyArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LanguageCreateManyArgs>(args?: SelectSubset<T, LanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Languages and returns the data saved in the database.
     * @param {LanguageCreateManyAndReturnArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Languages and only return the `id`
     * const languageWithIdOnly = await prisma.language.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LanguageCreateManyAndReturnArgs>(args?: SelectSubset<T, LanguageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Language.
     * @param {LanguageDeleteArgs} args - Arguments to delete one Language.
     * @example
     * // Delete one Language
     * const Language = await prisma.language.delete({
     *   where: {
     *     // ... filter to delete one Language
     *   }
     * })
     * 
     */
    delete<T extends LanguageDeleteArgs>(args: SelectSubset<T, LanguageDeleteArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Language.
     * @param {LanguageUpdateArgs} args - Arguments to update one Language.
     * @example
     * // Update one Language
     * const language = await prisma.language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LanguageUpdateArgs>(args: SelectSubset<T, LanguageUpdateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Languages.
     * @param {LanguageDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LanguageDeleteManyArgs>(args?: SelectSubset<T, LanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LanguageUpdateManyArgs>(args: SelectSubset<T, LanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages and returns the data updated in the database.
     * @param {LanguageUpdateManyAndReturnArgs} args - Arguments to update many Languages.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Languages and only return the `id`
     * const languageWithIdOnly = await prisma.language.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LanguageUpdateManyAndReturnArgs>(args: SelectSubset<T, LanguageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Language.
     * @param {LanguageUpsertArgs} args - Arguments to update or create a Language.
     * @example
     * // Update or create a Language
     * const language = await prisma.language.upsert({
     *   create: {
     *     // ... data to create a Language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Language we want to update
     *   }
     * })
     */
    upsert<T extends LanguageUpsertArgs>(args: SelectSubset<T, LanguageUpsertArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.language.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
    **/
    count<T extends LanguageCountArgs>(
      args?: Subset<T, LanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageAggregateArgs>(args: Subset<T, LanguageAggregateArgs>): Prisma.PrismaPromise<GetLanguageAggregateType<T>>

    /**
     * Group by Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageGroupByArgs['orderBy'] }
        : { orderBy?: LanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Language model
   */
  readonly fields: LanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Language model
   */
  interface LanguageFieldRefs {
    readonly id: FieldRef<"Language", 'String'>
    readonly code: FieldRef<"Language", 'String'>
    readonly name: FieldRef<"Language", 'String'>
    readonly slug: FieldRef<"Language", 'String'>
    readonly isActive: FieldRef<"Language", 'Boolean'>
    readonly isDefault: FieldRef<"Language", 'Boolean'>
    readonly createdAt: FieldRef<"Language", 'DateTime'>
    readonly updatedAt: FieldRef<"Language", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Language findUnique
   */
  export type LanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findUniqueOrThrow
   */
  export type LanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findFirst
   */
  export type LanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findFirstOrThrow
   */
  export type LanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findMany
   */
  export type LanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Filter, which Languages to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language create
   */
  export type LanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * The data needed to create a Language.
     */
    data: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
  }

  /**
   * Language createMany
   */
  export type LanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language createManyAndReturn
   */
  export type LanguageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language update
   */
  export type LanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * The data needed to update a Language.
     */
    data: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
    /**
     * Choose, which Language to update.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language updateMany
   */
  export type LanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to update.
     */
    limit?: number
  }

  /**
   * Language updateManyAndReturn
   */
  export type LanguageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to update.
     */
    limit?: number
  }

  /**
   * Language upsert
   */
  export type LanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * The filter to search for the Language to update in case it exists.
     */
    where: LanguageWhereUniqueInput
    /**
     * In case the Language found by the `where` argument doesn't exist, create a new Language with this data.
     */
    create: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
    /**
     * In case the Language was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
  }

  /**
   * Language delete
   */
  export type LanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Filter which Language to delete.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language deleteMany
   */
  export type LanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Languages to delete
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to delete.
     */
    limit?: number
  }

  /**
   * Language without action
   */
  export type LanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
  }


  /**
   * Model Settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsMinAggregateOutputType = {
    id: string | null
    siteName: string | null
    siteUrl: string | null
    deployWebhookUrl: string | null
    logoUrl: string | null
    seoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingsMaxAggregateOutputType = {
    id: string | null
    siteName: string | null
    siteUrl: string | null
    deployWebhookUrl: string | null
    logoUrl: string | null
    seoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingsCountAggregateOutputType = {
    id: number
    siteName: number
    siteUrl: number
    deployWebhookUrl: number
    logoUrl: number
    scripts:PrismaJson.Scripts
    seoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SettingsMinAggregateInputType = {
    id?: true
    siteName?: true
    siteUrl?: true
    deployWebhookUrl?: true
    logoUrl?: true
    seoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingsMaxAggregateInputType = {
    id?: true
    siteName?: true
    siteUrl?: true
    deployWebhookUrl?: true
    logoUrl?: true
    seoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingsCountAggregateInputType = {
    id?: true
    siteName?: true
    siteUrl?: true
    deployWebhookUrl?: true
    logoUrl?: true
    scripts?: true
    seoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to aggregate.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type SettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsWhereInput
    orderBy?: SettingsOrderByWithAggregationInput | SettingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: SettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }

  export type SettingsGroupByOutputType = {
    id: string
    siteName: string | null
    siteUrl: string | null
    deployWebhookUrl: string | null
    logoUrl: string | null
    scripts:PrismaJson.Scripts
    seoId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends SettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type SettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteName?: boolean
    siteUrl?: boolean
    deployWebhookUrl?: boolean
    logoUrl?: boolean
    scripts?: boolean
    seoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seo?: boolean | Settings$seoArgs<ExtArgs>
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteName?: boolean
    siteUrl?: boolean
    deployWebhookUrl?: boolean
    logoUrl?: boolean
    scripts?: boolean
    seoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seo?: boolean | Settings$seoArgs<ExtArgs>
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteName?: boolean
    siteUrl?: boolean
    deployWebhookUrl?: boolean
    logoUrl?: boolean
    scripts?: boolean
    seoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seo?: boolean | Settings$seoArgs<ExtArgs>
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectScalar = {
    id?: boolean
    siteName?: boolean
    siteUrl?: boolean
    deployWebhookUrl?: boolean
    logoUrl?: boolean
    scripts?: boolean
    seoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "siteName" | "siteUrl" | "deployWebhookUrl" | "logoUrl" | "scripts" | "seoId" | "createdAt" | "updatedAt", ExtArgs["result"]["settings"]>
  export type SettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seo?: boolean | Settings$seoArgs<ExtArgs>
  }
  export type SettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seo?: boolean | Settings$seoArgs<ExtArgs>
  }
  export type SettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seo?: boolean | Settings$seoArgs<ExtArgs>
  }

  export type $SettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Settings"
    objects: {
      seo: Prisma.$SeoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      siteName: string | null
      siteUrl: string | null
      deployWebhookUrl: string | null
      logoUrl: string | null
      /**
       * [Scripts]
       */
      scripts:PrismaJson.Scripts
      seoId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["settings"]>
    composites: {}
  }

  type SettingsGetPayload<S extends boolean | null | undefined | SettingsDefaultArgs> = $Result.GetResult<Prisma.$SettingsPayload, S>

  type SettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface SettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Settings'], meta: { name: 'Settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {SettingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingsFindUniqueArgs>(args: SelectSubset<T, SettingsFindUniqueArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingsFindFirstArgs>(args?: SelectSubset<T, SettingsFindFirstArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingsFindManyArgs>(args?: SelectSubset<T, SettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settings.
     * @param {SettingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
     */
    create<T extends SettingsCreateArgs>(args: SelectSubset<T, SettingsCreateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingsCreateManyArgs>(args?: SelectSubset<T, SettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingsCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Settings.
     * @param {SettingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
     */
    delete<T extends SettingsDeleteArgs>(args: SelectSubset<T, SettingsDeleteArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settings.
     * @param {SettingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingsUpdateArgs>(args: SelectSubset<T, SettingsUpdateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingsDeleteManyArgs>(args?: SelectSubset<T, SettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingsUpdateManyArgs>(args: SelectSubset<T, SettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingsUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Settings.
     * @param {SettingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends SettingsUpsertArgs>(args: SelectSubset<T, SettingsUpsertArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingsCountArgs>(
      args?: Subset<T, SettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingsGroupByArgs['orderBy'] }
        : { orderBy?: SettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Settings model
   */
  readonly fields: SettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seo<T extends Settings$seoArgs<ExtArgs> = {}>(args?: Subset<T, Settings$seoArgs<ExtArgs>>): Prisma__SeoClient<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Settings model
   */
  interface SettingsFieldRefs {
    readonly id: FieldRef<"Settings", 'String'>
    readonly siteName: FieldRef<"Settings", 'String'>
    readonly siteUrl: FieldRef<"Settings", 'String'>
    readonly deployWebhookUrl: FieldRef<"Settings", 'String'>
    readonly logoUrl: FieldRef<"Settings", 'String'>
    readonly scripts: FieldRef<"Settings", 'Json'>
    readonly seoId: FieldRef<"Settings", 'String'>
    readonly createdAt: FieldRef<"Settings", 'DateTime'>
    readonly updatedAt: FieldRef<"Settings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Settings findUnique
   */
  export type SettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findUniqueOrThrow
   */
  export type SettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findFirst
   */
  export type SettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findFirstOrThrow
   */
  export type SettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findMany
   */
  export type SettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings create
   */
  export type SettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a Settings.
     */
    data: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
  }

  /**
   * Settings createMany
   */
  export type SettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Settings createManyAndReturn
   */
  export type SettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Settings update
   */
  export type SettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a Settings.
     */
    data: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
    /**
     * Choose, which Settings to update.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings updateMany
   */
  export type SettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings updateManyAndReturn
   */
  export type SettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Settings upsert
   */
  export type SettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the Settings to update in case it exists.
     */
    where: SettingsWhereUniqueInput
    /**
     * In case the Settings found by the `where` argument doesn't exist, create a new Settings with this data.
     */
    create: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
    /**
     * In case the Settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
  }

  /**
   * Settings delete
   */
  export type SettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter which Settings to delete.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings deleteMany
   */
  export type SettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Settings.seo
   */
  export type Settings$seoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    where?: SeoWhereInput
  }

  /**
   * Settings without action
   */
  export type SettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
  }


  /**
   * Model Widget
   */

  export type AggregateWidget = {
    _count: WidgetCountAggregateOutputType | null
    _avg: WidgetAvgAggregateOutputType | null
    _sum: WidgetSumAggregateOutputType | null
    _min: WidgetMinAggregateOutputType | null
    _max: WidgetMaxAggregateOutputType | null
  }

  export type WidgetAvgAggregateOutputType = {
    sort: number | null
  }

  export type WidgetSumAggregateOutputType = {
    sort: number | null
  }

  export type WidgetMinAggregateOutputType = {
    id: string | null
    name: string | null
    section: $Enums.WidgetSection | null
    type: $Enums.WidgetType | null
    sort: number | null
    isEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WidgetMaxAggregateOutputType = {
    id: string | null
    name: string | null
    section: $Enums.WidgetSection | null
    type: $Enums.WidgetType | null
    sort: number | null
    isEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WidgetCountAggregateOutputType = {
    id: number
    name: number
    section: number
    type: number
    sort: number
    isEnabled: number
    metadata:PrismaJson.WidgetMetadata
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WidgetAvgAggregateInputType = {
    sort?: true
  }

  export type WidgetSumAggregateInputType = {
    sort?: true
  }

  export type WidgetMinAggregateInputType = {
    id?: true
    name?: true
    section?: true
    type?: true
    sort?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WidgetMaxAggregateInputType = {
    id?: true
    name?: true
    section?: true
    type?: true
    sort?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WidgetCountAggregateInputType = {
    id?: true
    name?: true
    section?: true
    type?: true
    sort?: true
    isEnabled?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WidgetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Widget to aggregate.
     */
    where?: WidgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Widgets to fetch.
     */
    orderBy?: WidgetOrderByWithRelationInput | WidgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WidgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Widgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Widgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Widgets
    **/
    _count?: true | WidgetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WidgetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WidgetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WidgetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WidgetMaxAggregateInputType
  }

  export type GetWidgetAggregateType<T extends WidgetAggregateArgs> = {
        [P in keyof T & keyof AggregateWidget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWidget[P]>
      : GetScalarType<T[P], AggregateWidget[P]>
  }




  export type WidgetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WidgetWhereInput
    orderBy?: WidgetOrderByWithAggregationInput | WidgetOrderByWithAggregationInput[]
    by: WidgetScalarFieldEnum[] | WidgetScalarFieldEnum
    having?: WidgetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WidgetCountAggregateInputType | true
    _avg?: WidgetAvgAggregateInputType
    _sum?: WidgetSumAggregateInputType
    _min?: WidgetMinAggregateInputType
    _max?: WidgetMaxAggregateInputType
  }

  export type WidgetGroupByOutputType = {
    id: string
    name: string
    section: $Enums.WidgetSection
    type: $Enums.WidgetType
    sort: number
    isEnabled: boolean
    metadata:PrismaJson.WidgetMetadata | null
    createdAt: Date
    updatedAt: Date
    _count: WidgetCountAggregateOutputType | null
    _avg: WidgetAvgAggregateOutputType | null
    _sum: WidgetSumAggregateOutputType | null
    _min: WidgetMinAggregateOutputType | null
    _max: WidgetMaxAggregateOutputType | null
  }

  type GetWidgetGroupByPayload<T extends WidgetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WidgetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WidgetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WidgetGroupByOutputType[P]>
            : GetScalarType<T[P], WidgetGroupByOutputType[P]>
        }
      >
    >


  export type WidgetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    section?: boolean
    type?: boolean
    sort?: boolean
    isEnabled?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["widget"]>

  export type WidgetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    section?: boolean
    type?: boolean
    sort?: boolean
    isEnabled?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["widget"]>

  export type WidgetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    section?: boolean
    type?: boolean
    sort?: boolean
    isEnabled?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["widget"]>

  export type WidgetSelectScalar = {
    id?: boolean
    name?: boolean
    section?: boolean
    type?: boolean
    sort?: boolean
    isEnabled?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WidgetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "section" | "type" | "sort" | "isEnabled" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["widget"]>

  export type $WidgetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Widget"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      section: $Enums.WidgetSection
      type: $Enums.WidgetType
      sort: number
      isEnabled: boolean
      /**
       * [WidgetMetadata]
       */
      metadata:PrismaJson.WidgetMetadata | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["widget"]>
    composites: {}
  }

  type WidgetGetPayload<S extends boolean | null | undefined | WidgetDefaultArgs> = $Result.GetResult<Prisma.$WidgetPayload, S>

  type WidgetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WidgetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WidgetCountAggregateInputType | true
    }

  export interface WidgetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Widget'], meta: { name: 'Widget' } }
    /**
     * Find zero or one Widget that matches the filter.
     * @param {WidgetFindUniqueArgs} args - Arguments to find a Widget
     * @example
     * // Get one Widget
     * const widget = await prisma.widget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WidgetFindUniqueArgs>(args: SelectSubset<T, WidgetFindUniqueArgs<ExtArgs>>): Prisma__WidgetClient<$Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Widget that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WidgetFindUniqueOrThrowArgs} args - Arguments to find a Widget
     * @example
     * // Get one Widget
     * const widget = await prisma.widget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WidgetFindUniqueOrThrowArgs>(args: SelectSubset<T, WidgetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WidgetClient<$Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Widget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetFindFirstArgs} args - Arguments to find a Widget
     * @example
     * // Get one Widget
     * const widget = await prisma.widget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WidgetFindFirstArgs>(args?: SelectSubset<T, WidgetFindFirstArgs<ExtArgs>>): Prisma__WidgetClient<$Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Widget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetFindFirstOrThrowArgs} args - Arguments to find a Widget
     * @example
     * // Get one Widget
     * const widget = await prisma.widget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WidgetFindFirstOrThrowArgs>(args?: SelectSubset<T, WidgetFindFirstOrThrowArgs<ExtArgs>>): Prisma__WidgetClient<$Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Widgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Widgets
     * const widgets = await prisma.widget.findMany()
     * 
     * // Get first 10 Widgets
     * const widgets = await prisma.widget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const widgetWithIdOnly = await prisma.widget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WidgetFindManyArgs>(args?: SelectSubset<T, WidgetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Widget.
     * @param {WidgetCreateArgs} args - Arguments to create a Widget.
     * @example
     * // Create one Widget
     * const Widget = await prisma.widget.create({
     *   data: {
     *     // ... data to create a Widget
     *   }
     * })
     * 
     */
    create<T extends WidgetCreateArgs>(args: SelectSubset<T, WidgetCreateArgs<ExtArgs>>): Prisma__WidgetClient<$Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Widgets.
     * @param {WidgetCreateManyArgs} args - Arguments to create many Widgets.
     * @example
     * // Create many Widgets
     * const widget = await prisma.widget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WidgetCreateManyArgs>(args?: SelectSubset<T, WidgetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Widgets and returns the data saved in the database.
     * @param {WidgetCreateManyAndReturnArgs} args - Arguments to create many Widgets.
     * @example
     * // Create many Widgets
     * const widget = await prisma.widget.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Widgets and only return the `id`
     * const widgetWithIdOnly = await prisma.widget.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WidgetCreateManyAndReturnArgs>(args?: SelectSubset<T, WidgetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Widget.
     * @param {WidgetDeleteArgs} args - Arguments to delete one Widget.
     * @example
     * // Delete one Widget
     * const Widget = await prisma.widget.delete({
     *   where: {
     *     // ... filter to delete one Widget
     *   }
     * })
     * 
     */
    delete<T extends WidgetDeleteArgs>(args: SelectSubset<T, WidgetDeleteArgs<ExtArgs>>): Prisma__WidgetClient<$Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Widget.
     * @param {WidgetUpdateArgs} args - Arguments to update one Widget.
     * @example
     * // Update one Widget
     * const widget = await prisma.widget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WidgetUpdateArgs>(args: SelectSubset<T, WidgetUpdateArgs<ExtArgs>>): Prisma__WidgetClient<$Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Widgets.
     * @param {WidgetDeleteManyArgs} args - Arguments to filter Widgets to delete.
     * @example
     * // Delete a few Widgets
     * const { count } = await prisma.widget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WidgetDeleteManyArgs>(args?: SelectSubset<T, WidgetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Widgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Widgets
     * const widget = await prisma.widget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WidgetUpdateManyArgs>(args: SelectSubset<T, WidgetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Widgets and returns the data updated in the database.
     * @param {WidgetUpdateManyAndReturnArgs} args - Arguments to update many Widgets.
     * @example
     * // Update many Widgets
     * const widget = await prisma.widget.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Widgets and only return the `id`
     * const widgetWithIdOnly = await prisma.widget.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WidgetUpdateManyAndReturnArgs>(args: SelectSubset<T, WidgetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Widget.
     * @param {WidgetUpsertArgs} args - Arguments to update or create a Widget.
     * @example
     * // Update or create a Widget
     * const widget = await prisma.widget.upsert({
     *   create: {
     *     // ... data to create a Widget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Widget we want to update
     *   }
     * })
     */
    upsert<T extends WidgetUpsertArgs>(args: SelectSubset<T, WidgetUpsertArgs<ExtArgs>>): Prisma__WidgetClient<$Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Widgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetCountArgs} args - Arguments to filter Widgets to count.
     * @example
     * // Count the number of Widgets
     * const count = await prisma.widget.count({
     *   where: {
     *     // ... the filter for the Widgets we want to count
     *   }
     * })
    **/
    count<T extends WidgetCountArgs>(
      args?: Subset<T, WidgetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WidgetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Widget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WidgetAggregateArgs>(args: Subset<T, WidgetAggregateArgs>): Prisma.PrismaPromise<GetWidgetAggregateType<T>>

    /**
     * Group by Widget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WidgetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WidgetGroupByArgs['orderBy'] }
        : { orderBy?: WidgetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WidgetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWidgetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Widget model
   */
  readonly fields: WidgetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Widget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WidgetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Widget model
   */
  interface WidgetFieldRefs {
    readonly id: FieldRef<"Widget", 'String'>
    readonly name: FieldRef<"Widget", 'String'>
    readonly section: FieldRef<"Widget", 'WidgetSection'>
    readonly type: FieldRef<"Widget", 'WidgetType'>
    readonly sort: FieldRef<"Widget", 'Int'>
    readonly isEnabled: FieldRef<"Widget", 'Boolean'>
    readonly metadata: FieldRef<"Widget", 'Json'>
    readonly createdAt: FieldRef<"Widget", 'DateTime'>
    readonly updatedAt: FieldRef<"Widget", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Widget findUnique
   */
  export type WidgetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
    /**
     * Filter, which Widget to fetch.
     */
    where: WidgetWhereUniqueInput
  }

  /**
   * Widget findUniqueOrThrow
   */
  export type WidgetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
    /**
     * Filter, which Widget to fetch.
     */
    where: WidgetWhereUniqueInput
  }

  /**
   * Widget findFirst
   */
  export type WidgetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
    /**
     * Filter, which Widget to fetch.
     */
    where?: WidgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Widgets to fetch.
     */
    orderBy?: WidgetOrderByWithRelationInput | WidgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Widgets.
     */
    cursor?: WidgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Widgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Widgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Widgets.
     */
    distinct?: WidgetScalarFieldEnum | WidgetScalarFieldEnum[]
  }

  /**
   * Widget findFirstOrThrow
   */
  export type WidgetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
    /**
     * Filter, which Widget to fetch.
     */
    where?: WidgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Widgets to fetch.
     */
    orderBy?: WidgetOrderByWithRelationInput | WidgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Widgets.
     */
    cursor?: WidgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Widgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Widgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Widgets.
     */
    distinct?: WidgetScalarFieldEnum | WidgetScalarFieldEnum[]
  }

  /**
   * Widget findMany
   */
  export type WidgetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
    /**
     * Filter, which Widgets to fetch.
     */
    where?: WidgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Widgets to fetch.
     */
    orderBy?: WidgetOrderByWithRelationInput | WidgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Widgets.
     */
    cursor?: WidgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Widgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Widgets.
     */
    skip?: number
    distinct?: WidgetScalarFieldEnum | WidgetScalarFieldEnum[]
  }

  /**
   * Widget create
   */
  export type WidgetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
    /**
     * The data needed to create a Widget.
     */
    data: XOR<WidgetCreateInput, WidgetUncheckedCreateInput>
  }

  /**
   * Widget createMany
   */
  export type WidgetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Widgets.
     */
    data: WidgetCreateManyInput | WidgetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Widget createManyAndReturn
   */
  export type WidgetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
    /**
     * The data used to create many Widgets.
     */
    data: WidgetCreateManyInput | WidgetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Widget update
   */
  export type WidgetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
    /**
     * The data needed to update a Widget.
     */
    data: XOR<WidgetUpdateInput, WidgetUncheckedUpdateInput>
    /**
     * Choose, which Widget to update.
     */
    where: WidgetWhereUniqueInput
  }

  /**
   * Widget updateMany
   */
  export type WidgetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Widgets.
     */
    data: XOR<WidgetUpdateManyMutationInput, WidgetUncheckedUpdateManyInput>
    /**
     * Filter which Widgets to update
     */
    where?: WidgetWhereInput
    /**
     * Limit how many Widgets to update.
     */
    limit?: number
  }

  /**
   * Widget updateManyAndReturn
   */
  export type WidgetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
    /**
     * The data used to update Widgets.
     */
    data: XOR<WidgetUpdateManyMutationInput, WidgetUncheckedUpdateManyInput>
    /**
     * Filter which Widgets to update
     */
    where?: WidgetWhereInput
    /**
     * Limit how many Widgets to update.
     */
    limit?: number
  }

  /**
   * Widget upsert
   */
  export type WidgetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
    /**
     * The filter to search for the Widget to update in case it exists.
     */
    where: WidgetWhereUniqueInput
    /**
     * In case the Widget found by the `where` argument doesn't exist, create a new Widget with this data.
     */
    create: XOR<WidgetCreateInput, WidgetUncheckedCreateInput>
    /**
     * In case the Widget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WidgetUpdateInput, WidgetUncheckedUpdateInput>
  }

  /**
   * Widget delete
   */
  export type WidgetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
    /**
     * Filter which Widget to delete.
     */
    where: WidgetWhereUniqueInput
  }

  /**
   * Widget deleteMany
   */
  export type WidgetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Widgets to delete
     */
    where?: WidgetWhereInput
    /**
     * Limit how many Widgets to delete.
     */
    limit?: number
  }

  /**
   * Widget without action
   */
  export type WidgetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    expiresAt: number
    token: number
    createdAt: number
    updatedAt: number
    ipAddress: number
    userAgent: number
    userId: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    expiresAt: Date
    token: string
    createdAt: Date
    updatedAt: Date
    ipAddress: string | null
    userAgent: string | null
    userId: string
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expiresAt" | "token" | "createdAt" | "updatedAt" | "ipAddress" | "userAgent" | "userId", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expiresAt: Date
      token: string
      createdAt: Date
      updatedAt: Date
      ipAddress: string | null
      userAgent: string | null
      userId: string
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly token: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    firstName: string | null
    lastName: string | null
    password: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    profileImageId: string | null
    bio: string | null
    imageUrl: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    firstName: string | null
    lastName: string | null
    password: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    profileImageId: string | null
    bio: string | null
    imageUrl: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    firstName: number
    lastName: number
    password: number
    email: number
    emailVerified: number
    image: number
    profileImageId: number
    bio: number
    imageUrl: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    firstName?: true
    lastName?: true
    password?: true
    email?: true
    emailVerified?: true
    image?: true
    profileImageId?: true
    bio?: true
    imageUrl?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    firstName?: true
    lastName?: true
    password?: true
    email?: true
    emailVerified?: true
    image?: true
    profileImageId?: true
    bio?: true
    imageUrl?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    firstName?: true
    lastName?: true
    password?: true
    email?: true
    emailVerified?: true
    image?: true
    profileImageId?: true
    bio?: true
    imageUrl?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    firstName: string | null
    lastName: string | null
    password: string | null
    email: string | null
    emailVerified: boolean
    image: string | null
    profileImageId: string | null
    bio: string | null
    imageUrl: string | null
    role: $Enums.UserRole
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    profileImageId?: boolean
    bio?: boolean
    imageUrl?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileImage?: boolean | User$profileImageArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    postAuthors?: boolean | User$postAuthorsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    products?: boolean | User$productsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    profileImageId?: boolean
    bio?: boolean
    imageUrl?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileImage?: boolean | User$profileImageArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    profileImageId?: boolean
    bio?: boolean
    imageUrl?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileImage?: boolean | User$profileImageArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    profileImageId?: boolean
    bio?: boolean
    imageUrl?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "firstName" | "lastName" | "password" | "email" | "emailVerified" | "image" | "profileImageId" | "bio" | "imageUrl" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profileImage?: boolean | User$profileImageArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    postAuthors?: boolean | User$postAuthorsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    products?: boolean | User$productsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profileImage?: boolean | User$profileImageArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profileImage?: boolean | User$profileImageArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profileImage: Prisma.$MediaPayload<ExtArgs> | null
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      postAuthors: Prisma.$PostAuthorPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      firstName: string | null
      lastName: string | null
      password: string | null
      email: string | null
      emailVerified: boolean
      image: string | null
      profileImageId: string | null
      bio: string | null
      imageUrl: string | null
      role: $Enums.UserRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profileImage<T extends User$profileImageArgs<ExtArgs> = {}>(args?: Subset<T, User$profileImageArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends User$postsArgs<ExtArgs> = {}>(args?: Subset<T, User$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    postAuthors<T extends User$postAuthorsArgs<ExtArgs> = {}>(args?: Subset<T, User$postAuthorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostAuthorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends User$productsArgs<ExtArgs> = {}>(args?: Subset<T, User$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly profileImageId: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly imageUrl: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.profileImage
   */
  export type User$profileImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.posts
   */
  export type User$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * User.postAuthors
   */
  export type User$postAuthorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAuthor
     */
    select?: PostAuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAuthor
     */
    omit?: PostAuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAuthorInclude<ExtArgs> | null
    where?: PostAuthorWhereInput
    orderBy?: PostAuthorOrderByWithRelationInput | PostAuthorOrderByWithRelationInput[]
    cursor?: PostAuthorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostAuthorScalarFieldEnum | PostAuthorScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.products
   */
  export type User$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
    scope: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
    scope: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    accountId: number
    providerId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    password: number
    createdAt: number
    updatedAt: number
    scope: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    scope?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    scope?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    scope?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    accountId: string
    providerId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    scope: string | null
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    scope?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    scope?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    scope?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    scope?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "accountId" | "providerId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "password" | "createdAt" | "updatedAt" | "scope", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      accountId: string
      providerId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      password: string | null
      createdAt: Date
      updatedAt: Date
      scope: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    id: number
    email: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    id: string
    email: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationTokenWithIdOnly = await prisma.verificationToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `id`
     * const verificationTokenWithIdOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `id`
     * const verificationTokenWithIdOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly id: FieldRef<"VerificationToken", 'String'>
    readonly email: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    email: number
    token: number
    expires: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: string
    email: string
    token: string
    expires: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }

  export type PasswordResetTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "token" | "expires", ExtArgs["result"]["passwordResetToken"]>

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      token: string
      expires: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens and returns the data updated in the database.
     * @param {PasswordResetTokenUpdateManyAndReturnArgs} args - Arguments to update many PasswordResetTokens.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'String'>
    readonly email: FieldRef<"PasswordResetToken", 'String'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly expires: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken updateManyAndReturn
   */
  export type PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to delete.
     */
    limit?: number
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
  }


  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaAvgAggregateOutputType = {
    size: number | null
  }

  export type MediaSumAggregateOutputType = {
    size: number | null
  }

  export type MediaMinAggregateOutputType = {
    id: string | null
    name: string | null
    key: string | null
    url: string | null
    size: number | null
    type: $Enums.MediaType | null
    altText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaMaxAggregateOutputType = {
    id: string | null
    name: string | null
    key: string | null
    url: string | null
    size: number | null
    type: $Enums.MediaType | null
    altText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    name: number
    key: number
    url: number
    size: number
    type: number
    altText: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MediaAvgAggregateInputType = {
    size?: true
  }

  export type MediaSumAggregateInputType = {
    size?: true
  }

  export type MediaMinAggregateInputType = {
    id?: true
    name?: true
    key?: true
    url?: true
    size?: true
    type?: true
    altText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    name?: true
    key?: true
    url?: true
    size?: true
    type?: true
    altText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    name?: true
    key?: true
    url?: true
    size?: true
    type?: true
    altText?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _avg?: MediaAvgAggregateInputType
    _sum?: MediaSumAggregateInputType
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: string
    name: string
    key: string | null
    url: string
    size: number | null
    type: $Enums.MediaType
    altText: string | null
    createdAt: Date
    updatedAt: Date
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    key?: boolean
    url?: boolean
    size?: boolean
    type?: boolean
    altText?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | Media$postArgs<ExtArgs>
    seo?: boolean | Media$seoArgs<ExtArgs>
    product?: boolean | Media$productArgs<ExtArgs>
    impression?: boolean | Media$impressionArgs<ExtArgs>
    products?: boolean | Media$productsArgs<ExtArgs>
    user?: boolean | Media$userArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    key?: boolean
    url?: boolean
    size?: boolean
    type?: boolean
    altText?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["media"]>

  export type MediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    key?: boolean
    url?: boolean
    size?: boolean
    type?: boolean
    altText?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["media"]>

  export type MediaSelectScalar = {
    id?: boolean
    name?: boolean
    key?: boolean
    url?: boolean
    size?: boolean
    type?: boolean
    altText?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "key" | "url" | "size" | "type" | "altText" | "createdAt" | "updatedAt", ExtArgs["result"]["media"]>
  export type MediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | Media$postArgs<ExtArgs>
    seo?: boolean | Media$seoArgs<ExtArgs>
    product?: boolean | Media$productArgs<ExtArgs>
    impression?: boolean | Media$impressionArgs<ExtArgs>
    products?: boolean | Media$productsArgs<ExtArgs>
    user?: boolean | Media$userArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>[]
      seo: Prisma.$SeoPayload<ExtArgs>[]
      product: Prisma.$ProductPayload<ExtArgs>[]
      impression: Prisma.$ImpressionPayload<ExtArgs> | null
      products: Prisma.$ProductGalleryPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      key: string | null
      url: string
      size: number | null
      type: $Enums.MediaType
      altText: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Media'], meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Media and returns the data saved in the database.
     * @param {MediaCreateManyAndReturnArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media and returns the data updated in the database.
     * @param {MediaUpdateManyAndReturnArgs} args - Arguments to update many Media.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MediaUpdateManyAndReturnArgs>(args: SelectSubset<T, MediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends Media$postArgs<ExtArgs> = {}>(args?: Subset<T, Media$postArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seo<T extends Media$seoArgs<ExtArgs> = {}>(args?: Subset<T, Media$seoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    product<T extends Media$productArgs<ExtArgs> = {}>(args?: Subset<T, Media$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    impression<T extends Media$impressionArgs<ExtArgs> = {}>(args?: Subset<T, Media$impressionArgs<ExtArgs>>): Prisma__ImpressionClient<$Result.GetResult<Prisma.$ImpressionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    products<T extends Media$productsArgs<ExtArgs> = {}>(args?: Subset<T, Media$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends Media$userArgs<ExtArgs> = {}>(args?: Subset<T, Media$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'String'>
    readonly name: FieldRef<"Media", 'String'>
    readonly key: FieldRef<"Media", 'String'>
    readonly url: FieldRef<"Media", 'String'>
    readonly size: FieldRef<"Media", 'Int'>
    readonly type: FieldRef<"Media", 'MediaType'>
    readonly altText: FieldRef<"Media", 'String'>
    readonly createdAt: FieldRef<"Media", 'DateTime'>
    readonly updatedAt: FieldRef<"Media", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media createManyAndReturn
   */
  export type MediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
  }

  /**
   * Media updateManyAndReturn
   */
  export type MediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to delete.
     */
    limit?: number
  }

  /**
   * Media.post
   */
  export type Media$postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Media.seo
   */
  export type Media$seoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    where?: SeoWhereInput
    orderBy?: SeoOrderByWithRelationInput | SeoOrderByWithRelationInput[]
    cursor?: SeoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeoScalarFieldEnum | SeoScalarFieldEnum[]
  }

  /**
   * Media.product
   */
  export type Media$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Media.impression
   */
  export type Media$impressionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionInclude<ExtArgs> | null
    where?: ImpressionWhereInput
  }

  /**
   * Media.products
   */
  export type Media$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryInclude<ExtArgs> | null
    where?: ProductGalleryWhereInput
    orderBy?: ProductGalleryOrderByWithRelationInput | ProductGalleryOrderByWithRelationInput[]
    cursor?: ProductGalleryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductGalleryScalarFieldEnum | ProductGalleryScalarFieldEnum[]
  }

  /**
   * Media.user
   */
  export type Media$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
  }


  /**
   * Model Seo
   */

  export type AggregateSeo = {
    _count: SeoCountAggregateOutputType | null
    _avg: SeoAvgAggregateOutputType | null
    _sum: SeoSumAggregateOutputType | null
    _min: SeoMinAggregateOutputType | null
    _max: SeoMaxAggregateOutputType | null
  }

  export type SeoAvgAggregateOutputType = {
    version: number | null
  }

  export type SeoSumAggregateOutputType = {
    version: number | null
  }

  export type SeoMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    canonicalUrl: string | null
    version: number | null
    noIndex: boolean | null
    noFollow: boolean | null
    ogTwitterType: string | null
    ogTwitterTitle: string | null
    ogTwitterDescription: string | null
    ogTwitterImageId: string | null
    ogTwitterLocale: string | null
    ogTwitterUrl: string | null
    rootId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeoMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    canonicalUrl: string | null
    version: number | null
    noIndex: boolean | null
    noFollow: boolean | null
    ogTwitterType: string | null
    ogTwitterTitle: string | null
    ogTwitterDescription: string | null
    ogTwitterImageId: string | null
    ogTwitterLocale: string | null
    ogTwitterUrl: string | null
    rootId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeoCountAggregateOutputType = {
    id: number
    title: number
    description: number
    canonicalUrl: number
    version: number
    noIndex: number
    noFollow: number
    ogTwitterType: number
    ogTwitterTitle: number
    ogTwitterDescription: number
    ogTwitterImageId: number
    ogTwitterLocale: number
    ogTwitterUrl: number
    rootId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SeoAvgAggregateInputType = {
    version?: true
  }

  export type SeoSumAggregateInputType = {
    version?: true
  }

  export type SeoMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    canonicalUrl?: true
    version?: true
    noIndex?: true
    noFollow?: true
    ogTwitterType?: true
    ogTwitterTitle?: true
    ogTwitterDescription?: true
    ogTwitterImageId?: true
    ogTwitterLocale?: true
    ogTwitterUrl?: true
    rootId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeoMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    canonicalUrl?: true
    version?: true
    noIndex?: true
    noFollow?: true
    ogTwitterType?: true
    ogTwitterTitle?: true
    ogTwitterDescription?: true
    ogTwitterImageId?: true
    ogTwitterLocale?: true
    ogTwitterUrl?: true
    rootId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeoCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    canonicalUrl?: true
    version?: true
    noIndex?: true
    noFollow?: true
    ogTwitterType?: true
    ogTwitterTitle?: true
    ogTwitterDescription?: true
    ogTwitterImageId?: true
    ogTwitterLocale?: true
    ogTwitterUrl?: true
    rootId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SeoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seo to aggregate.
     */
    where?: SeoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seos to fetch.
     */
    orderBy?: SeoOrderByWithRelationInput | SeoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Seos
    **/
    _count?: true | SeoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeoMaxAggregateInputType
  }

  export type GetSeoAggregateType<T extends SeoAggregateArgs> = {
        [P in keyof T & keyof AggregateSeo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeo[P]>
      : GetScalarType<T[P], AggregateSeo[P]>
  }




  export type SeoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeoWhereInput
    orderBy?: SeoOrderByWithAggregationInput | SeoOrderByWithAggregationInput[]
    by: SeoScalarFieldEnum[] | SeoScalarFieldEnum
    having?: SeoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeoCountAggregateInputType | true
    _avg?: SeoAvgAggregateInputType
    _sum?: SeoSumAggregateInputType
    _min?: SeoMinAggregateInputType
    _max?: SeoMaxAggregateInputType
  }

  export type SeoGroupByOutputType = {
    id: string
    title: string
    description: string | null
    canonicalUrl: string | null
    version: number
    noIndex: boolean
    noFollow: boolean
    ogTwitterType: string | null
    ogTwitterTitle: string | null
    ogTwitterDescription: string | null
    ogTwitterImageId: string | null
    ogTwitterLocale: string | null
    ogTwitterUrl: string | null
    rootId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SeoCountAggregateOutputType | null
    _avg: SeoAvgAggregateOutputType | null
    _sum: SeoSumAggregateOutputType | null
    _min: SeoMinAggregateOutputType | null
    _max: SeoMaxAggregateOutputType | null
  }

  type GetSeoGroupByPayload<T extends SeoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeoGroupByOutputType[P]>
            : GetScalarType<T[P], SeoGroupByOutputType[P]>
        }
      >
    >


  export type SeoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    canonicalUrl?: boolean
    version?: boolean
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: boolean
    ogTwitterTitle?: boolean
    ogTwitterDescription?: boolean
    ogTwitterImageId?: boolean
    ogTwitterLocale?: boolean
    ogTwitterUrl?: boolean
    rootId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ogTwitterImage?: boolean | Seo$ogTwitterImageArgs<ExtArgs>
    root?: boolean | Seo$rootArgs<ExtArgs>
    rootChildren?: boolean | Seo$rootChildrenArgs<ExtArgs>
    settings?: boolean | Seo$settingsArgs<ExtArgs>
    posts?: boolean | Seo$postsArgs<ExtArgs>
    categories?: boolean | Seo$categoriesArgs<ExtArgs>
    tags?: boolean | Seo$tagsArgs<ExtArgs>
    products?: boolean | Seo$productsArgs<ExtArgs>
    productCategories?: boolean | Seo$productCategoriesArgs<ExtArgs>
    _count?: boolean | SeoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seo"]>

  export type SeoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    canonicalUrl?: boolean
    version?: boolean
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: boolean
    ogTwitterTitle?: boolean
    ogTwitterDescription?: boolean
    ogTwitterImageId?: boolean
    ogTwitterLocale?: boolean
    ogTwitterUrl?: boolean
    rootId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ogTwitterImage?: boolean | Seo$ogTwitterImageArgs<ExtArgs>
    root?: boolean | Seo$rootArgs<ExtArgs>
  }, ExtArgs["result"]["seo"]>

  export type SeoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    canonicalUrl?: boolean
    version?: boolean
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: boolean
    ogTwitterTitle?: boolean
    ogTwitterDescription?: boolean
    ogTwitterImageId?: boolean
    ogTwitterLocale?: boolean
    ogTwitterUrl?: boolean
    rootId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ogTwitterImage?: boolean | Seo$ogTwitterImageArgs<ExtArgs>
    root?: boolean | Seo$rootArgs<ExtArgs>
  }, ExtArgs["result"]["seo"]>

  export type SeoSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    canonicalUrl?: boolean
    version?: boolean
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: boolean
    ogTwitterTitle?: boolean
    ogTwitterDescription?: boolean
    ogTwitterImageId?: boolean
    ogTwitterLocale?: boolean
    ogTwitterUrl?: boolean
    rootId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SeoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "canonicalUrl" | "version" | "noIndex" | "noFollow" | "ogTwitterType" | "ogTwitterTitle" | "ogTwitterDescription" | "ogTwitterImageId" | "ogTwitterLocale" | "ogTwitterUrl" | "rootId" | "createdAt" | "updatedAt", ExtArgs["result"]["seo"]>
  export type SeoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ogTwitterImage?: boolean | Seo$ogTwitterImageArgs<ExtArgs>
    root?: boolean | Seo$rootArgs<ExtArgs>
    rootChildren?: boolean | Seo$rootChildrenArgs<ExtArgs>
    settings?: boolean | Seo$settingsArgs<ExtArgs>
    posts?: boolean | Seo$postsArgs<ExtArgs>
    categories?: boolean | Seo$categoriesArgs<ExtArgs>
    tags?: boolean | Seo$tagsArgs<ExtArgs>
    products?: boolean | Seo$productsArgs<ExtArgs>
    productCategories?: boolean | Seo$productCategoriesArgs<ExtArgs>
    _count?: boolean | SeoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SeoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ogTwitterImage?: boolean | Seo$ogTwitterImageArgs<ExtArgs>
    root?: boolean | Seo$rootArgs<ExtArgs>
  }
  export type SeoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ogTwitterImage?: boolean | Seo$ogTwitterImageArgs<ExtArgs>
    root?: boolean | Seo$rootArgs<ExtArgs>
  }

  export type $SeoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Seo"
    objects: {
      ogTwitterImage: Prisma.$MediaPayload<ExtArgs> | null
      root: Prisma.$SeoPayload<ExtArgs> | null
      rootChildren: Prisma.$SeoPayload<ExtArgs>[]
      settings: Prisma.$SettingsPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      categories: Prisma.$CategoryPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      productCategories: Prisma.$ProductCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      canonicalUrl: string | null
      version: number
      noIndex: boolean
      noFollow: boolean
      ogTwitterType: string | null
      ogTwitterTitle: string | null
      ogTwitterDescription: string | null
      ogTwitterImageId: string | null
      ogTwitterLocale: string | null
      ogTwitterUrl: string | null
      rootId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["seo"]>
    composites: {}
  }

  type SeoGetPayload<S extends boolean | null | undefined | SeoDefaultArgs> = $Result.GetResult<Prisma.$SeoPayload, S>

  type SeoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeoCountAggregateInputType | true
    }

  export interface SeoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Seo'], meta: { name: 'Seo' } }
    /**
     * Find zero or one Seo that matches the filter.
     * @param {SeoFindUniqueArgs} args - Arguments to find a Seo
     * @example
     * // Get one Seo
     * const seo = await prisma.seo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeoFindUniqueArgs>(args: SelectSubset<T, SeoFindUniqueArgs<ExtArgs>>): Prisma__SeoClient<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Seo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeoFindUniqueOrThrowArgs} args - Arguments to find a Seo
     * @example
     * // Get one Seo
     * const seo = await prisma.seo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeoFindUniqueOrThrowArgs>(args: SelectSubset<T, SeoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeoClient<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoFindFirstArgs} args - Arguments to find a Seo
     * @example
     * // Get one Seo
     * const seo = await prisma.seo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeoFindFirstArgs>(args?: SelectSubset<T, SeoFindFirstArgs<ExtArgs>>): Prisma__SeoClient<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoFindFirstOrThrowArgs} args - Arguments to find a Seo
     * @example
     * // Get one Seo
     * const seo = await prisma.seo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeoFindFirstOrThrowArgs>(args?: SelectSubset<T, SeoFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeoClient<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Seos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seos
     * const seos = await prisma.seo.findMany()
     * 
     * // Get first 10 Seos
     * const seos = await prisma.seo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seoWithIdOnly = await prisma.seo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeoFindManyArgs>(args?: SelectSubset<T, SeoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Seo.
     * @param {SeoCreateArgs} args - Arguments to create a Seo.
     * @example
     * // Create one Seo
     * const Seo = await prisma.seo.create({
     *   data: {
     *     // ... data to create a Seo
     *   }
     * })
     * 
     */
    create<T extends SeoCreateArgs>(args: SelectSubset<T, SeoCreateArgs<ExtArgs>>): Prisma__SeoClient<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Seos.
     * @param {SeoCreateManyArgs} args - Arguments to create many Seos.
     * @example
     * // Create many Seos
     * const seo = await prisma.seo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeoCreateManyArgs>(args?: SelectSubset<T, SeoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Seos and returns the data saved in the database.
     * @param {SeoCreateManyAndReturnArgs} args - Arguments to create many Seos.
     * @example
     * // Create many Seos
     * const seo = await prisma.seo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Seos and only return the `id`
     * const seoWithIdOnly = await prisma.seo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeoCreateManyAndReturnArgs>(args?: SelectSubset<T, SeoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Seo.
     * @param {SeoDeleteArgs} args - Arguments to delete one Seo.
     * @example
     * // Delete one Seo
     * const Seo = await prisma.seo.delete({
     *   where: {
     *     // ... filter to delete one Seo
     *   }
     * })
     * 
     */
    delete<T extends SeoDeleteArgs>(args: SelectSubset<T, SeoDeleteArgs<ExtArgs>>): Prisma__SeoClient<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Seo.
     * @param {SeoUpdateArgs} args - Arguments to update one Seo.
     * @example
     * // Update one Seo
     * const seo = await prisma.seo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeoUpdateArgs>(args: SelectSubset<T, SeoUpdateArgs<ExtArgs>>): Prisma__SeoClient<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Seos.
     * @param {SeoDeleteManyArgs} args - Arguments to filter Seos to delete.
     * @example
     * // Delete a few Seos
     * const { count } = await prisma.seo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeoDeleteManyArgs>(args?: SelectSubset<T, SeoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seos
     * const seo = await prisma.seo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeoUpdateManyArgs>(args: SelectSubset<T, SeoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seos and returns the data updated in the database.
     * @param {SeoUpdateManyAndReturnArgs} args - Arguments to update many Seos.
     * @example
     * // Update many Seos
     * const seo = await prisma.seo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Seos and only return the `id`
     * const seoWithIdOnly = await prisma.seo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SeoUpdateManyAndReturnArgs>(args: SelectSubset<T, SeoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Seo.
     * @param {SeoUpsertArgs} args - Arguments to update or create a Seo.
     * @example
     * // Update or create a Seo
     * const seo = await prisma.seo.upsert({
     *   create: {
     *     // ... data to create a Seo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seo we want to update
     *   }
     * })
     */
    upsert<T extends SeoUpsertArgs>(args: SelectSubset<T, SeoUpsertArgs<ExtArgs>>): Prisma__SeoClient<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Seos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoCountArgs} args - Arguments to filter Seos to count.
     * @example
     * // Count the number of Seos
     * const count = await prisma.seo.count({
     *   where: {
     *     // ... the filter for the Seos we want to count
     *   }
     * })
    **/
    count<T extends SeoCountArgs>(
      args?: Subset<T, SeoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Seo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeoAggregateArgs>(args: Subset<T, SeoAggregateArgs>): Prisma.PrismaPromise<GetSeoAggregateType<T>>

    /**
     * Group by Seo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeoGroupByArgs['orderBy'] }
        : { orderBy?: SeoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Seo model
   */
  readonly fields: SeoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Seo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ogTwitterImage<T extends Seo$ogTwitterImageArgs<ExtArgs> = {}>(args?: Subset<T, Seo$ogTwitterImageArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    root<T extends Seo$rootArgs<ExtArgs> = {}>(args?: Subset<T, Seo$rootArgs<ExtArgs>>): Prisma__SeoClient<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    rootChildren<T extends Seo$rootChildrenArgs<ExtArgs> = {}>(args?: Subset<T, Seo$rootChildrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    settings<T extends Seo$settingsArgs<ExtArgs> = {}>(args?: Subset<T, Seo$settingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends Seo$postsArgs<ExtArgs> = {}>(args?: Subset<T, Seo$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends Seo$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Seo$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Seo$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Seo$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends Seo$productsArgs<ExtArgs> = {}>(args?: Subset<T, Seo$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productCategories<T extends Seo$productCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Seo$productCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Seo model
   */
  interface SeoFieldRefs {
    readonly id: FieldRef<"Seo", 'String'>
    readonly title: FieldRef<"Seo", 'String'>
    readonly description: FieldRef<"Seo", 'String'>
    readonly canonicalUrl: FieldRef<"Seo", 'String'>
    readonly version: FieldRef<"Seo", 'Int'>
    readonly noIndex: FieldRef<"Seo", 'Boolean'>
    readonly noFollow: FieldRef<"Seo", 'Boolean'>
    readonly ogTwitterType: FieldRef<"Seo", 'String'>
    readonly ogTwitterTitle: FieldRef<"Seo", 'String'>
    readonly ogTwitterDescription: FieldRef<"Seo", 'String'>
    readonly ogTwitterImageId: FieldRef<"Seo", 'String'>
    readonly ogTwitterLocale: FieldRef<"Seo", 'String'>
    readonly ogTwitterUrl: FieldRef<"Seo", 'String'>
    readonly rootId: FieldRef<"Seo", 'String'>
    readonly createdAt: FieldRef<"Seo", 'DateTime'>
    readonly updatedAt: FieldRef<"Seo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Seo findUnique
   */
  export type SeoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    /**
     * Filter, which Seo to fetch.
     */
    where: SeoWhereUniqueInput
  }

  /**
   * Seo findUniqueOrThrow
   */
  export type SeoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    /**
     * Filter, which Seo to fetch.
     */
    where: SeoWhereUniqueInput
  }

  /**
   * Seo findFirst
   */
  export type SeoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    /**
     * Filter, which Seo to fetch.
     */
    where?: SeoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seos to fetch.
     */
    orderBy?: SeoOrderByWithRelationInput | SeoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seos.
     */
    cursor?: SeoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seos.
     */
    distinct?: SeoScalarFieldEnum | SeoScalarFieldEnum[]
  }

  /**
   * Seo findFirstOrThrow
   */
  export type SeoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    /**
     * Filter, which Seo to fetch.
     */
    where?: SeoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seos to fetch.
     */
    orderBy?: SeoOrderByWithRelationInput | SeoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seos.
     */
    cursor?: SeoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seos.
     */
    distinct?: SeoScalarFieldEnum | SeoScalarFieldEnum[]
  }

  /**
   * Seo findMany
   */
  export type SeoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    /**
     * Filter, which Seos to fetch.
     */
    where?: SeoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seos to fetch.
     */
    orderBy?: SeoOrderByWithRelationInput | SeoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Seos.
     */
    cursor?: SeoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seos.
     */
    skip?: number
    distinct?: SeoScalarFieldEnum | SeoScalarFieldEnum[]
  }

  /**
   * Seo create
   */
  export type SeoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    /**
     * The data needed to create a Seo.
     */
    data: XOR<SeoCreateInput, SeoUncheckedCreateInput>
  }

  /**
   * Seo createMany
   */
  export type SeoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Seos.
     */
    data: SeoCreateManyInput | SeoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Seo createManyAndReturn
   */
  export type SeoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * The data used to create many Seos.
     */
    data: SeoCreateManyInput | SeoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Seo update
   */
  export type SeoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    /**
     * The data needed to update a Seo.
     */
    data: XOR<SeoUpdateInput, SeoUncheckedUpdateInput>
    /**
     * Choose, which Seo to update.
     */
    where: SeoWhereUniqueInput
  }

  /**
   * Seo updateMany
   */
  export type SeoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Seos.
     */
    data: XOR<SeoUpdateManyMutationInput, SeoUncheckedUpdateManyInput>
    /**
     * Filter which Seos to update
     */
    where?: SeoWhereInput
    /**
     * Limit how many Seos to update.
     */
    limit?: number
  }

  /**
   * Seo updateManyAndReturn
   */
  export type SeoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * The data used to update Seos.
     */
    data: XOR<SeoUpdateManyMutationInput, SeoUncheckedUpdateManyInput>
    /**
     * Filter which Seos to update
     */
    where?: SeoWhereInput
    /**
     * Limit how many Seos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Seo upsert
   */
  export type SeoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    /**
     * The filter to search for the Seo to update in case it exists.
     */
    where: SeoWhereUniqueInput
    /**
     * In case the Seo found by the `where` argument doesn't exist, create a new Seo with this data.
     */
    create: XOR<SeoCreateInput, SeoUncheckedCreateInput>
    /**
     * In case the Seo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeoUpdateInput, SeoUncheckedUpdateInput>
  }

  /**
   * Seo delete
   */
  export type SeoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    /**
     * Filter which Seo to delete.
     */
    where: SeoWhereUniqueInput
  }

  /**
   * Seo deleteMany
   */
  export type SeoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seos to delete
     */
    where?: SeoWhereInput
    /**
     * Limit how many Seos to delete.
     */
    limit?: number
  }

  /**
   * Seo.ogTwitterImage
   */
  export type Seo$ogTwitterImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Seo.root
   */
  export type Seo$rootArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    where?: SeoWhereInput
  }

  /**
   * Seo.rootChildren
   */
  export type Seo$rootChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    where?: SeoWhereInput
    orderBy?: SeoOrderByWithRelationInput | SeoOrderByWithRelationInput[]
    cursor?: SeoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeoScalarFieldEnum | SeoScalarFieldEnum[]
  }

  /**
   * Seo.settings
   */
  export type Seo$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    where?: SettingsWhereInput
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    cursor?: SettingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Seo.posts
   */
  export type Seo$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Seo.categories
   */
  export type Seo$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Seo.tags
   */
  export type Seo$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Seo.products
   */
  export type Seo$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Seo.productCategories
   */
  export type Seo$productCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * Seo without action
   */
  export type SeoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    version: number | null
  }

  export type PostSumAggregateOutputType = {
    version: number | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    version: number | null
    status: $Enums.ContentStatus | null
    isLatest: boolean | null
    editorType: $Enums.EditorType | null
    rootId: string | null
    imageCoverId: string | null
    seoId: string | null
    userId: string | null
    firstPublishedAt: Date | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    version: number | null
    status: $Enums.ContentStatus | null
    isLatest: boolean | null
    editorType: $Enums.EditorType | null
    rootId: string | null
    imageCoverId: string | null
    seoId: string | null
    userId: string | null
    firstPublishedAt: Date | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    description: number
    version: number
    status: number
    isLatest: number
    editorType: number
    bodyData:PrismaJson.BodyData
    tiptapBodyData:PrismaJson.TipTapBodyData
    rootId: number
    imageCoverId: number
    seoId: number
    userId: number
    firstPublishedAt: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    version?: true
  }

  export type PostSumAggregateInputType = {
    version?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    version?: true
    status?: true
    isLatest?: true
    editorType?: true
    rootId?: true
    imageCoverId?: true
    seoId?: true
    userId?: true
    firstPublishedAt?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    version?: true
    status?: true
    isLatest?: true
    editorType?: true
    rootId?: true
    imageCoverId?: true
    seoId?: true
    userId?: true
    firstPublishedAt?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    version?: true
    status?: true
    isLatest?: true
    editorType?: true
    bodyData?: true
    tiptapBodyData?: true
    rootId?: true
    imageCoverId?: true
    seoId?: true
    userId?: true
    firstPublishedAt?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    title: string
    slug: string
    description: string | null
    version: number
    status: $Enums.ContentStatus
    isLatest: boolean
    editorType: $Enums.EditorType
    bodyData:PrismaJson.BodyData
    tiptapBodyData:PrismaJson.TipTapBodyData | null
    rootId: string | null
    imageCoverId: string | null
    seoId: string | null
    userId: string | null
    firstPublishedAt: Date
    publishedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    version?: boolean
    status?: boolean
    isLatest?: boolean
    editorType?: boolean
    bodyData?: boolean
    tiptapBodyData?: boolean
    rootId?: boolean
    imageCoverId?: boolean
    seoId?: boolean
    userId?: boolean
    firstPublishedAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    root?: boolean | Post$rootArgs<ExtArgs>
    rootChildren?: boolean | Post$rootChildrenArgs<ExtArgs>
    imageCover?: boolean | Post$imageCoverArgs<ExtArgs>
    postCategories?: boolean | Post$postCategoriesArgs<ExtArgs>
    tags?: boolean | Post$tagsArgs<ExtArgs>
    seo?: boolean | Post$seoArgs<ExtArgs>
    postAuthors?: boolean | Post$postAuthorsArgs<ExtArgs>
    user?: boolean | Post$userArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    version?: boolean
    status?: boolean
    isLatest?: boolean
    editorType?: boolean
    bodyData?: boolean
    tiptapBodyData?: boolean
    rootId?: boolean
    imageCoverId?: boolean
    seoId?: boolean
    userId?: boolean
    firstPublishedAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    root?: boolean | Post$rootArgs<ExtArgs>
    imageCover?: boolean | Post$imageCoverArgs<ExtArgs>
    seo?: boolean | Post$seoArgs<ExtArgs>
    user?: boolean | Post$userArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    version?: boolean
    status?: boolean
    isLatest?: boolean
    editorType?: boolean
    bodyData?: boolean
    tiptapBodyData?: boolean
    rootId?: boolean
    imageCoverId?: boolean
    seoId?: boolean
    userId?: boolean
    firstPublishedAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    root?: boolean | Post$rootArgs<ExtArgs>
    imageCover?: boolean | Post$imageCoverArgs<ExtArgs>
    seo?: boolean | Post$seoArgs<ExtArgs>
    user?: boolean | Post$userArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    version?: boolean
    status?: boolean
    isLatest?: boolean
    editorType?: boolean
    bodyData?: boolean
    tiptapBodyData?: boolean
    rootId?: boolean
    imageCoverId?: boolean
    seoId?: boolean
    userId?: boolean
    firstPublishedAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "description" | "version" | "status" | "isLatest" | "editorType" | "bodyData" | "tiptapBodyData" | "rootId" | "imageCoverId" | "seoId" | "userId" | "firstPublishedAt" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    root?: boolean | Post$rootArgs<ExtArgs>
    rootChildren?: boolean | Post$rootChildrenArgs<ExtArgs>
    imageCover?: boolean | Post$imageCoverArgs<ExtArgs>
    postCategories?: boolean | Post$postCategoriesArgs<ExtArgs>
    tags?: boolean | Post$tagsArgs<ExtArgs>
    seo?: boolean | Post$seoArgs<ExtArgs>
    postAuthors?: boolean | Post$postAuthorsArgs<ExtArgs>
    user?: boolean | Post$userArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    root?: boolean | Post$rootArgs<ExtArgs>
    imageCover?: boolean | Post$imageCoverArgs<ExtArgs>
    seo?: boolean | Post$seoArgs<ExtArgs>
    user?: boolean | Post$userArgs<ExtArgs>
  }
  export type PostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    root?: boolean | Post$rootArgs<ExtArgs>
    imageCover?: boolean | Post$imageCoverArgs<ExtArgs>
    seo?: boolean | Post$seoArgs<ExtArgs>
    user?: boolean | Post$userArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      root: Prisma.$PostPayload<ExtArgs> | null
      rootChildren: Prisma.$PostPayload<ExtArgs>[]
      imageCover: Prisma.$MediaPayload<ExtArgs> | null
      postCategories: Prisma.$PostCategoryPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
      seo: Prisma.$SeoPayload<ExtArgs> | null
      postAuthors: Prisma.$PostAuthorPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      description: string | null
      version: number
      status: $Enums.ContentStatus
      isLatest: boolean
      editorType: $Enums.EditorType
      /**
       * [BodyData]
       */
      bodyData:PrismaJson.BodyData
      /**
       * [TipTapBodyData]
       */
      tiptapBodyData:PrismaJson.TipTapBodyData | null
      rootId: string | null
      imageCoverId: string | null
      seoId: string | null
      userId: string | null
      firstPublishedAt: Date
      publishedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts and returns the data updated in the database.
     * @param {PostUpdateManyAndReturnArgs} args - Arguments to update many Posts.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostUpdateManyAndReturnArgs>(args: SelectSubset<T, PostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    root<T extends Post$rootArgs<ExtArgs> = {}>(args?: Subset<T, Post$rootArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    rootChildren<T extends Post$rootChildrenArgs<ExtArgs> = {}>(args?: Subset<T, Post$rootChildrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    imageCover<T extends Post$imageCoverArgs<ExtArgs> = {}>(args?: Subset<T, Post$imageCoverArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    postCategories<T extends Post$postCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Post$postCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Post$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Post$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seo<T extends Post$seoArgs<ExtArgs> = {}>(args?: Subset<T, Post$seoArgs<ExtArgs>>): Prisma__SeoClient<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    postAuthors<T extends Post$postAuthorsArgs<ExtArgs> = {}>(args?: Subset<T, Post$postAuthorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostAuthorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends Post$userArgs<ExtArgs> = {}>(args?: Subset<T, Post$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'String'>
    readonly title: FieldRef<"Post", 'String'>
    readonly slug: FieldRef<"Post", 'String'>
    readonly description: FieldRef<"Post", 'String'>
    readonly version: FieldRef<"Post", 'Int'>
    readonly status: FieldRef<"Post", 'ContentStatus'>
    readonly isLatest: FieldRef<"Post", 'Boolean'>
    readonly editorType: FieldRef<"Post", 'EditorType'>
    readonly bodyData: FieldRef<"Post", 'Json'>
    readonly tiptapBodyData: FieldRef<"Post", 'Json'>
    readonly rootId: FieldRef<"Post", 'String'>
    readonly imageCoverId: FieldRef<"Post", 'String'>
    readonly seoId: FieldRef<"Post", 'String'>
    readonly userId: FieldRef<"Post", 'String'>
    readonly firstPublishedAt: FieldRef<"Post", 'DateTime'>
    readonly publishedAt: FieldRef<"Post", 'DateTime'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post updateManyAndReturn
   */
  export type PostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post.root
   */
  export type Post$rootArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
  }

  /**
   * Post.rootChildren
   */
  export type Post$rootChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post.imageCover
   */
  export type Post$imageCoverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Post.postCategories
   */
  export type Post$postCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostCategory
     */
    omit?: PostCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryInclude<ExtArgs> | null
    where?: PostCategoryWhereInput
    orderBy?: PostCategoryOrderByWithRelationInput | PostCategoryOrderByWithRelationInput[]
    cursor?: PostCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostCategoryScalarFieldEnum | PostCategoryScalarFieldEnum[]
  }

  /**
   * Post.tags
   */
  export type Post$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Post.seo
   */
  export type Post$seoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    where?: SeoWhereInput
  }

  /**
   * Post.postAuthors
   */
  export type Post$postAuthorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAuthor
     */
    select?: PostAuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAuthor
     */
    omit?: PostAuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAuthorInclude<ExtArgs> | null
    where?: PostAuthorWhereInput
    orderBy?: PostAuthorOrderByWithRelationInput | PostAuthorOrderByWithRelationInput[]
    cursor?: PostAuthorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostAuthorScalarFieldEnum | PostAuthorScalarFieldEnum[]
  }

  /**
   * Post.user
   */
  export type Post$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model PostAuthor
   */

  export type AggregatePostAuthor = {
    _count: PostAuthorCountAggregateOutputType | null
    _avg: PostAuthorAvgAggregateOutputType | null
    _sum: PostAuthorSumAggregateOutputType | null
    _min: PostAuthorMinAggregateOutputType | null
    _max: PostAuthorMaxAggregateOutputType | null
  }

  export type PostAuthorAvgAggregateOutputType = {
    sort: number | null
  }

  export type PostAuthorSumAggregateOutputType = {
    sort: number | null
  }

  export type PostAuthorMinAggregateOutputType = {
    postId: string | null
    userId: string | null
    sort: number | null
  }

  export type PostAuthorMaxAggregateOutputType = {
    postId: string | null
    userId: string | null
    sort: number | null
  }

  export type PostAuthorCountAggregateOutputType = {
    postId: number
    userId: number
    sort: number
    _all: number
  }


  export type PostAuthorAvgAggregateInputType = {
    sort?: true
  }

  export type PostAuthorSumAggregateInputType = {
    sort?: true
  }

  export type PostAuthorMinAggregateInputType = {
    postId?: true
    userId?: true
    sort?: true
  }

  export type PostAuthorMaxAggregateInputType = {
    postId?: true
    userId?: true
    sort?: true
  }

  export type PostAuthorCountAggregateInputType = {
    postId?: true
    userId?: true
    sort?: true
    _all?: true
  }

  export type PostAuthorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostAuthor to aggregate.
     */
    where?: PostAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAuthors to fetch.
     */
    orderBy?: PostAuthorOrderByWithRelationInput | PostAuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostAuthors
    **/
    _count?: true | PostAuthorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAuthorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostAuthorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostAuthorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostAuthorMaxAggregateInputType
  }

  export type GetPostAuthorAggregateType<T extends PostAuthorAggregateArgs> = {
        [P in keyof T & keyof AggregatePostAuthor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostAuthor[P]>
      : GetScalarType<T[P], AggregatePostAuthor[P]>
  }




  export type PostAuthorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostAuthorWhereInput
    orderBy?: PostAuthorOrderByWithAggregationInput | PostAuthorOrderByWithAggregationInput[]
    by: PostAuthorScalarFieldEnum[] | PostAuthorScalarFieldEnum
    having?: PostAuthorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostAuthorCountAggregateInputType | true
    _avg?: PostAuthorAvgAggregateInputType
    _sum?: PostAuthorSumAggregateInputType
    _min?: PostAuthorMinAggregateInputType
    _max?: PostAuthorMaxAggregateInputType
  }

  export type PostAuthorGroupByOutputType = {
    postId: string
    userId: string
    sort: number
    _count: PostAuthorCountAggregateOutputType | null
    _avg: PostAuthorAvgAggregateOutputType | null
    _sum: PostAuthorSumAggregateOutputType | null
    _min: PostAuthorMinAggregateOutputType | null
    _max: PostAuthorMaxAggregateOutputType | null
  }

  type GetPostAuthorGroupByPayload<T extends PostAuthorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostAuthorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostAuthorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostAuthorGroupByOutputType[P]>
            : GetScalarType<T[P], PostAuthorGroupByOutputType[P]>
        }
      >
    >


  export type PostAuthorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    userId?: boolean
    sort?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postAuthor"]>

  export type PostAuthorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    userId?: boolean
    sort?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postAuthor"]>

  export type PostAuthorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    userId?: boolean
    sort?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postAuthor"]>

  export type PostAuthorSelectScalar = {
    postId?: boolean
    userId?: boolean
    sort?: boolean
  }

  export type PostAuthorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"postId" | "userId" | "sort", ExtArgs["result"]["postAuthor"]>
  export type PostAuthorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PostAuthorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PostAuthorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PostAuthorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostAuthor"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      postId: string
      userId: string
      sort: number
    }, ExtArgs["result"]["postAuthor"]>
    composites: {}
  }

  type PostAuthorGetPayload<S extends boolean | null | undefined | PostAuthorDefaultArgs> = $Result.GetResult<Prisma.$PostAuthorPayload, S>

  type PostAuthorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostAuthorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostAuthorCountAggregateInputType | true
    }

  export interface PostAuthorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostAuthor'], meta: { name: 'PostAuthor' } }
    /**
     * Find zero or one PostAuthor that matches the filter.
     * @param {PostAuthorFindUniqueArgs} args - Arguments to find a PostAuthor
     * @example
     * // Get one PostAuthor
     * const postAuthor = await prisma.postAuthor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostAuthorFindUniqueArgs>(args: SelectSubset<T, PostAuthorFindUniqueArgs<ExtArgs>>): Prisma__PostAuthorClient<$Result.GetResult<Prisma.$PostAuthorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostAuthor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostAuthorFindUniqueOrThrowArgs} args - Arguments to find a PostAuthor
     * @example
     * // Get one PostAuthor
     * const postAuthor = await prisma.postAuthor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostAuthorFindUniqueOrThrowArgs>(args: SelectSubset<T, PostAuthorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostAuthorClient<$Result.GetResult<Prisma.$PostAuthorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostAuthor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAuthorFindFirstArgs} args - Arguments to find a PostAuthor
     * @example
     * // Get one PostAuthor
     * const postAuthor = await prisma.postAuthor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostAuthorFindFirstArgs>(args?: SelectSubset<T, PostAuthorFindFirstArgs<ExtArgs>>): Prisma__PostAuthorClient<$Result.GetResult<Prisma.$PostAuthorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostAuthor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAuthorFindFirstOrThrowArgs} args - Arguments to find a PostAuthor
     * @example
     * // Get one PostAuthor
     * const postAuthor = await prisma.postAuthor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostAuthorFindFirstOrThrowArgs>(args?: SelectSubset<T, PostAuthorFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostAuthorClient<$Result.GetResult<Prisma.$PostAuthorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostAuthors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAuthorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostAuthors
     * const postAuthors = await prisma.postAuthor.findMany()
     * 
     * // Get first 10 PostAuthors
     * const postAuthors = await prisma.postAuthor.findMany({ take: 10 })
     * 
     * // Only select the `postId`
     * const postAuthorWithPostIdOnly = await prisma.postAuthor.findMany({ select: { postId: true } })
     * 
     */
    findMany<T extends PostAuthorFindManyArgs>(args?: SelectSubset<T, PostAuthorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostAuthorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostAuthor.
     * @param {PostAuthorCreateArgs} args - Arguments to create a PostAuthor.
     * @example
     * // Create one PostAuthor
     * const PostAuthor = await prisma.postAuthor.create({
     *   data: {
     *     // ... data to create a PostAuthor
     *   }
     * })
     * 
     */
    create<T extends PostAuthorCreateArgs>(args: SelectSubset<T, PostAuthorCreateArgs<ExtArgs>>): Prisma__PostAuthorClient<$Result.GetResult<Prisma.$PostAuthorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostAuthors.
     * @param {PostAuthorCreateManyArgs} args - Arguments to create many PostAuthors.
     * @example
     * // Create many PostAuthors
     * const postAuthor = await prisma.postAuthor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostAuthorCreateManyArgs>(args?: SelectSubset<T, PostAuthorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostAuthors and returns the data saved in the database.
     * @param {PostAuthorCreateManyAndReturnArgs} args - Arguments to create many PostAuthors.
     * @example
     * // Create many PostAuthors
     * const postAuthor = await prisma.postAuthor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostAuthors and only return the `postId`
     * const postAuthorWithPostIdOnly = await prisma.postAuthor.createManyAndReturn({
     *   select: { postId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostAuthorCreateManyAndReturnArgs>(args?: SelectSubset<T, PostAuthorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostAuthorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostAuthor.
     * @param {PostAuthorDeleteArgs} args - Arguments to delete one PostAuthor.
     * @example
     * // Delete one PostAuthor
     * const PostAuthor = await prisma.postAuthor.delete({
     *   where: {
     *     // ... filter to delete one PostAuthor
     *   }
     * })
     * 
     */
    delete<T extends PostAuthorDeleteArgs>(args: SelectSubset<T, PostAuthorDeleteArgs<ExtArgs>>): Prisma__PostAuthorClient<$Result.GetResult<Prisma.$PostAuthorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostAuthor.
     * @param {PostAuthorUpdateArgs} args - Arguments to update one PostAuthor.
     * @example
     * // Update one PostAuthor
     * const postAuthor = await prisma.postAuthor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostAuthorUpdateArgs>(args: SelectSubset<T, PostAuthorUpdateArgs<ExtArgs>>): Prisma__PostAuthorClient<$Result.GetResult<Prisma.$PostAuthorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostAuthors.
     * @param {PostAuthorDeleteManyArgs} args - Arguments to filter PostAuthors to delete.
     * @example
     * // Delete a few PostAuthors
     * const { count } = await prisma.postAuthor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostAuthorDeleteManyArgs>(args?: SelectSubset<T, PostAuthorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostAuthors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAuthorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostAuthors
     * const postAuthor = await prisma.postAuthor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostAuthorUpdateManyArgs>(args: SelectSubset<T, PostAuthorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostAuthors and returns the data updated in the database.
     * @param {PostAuthorUpdateManyAndReturnArgs} args - Arguments to update many PostAuthors.
     * @example
     * // Update many PostAuthors
     * const postAuthor = await prisma.postAuthor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostAuthors and only return the `postId`
     * const postAuthorWithPostIdOnly = await prisma.postAuthor.updateManyAndReturn({
     *   select: { postId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostAuthorUpdateManyAndReturnArgs>(args: SelectSubset<T, PostAuthorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostAuthorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostAuthor.
     * @param {PostAuthorUpsertArgs} args - Arguments to update or create a PostAuthor.
     * @example
     * // Update or create a PostAuthor
     * const postAuthor = await prisma.postAuthor.upsert({
     *   create: {
     *     // ... data to create a PostAuthor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostAuthor we want to update
     *   }
     * })
     */
    upsert<T extends PostAuthorUpsertArgs>(args: SelectSubset<T, PostAuthorUpsertArgs<ExtArgs>>): Prisma__PostAuthorClient<$Result.GetResult<Prisma.$PostAuthorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostAuthors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAuthorCountArgs} args - Arguments to filter PostAuthors to count.
     * @example
     * // Count the number of PostAuthors
     * const count = await prisma.postAuthor.count({
     *   where: {
     *     // ... the filter for the PostAuthors we want to count
     *   }
     * })
    **/
    count<T extends PostAuthorCountArgs>(
      args?: Subset<T, PostAuthorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostAuthorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostAuthor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAuthorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAuthorAggregateArgs>(args: Subset<T, PostAuthorAggregateArgs>): Prisma.PrismaPromise<GetPostAuthorAggregateType<T>>

    /**
     * Group by PostAuthor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAuthorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostAuthorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostAuthorGroupByArgs['orderBy'] }
        : { orderBy?: PostAuthorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostAuthorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostAuthorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostAuthor model
   */
  readonly fields: PostAuthorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostAuthor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostAuthorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostAuthor model
   */
  interface PostAuthorFieldRefs {
    readonly postId: FieldRef<"PostAuthor", 'String'>
    readonly userId: FieldRef<"PostAuthor", 'String'>
    readonly sort: FieldRef<"PostAuthor", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PostAuthor findUnique
   */
  export type PostAuthorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAuthor
     */
    select?: PostAuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAuthor
     */
    omit?: PostAuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAuthorInclude<ExtArgs> | null
    /**
     * Filter, which PostAuthor to fetch.
     */
    where: PostAuthorWhereUniqueInput
  }

  /**
   * PostAuthor findUniqueOrThrow
   */
  export type PostAuthorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAuthor
     */
    select?: PostAuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAuthor
     */
    omit?: PostAuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAuthorInclude<ExtArgs> | null
    /**
     * Filter, which PostAuthor to fetch.
     */
    where: PostAuthorWhereUniqueInput
  }

  /**
   * PostAuthor findFirst
   */
  export type PostAuthorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAuthor
     */
    select?: PostAuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAuthor
     */
    omit?: PostAuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAuthorInclude<ExtArgs> | null
    /**
     * Filter, which PostAuthor to fetch.
     */
    where?: PostAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAuthors to fetch.
     */
    orderBy?: PostAuthorOrderByWithRelationInput | PostAuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostAuthors.
     */
    cursor?: PostAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostAuthors.
     */
    distinct?: PostAuthorScalarFieldEnum | PostAuthorScalarFieldEnum[]
  }

  /**
   * PostAuthor findFirstOrThrow
   */
  export type PostAuthorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAuthor
     */
    select?: PostAuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAuthor
     */
    omit?: PostAuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAuthorInclude<ExtArgs> | null
    /**
     * Filter, which PostAuthor to fetch.
     */
    where?: PostAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAuthors to fetch.
     */
    orderBy?: PostAuthorOrderByWithRelationInput | PostAuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostAuthors.
     */
    cursor?: PostAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostAuthors.
     */
    distinct?: PostAuthorScalarFieldEnum | PostAuthorScalarFieldEnum[]
  }

  /**
   * PostAuthor findMany
   */
  export type PostAuthorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAuthor
     */
    select?: PostAuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAuthor
     */
    omit?: PostAuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAuthorInclude<ExtArgs> | null
    /**
     * Filter, which PostAuthors to fetch.
     */
    where?: PostAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAuthors to fetch.
     */
    orderBy?: PostAuthorOrderByWithRelationInput | PostAuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostAuthors.
     */
    cursor?: PostAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAuthors.
     */
    skip?: number
    distinct?: PostAuthorScalarFieldEnum | PostAuthorScalarFieldEnum[]
  }

  /**
   * PostAuthor create
   */
  export type PostAuthorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAuthor
     */
    select?: PostAuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAuthor
     */
    omit?: PostAuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAuthorInclude<ExtArgs> | null
    /**
     * The data needed to create a PostAuthor.
     */
    data: XOR<PostAuthorCreateInput, PostAuthorUncheckedCreateInput>
  }

  /**
   * PostAuthor createMany
   */
  export type PostAuthorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostAuthors.
     */
    data: PostAuthorCreateManyInput | PostAuthorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostAuthor createManyAndReturn
   */
  export type PostAuthorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAuthor
     */
    select?: PostAuthorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostAuthor
     */
    omit?: PostAuthorOmit<ExtArgs> | null
    /**
     * The data used to create many PostAuthors.
     */
    data: PostAuthorCreateManyInput | PostAuthorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAuthorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostAuthor update
   */
  export type PostAuthorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAuthor
     */
    select?: PostAuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAuthor
     */
    omit?: PostAuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAuthorInclude<ExtArgs> | null
    /**
     * The data needed to update a PostAuthor.
     */
    data: XOR<PostAuthorUpdateInput, PostAuthorUncheckedUpdateInput>
    /**
     * Choose, which PostAuthor to update.
     */
    where: PostAuthorWhereUniqueInput
  }

  /**
   * PostAuthor updateMany
   */
  export type PostAuthorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostAuthors.
     */
    data: XOR<PostAuthorUpdateManyMutationInput, PostAuthorUncheckedUpdateManyInput>
    /**
     * Filter which PostAuthors to update
     */
    where?: PostAuthorWhereInput
    /**
     * Limit how many PostAuthors to update.
     */
    limit?: number
  }

  /**
   * PostAuthor updateManyAndReturn
   */
  export type PostAuthorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAuthor
     */
    select?: PostAuthorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostAuthor
     */
    omit?: PostAuthorOmit<ExtArgs> | null
    /**
     * The data used to update PostAuthors.
     */
    data: XOR<PostAuthorUpdateManyMutationInput, PostAuthorUncheckedUpdateManyInput>
    /**
     * Filter which PostAuthors to update
     */
    where?: PostAuthorWhereInput
    /**
     * Limit how many PostAuthors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAuthorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostAuthor upsert
   */
  export type PostAuthorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAuthor
     */
    select?: PostAuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAuthor
     */
    omit?: PostAuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAuthorInclude<ExtArgs> | null
    /**
     * The filter to search for the PostAuthor to update in case it exists.
     */
    where: PostAuthorWhereUniqueInput
    /**
     * In case the PostAuthor found by the `where` argument doesn't exist, create a new PostAuthor with this data.
     */
    create: XOR<PostAuthorCreateInput, PostAuthorUncheckedCreateInput>
    /**
     * In case the PostAuthor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostAuthorUpdateInput, PostAuthorUncheckedUpdateInput>
  }

  /**
   * PostAuthor delete
   */
  export type PostAuthorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAuthor
     */
    select?: PostAuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAuthor
     */
    omit?: PostAuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAuthorInclude<ExtArgs> | null
    /**
     * Filter which PostAuthor to delete.
     */
    where: PostAuthorWhereUniqueInput
  }

  /**
   * PostAuthor deleteMany
   */
  export type PostAuthorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostAuthors to delete
     */
    where?: PostAuthorWhereInput
    /**
     * Limit how many PostAuthors to delete.
     */
    limit?: number
  }

  /**
   * PostAuthor without action
   */
  export type PostAuthorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAuthor
     */
    select?: PostAuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAuthor
     */
    omit?: PostAuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAuthorInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    version: number | null
  }

  export type CategorySumAggregateOutputType = {
    version: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    version: number | null
    status: $Enums.ContentStatus | null
    isLatest: boolean | null
    rootId: string | null
    seoId: string | null
    firstPublishedAt: Date | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    version: number | null
    status: $Enums.ContentStatus | null
    isLatest: boolean | null
    rootId: string | null
    seoId: string | null
    firstPublishedAt: Date | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    description: number
    version: number
    status: number
    isLatest: number
    rootId: number
    seoId: number
    firstPublishedAt: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    version?: true
  }

  export type CategorySumAggregateInputType = {
    version?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    version?: true
    status?: true
    isLatest?: true
    rootId?: true
    seoId?: true
    firstPublishedAt?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    version?: true
    status?: true
    isLatest?: true
    rootId?: true
    seoId?: true
    firstPublishedAt?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    version?: true
    status?: true
    isLatest?: true
    rootId?: true
    seoId?: true
    firstPublishedAt?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    title: string
    slug: string
    description: string | null
    version: number
    status: $Enums.ContentStatus
    isLatest: boolean
    rootId: string | null
    seoId: string | null
    firstPublishedAt: Date
    publishedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    version?: boolean
    status?: boolean
    isLatest?: boolean
    rootId?: boolean
    seoId?: boolean
    firstPublishedAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    root?: boolean | Category$rootArgs<ExtArgs>
    rootChildren?: boolean | Category$rootChildrenArgs<ExtArgs>
    postCategories?: boolean | Category$postCategoriesArgs<ExtArgs>
    seo?: boolean | Category$seoArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    version?: boolean
    status?: boolean
    isLatest?: boolean
    rootId?: boolean
    seoId?: boolean
    firstPublishedAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    root?: boolean | Category$rootArgs<ExtArgs>
    seo?: boolean | Category$seoArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    version?: boolean
    status?: boolean
    isLatest?: boolean
    rootId?: boolean
    seoId?: boolean
    firstPublishedAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    root?: boolean | Category$rootArgs<ExtArgs>
    seo?: boolean | Category$seoArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    version?: boolean
    status?: boolean
    isLatest?: boolean
    rootId?: boolean
    seoId?: boolean
    firstPublishedAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "description" | "version" | "status" | "isLatest" | "rootId" | "seoId" | "firstPublishedAt" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    root?: boolean | Category$rootArgs<ExtArgs>
    rootChildren?: boolean | Category$rootChildrenArgs<ExtArgs>
    postCategories?: boolean | Category$postCategoriesArgs<ExtArgs>
    seo?: boolean | Category$seoArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    root?: boolean | Category$rootArgs<ExtArgs>
    seo?: boolean | Category$seoArgs<ExtArgs>
  }
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    root?: boolean | Category$rootArgs<ExtArgs>
    seo?: boolean | Category$seoArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      root: Prisma.$CategoryPayload<ExtArgs> | null
      rootChildren: Prisma.$CategoryPayload<ExtArgs>[]
      postCategories: Prisma.$PostCategoryPayload<ExtArgs>[]
      seo: Prisma.$SeoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      description: string | null
      version: number
      status: $Enums.ContentStatus
      isLatest: boolean
      rootId: string | null
      seoId: string | null
      firstPublishedAt: Date
      publishedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    root<T extends Category$rootArgs<ExtArgs> = {}>(args?: Subset<T, Category$rootArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    rootChildren<T extends Category$rootChildrenArgs<ExtArgs> = {}>(args?: Subset<T, Category$rootChildrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    postCategories<T extends Category$postCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Category$postCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seo<T extends Category$seoArgs<ExtArgs> = {}>(args?: Subset<T, Category$seoArgs<ExtArgs>>): Prisma__SeoClient<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly title: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly version: FieldRef<"Category", 'Int'>
    readonly status: FieldRef<"Category", 'ContentStatus'>
    readonly isLatest: FieldRef<"Category", 'Boolean'>
    readonly rootId: FieldRef<"Category", 'String'>
    readonly seoId: FieldRef<"Category", 'String'>
    readonly firstPublishedAt: FieldRef<"Category", 'DateTime'>
    readonly publishedAt: FieldRef<"Category", 'DateTime'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.root
   */
  export type Category$rootArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Category.rootChildren
   */
  export type Category$rootChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category.postCategories
   */
  export type Category$postCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostCategory
     */
    omit?: PostCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryInclude<ExtArgs> | null
    where?: PostCategoryWhereInput
    orderBy?: PostCategoryOrderByWithRelationInput | PostCategoryOrderByWithRelationInput[]
    cursor?: PostCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostCategoryScalarFieldEnum | PostCategoryScalarFieldEnum[]
  }

  /**
   * Category.seo
   */
  export type Category$seoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    where?: SeoWhereInput
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model PostCategory
   */

  export type AggregatePostCategory = {
    _count: PostCategoryCountAggregateOutputType | null
    _avg: PostCategoryAvgAggregateOutputType | null
    _sum: PostCategorySumAggregateOutputType | null
    _min: PostCategoryMinAggregateOutputType | null
    _max: PostCategoryMaxAggregateOutputType | null
  }

  export type PostCategoryAvgAggregateOutputType = {
    sort: number | null
  }

  export type PostCategorySumAggregateOutputType = {
    sort: number | null
  }

  export type PostCategoryMinAggregateOutputType = {
    postId: string | null
    categoryId: string | null
    sort: number | null
  }

  export type PostCategoryMaxAggregateOutputType = {
    postId: string | null
    categoryId: string | null
    sort: number | null
  }

  export type PostCategoryCountAggregateOutputType = {
    postId: number
    categoryId: number
    sort: number
    _all: number
  }


  export type PostCategoryAvgAggregateInputType = {
    sort?: true
  }

  export type PostCategorySumAggregateInputType = {
    sort?: true
  }

  export type PostCategoryMinAggregateInputType = {
    postId?: true
    categoryId?: true
    sort?: true
  }

  export type PostCategoryMaxAggregateInputType = {
    postId?: true
    categoryId?: true
    sort?: true
  }

  export type PostCategoryCountAggregateInputType = {
    postId?: true
    categoryId?: true
    sort?: true
    _all?: true
  }

  export type PostCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostCategory to aggregate.
     */
    where?: PostCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostCategories to fetch.
     */
    orderBy?: PostCategoryOrderByWithRelationInput | PostCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostCategories
    **/
    _count?: true | PostCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostCategoryMaxAggregateInputType
  }

  export type GetPostCategoryAggregateType<T extends PostCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePostCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostCategory[P]>
      : GetScalarType<T[P], AggregatePostCategory[P]>
  }




  export type PostCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostCategoryWhereInput
    orderBy?: PostCategoryOrderByWithAggregationInput | PostCategoryOrderByWithAggregationInput[]
    by: PostCategoryScalarFieldEnum[] | PostCategoryScalarFieldEnum
    having?: PostCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCategoryCountAggregateInputType | true
    _avg?: PostCategoryAvgAggregateInputType
    _sum?: PostCategorySumAggregateInputType
    _min?: PostCategoryMinAggregateInputType
    _max?: PostCategoryMaxAggregateInputType
  }

  export type PostCategoryGroupByOutputType = {
    postId: string
    categoryId: string
    sort: number
    _count: PostCategoryCountAggregateOutputType | null
    _avg: PostCategoryAvgAggregateOutputType | null
    _sum: PostCategorySumAggregateOutputType | null
    _min: PostCategoryMinAggregateOutputType | null
    _max: PostCategoryMaxAggregateOutputType | null
  }

  type GetPostCategoryGroupByPayload<T extends PostCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], PostCategoryGroupByOutputType[P]>
        }
      >
    >


  export type PostCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    categoryId?: boolean
    sort?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postCategory"]>

  export type PostCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    categoryId?: boolean
    sort?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postCategory"]>

  export type PostCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    categoryId?: boolean
    sort?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postCategory"]>

  export type PostCategorySelectScalar = {
    postId?: boolean
    categoryId?: boolean
    sort?: boolean
  }

  export type PostCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"postId" | "categoryId" | "sort", ExtArgs["result"]["postCategory"]>
  export type PostCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type PostCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type PostCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $PostCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostCategory"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      postId: string
      categoryId: string
      sort: number
    }, ExtArgs["result"]["postCategory"]>
    composites: {}
  }

  type PostCategoryGetPayload<S extends boolean | null | undefined | PostCategoryDefaultArgs> = $Result.GetResult<Prisma.$PostCategoryPayload, S>

  type PostCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCategoryCountAggregateInputType | true
    }

  export interface PostCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostCategory'], meta: { name: 'PostCategory' } }
    /**
     * Find zero or one PostCategory that matches the filter.
     * @param {PostCategoryFindUniqueArgs} args - Arguments to find a PostCategory
     * @example
     * // Get one PostCategory
     * const postCategory = await prisma.postCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostCategoryFindUniqueArgs>(args: SelectSubset<T, PostCategoryFindUniqueArgs<ExtArgs>>): Prisma__PostCategoryClient<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostCategoryFindUniqueOrThrowArgs} args - Arguments to find a PostCategory
     * @example
     * // Get one PostCategory
     * const postCategory = await prisma.postCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PostCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostCategoryClient<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCategoryFindFirstArgs} args - Arguments to find a PostCategory
     * @example
     * // Get one PostCategory
     * const postCategory = await prisma.postCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostCategoryFindFirstArgs>(args?: SelectSubset<T, PostCategoryFindFirstArgs<ExtArgs>>): Prisma__PostCategoryClient<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCategoryFindFirstOrThrowArgs} args - Arguments to find a PostCategory
     * @example
     * // Get one PostCategory
     * const postCategory = await prisma.postCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PostCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostCategoryClient<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostCategories
     * const postCategories = await prisma.postCategory.findMany()
     * 
     * // Get first 10 PostCategories
     * const postCategories = await prisma.postCategory.findMany({ take: 10 })
     * 
     * // Only select the `postId`
     * const postCategoryWithPostIdOnly = await prisma.postCategory.findMany({ select: { postId: true } })
     * 
     */
    findMany<T extends PostCategoryFindManyArgs>(args?: SelectSubset<T, PostCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostCategory.
     * @param {PostCategoryCreateArgs} args - Arguments to create a PostCategory.
     * @example
     * // Create one PostCategory
     * const PostCategory = await prisma.postCategory.create({
     *   data: {
     *     // ... data to create a PostCategory
     *   }
     * })
     * 
     */
    create<T extends PostCategoryCreateArgs>(args: SelectSubset<T, PostCategoryCreateArgs<ExtArgs>>): Prisma__PostCategoryClient<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostCategories.
     * @param {PostCategoryCreateManyArgs} args - Arguments to create many PostCategories.
     * @example
     * // Create many PostCategories
     * const postCategory = await prisma.postCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCategoryCreateManyArgs>(args?: SelectSubset<T, PostCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostCategories and returns the data saved in the database.
     * @param {PostCategoryCreateManyAndReturnArgs} args - Arguments to create many PostCategories.
     * @example
     * // Create many PostCategories
     * const postCategory = await prisma.postCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostCategories and only return the `postId`
     * const postCategoryWithPostIdOnly = await prisma.postCategory.createManyAndReturn({
     *   select: { postId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostCategory.
     * @param {PostCategoryDeleteArgs} args - Arguments to delete one PostCategory.
     * @example
     * // Delete one PostCategory
     * const PostCategory = await prisma.postCategory.delete({
     *   where: {
     *     // ... filter to delete one PostCategory
     *   }
     * })
     * 
     */
    delete<T extends PostCategoryDeleteArgs>(args: SelectSubset<T, PostCategoryDeleteArgs<ExtArgs>>): Prisma__PostCategoryClient<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostCategory.
     * @param {PostCategoryUpdateArgs} args - Arguments to update one PostCategory.
     * @example
     * // Update one PostCategory
     * const postCategory = await prisma.postCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostCategoryUpdateArgs>(args: SelectSubset<T, PostCategoryUpdateArgs<ExtArgs>>): Prisma__PostCategoryClient<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostCategories.
     * @param {PostCategoryDeleteManyArgs} args - Arguments to filter PostCategories to delete.
     * @example
     * // Delete a few PostCategories
     * const { count } = await prisma.postCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostCategoryDeleteManyArgs>(args?: SelectSubset<T, PostCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostCategories
     * const postCategory = await prisma.postCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostCategoryUpdateManyArgs>(args: SelectSubset<T, PostCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostCategories and returns the data updated in the database.
     * @param {PostCategoryUpdateManyAndReturnArgs} args - Arguments to update many PostCategories.
     * @example
     * // Update many PostCategories
     * const postCategory = await prisma.postCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostCategories and only return the `postId`
     * const postCategoryWithPostIdOnly = await prisma.postCategory.updateManyAndReturn({
     *   select: { postId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, PostCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostCategory.
     * @param {PostCategoryUpsertArgs} args - Arguments to update or create a PostCategory.
     * @example
     * // Update or create a PostCategory
     * const postCategory = await prisma.postCategory.upsert({
     *   create: {
     *     // ... data to create a PostCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostCategory we want to update
     *   }
     * })
     */
    upsert<T extends PostCategoryUpsertArgs>(args: SelectSubset<T, PostCategoryUpsertArgs<ExtArgs>>): Prisma__PostCategoryClient<$Result.GetResult<Prisma.$PostCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCategoryCountArgs} args - Arguments to filter PostCategories to count.
     * @example
     * // Count the number of PostCategories
     * const count = await prisma.postCategory.count({
     *   where: {
     *     // ... the filter for the PostCategories we want to count
     *   }
     * })
    **/
    count<T extends PostCategoryCountArgs>(
      args?: Subset<T, PostCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostCategoryAggregateArgs>(args: Subset<T, PostCategoryAggregateArgs>): Prisma.PrismaPromise<GetPostCategoryAggregateType<T>>

    /**
     * Group by PostCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostCategoryGroupByArgs['orderBy'] }
        : { orderBy?: PostCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostCategory model
   */
  readonly fields: PostCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostCategory model
   */
  interface PostCategoryFieldRefs {
    readonly postId: FieldRef<"PostCategory", 'String'>
    readonly categoryId: FieldRef<"PostCategory", 'String'>
    readonly sort: FieldRef<"PostCategory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PostCategory findUnique
   */
  export type PostCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostCategory
     */
    omit?: PostCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PostCategory to fetch.
     */
    where: PostCategoryWhereUniqueInput
  }

  /**
   * PostCategory findUniqueOrThrow
   */
  export type PostCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostCategory
     */
    omit?: PostCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PostCategory to fetch.
     */
    where: PostCategoryWhereUniqueInput
  }

  /**
   * PostCategory findFirst
   */
  export type PostCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostCategory
     */
    omit?: PostCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PostCategory to fetch.
     */
    where?: PostCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostCategories to fetch.
     */
    orderBy?: PostCategoryOrderByWithRelationInput | PostCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostCategories.
     */
    cursor?: PostCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostCategories.
     */
    distinct?: PostCategoryScalarFieldEnum | PostCategoryScalarFieldEnum[]
  }

  /**
   * PostCategory findFirstOrThrow
   */
  export type PostCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostCategory
     */
    omit?: PostCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PostCategory to fetch.
     */
    where?: PostCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostCategories to fetch.
     */
    orderBy?: PostCategoryOrderByWithRelationInput | PostCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostCategories.
     */
    cursor?: PostCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostCategories.
     */
    distinct?: PostCategoryScalarFieldEnum | PostCategoryScalarFieldEnum[]
  }

  /**
   * PostCategory findMany
   */
  export type PostCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostCategory
     */
    omit?: PostCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PostCategories to fetch.
     */
    where?: PostCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostCategories to fetch.
     */
    orderBy?: PostCategoryOrderByWithRelationInput | PostCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostCategories.
     */
    cursor?: PostCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostCategories.
     */
    skip?: number
    distinct?: PostCategoryScalarFieldEnum | PostCategoryScalarFieldEnum[]
  }

  /**
   * PostCategory create
   */
  export type PostCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostCategory
     */
    omit?: PostCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PostCategory.
     */
    data: XOR<PostCategoryCreateInput, PostCategoryUncheckedCreateInput>
  }

  /**
   * PostCategory createMany
   */
  export type PostCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostCategories.
     */
    data: PostCategoryCreateManyInput | PostCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostCategory createManyAndReturn
   */
  export type PostCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostCategory
     */
    omit?: PostCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many PostCategories.
     */
    data: PostCategoryCreateManyInput | PostCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostCategory update
   */
  export type PostCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostCategory
     */
    omit?: PostCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PostCategory.
     */
    data: XOR<PostCategoryUpdateInput, PostCategoryUncheckedUpdateInput>
    /**
     * Choose, which PostCategory to update.
     */
    where: PostCategoryWhereUniqueInput
  }

  /**
   * PostCategory updateMany
   */
  export type PostCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostCategories.
     */
    data: XOR<PostCategoryUpdateManyMutationInput, PostCategoryUncheckedUpdateManyInput>
    /**
     * Filter which PostCategories to update
     */
    where?: PostCategoryWhereInput
    /**
     * Limit how many PostCategories to update.
     */
    limit?: number
  }

  /**
   * PostCategory updateManyAndReturn
   */
  export type PostCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostCategory
     */
    omit?: PostCategoryOmit<ExtArgs> | null
    /**
     * The data used to update PostCategories.
     */
    data: XOR<PostCategoryUpdateManyMutationInput, PostCategoryUncheckedUpdateManyInput>
    /**
     * Filter which PostCategories to update
     */
    where?: PostCategoryWhereInput
    /**
     * Limit how many PostCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostCategory upsert
   */
  export type PostCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostCategory
     */
    omit?: PostCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PostCategory to update in case it exists.
     */
    where: PostCategoryWhereUniqueInput
    /**
     * In case the PostCategory found by the `where` argument doesn't exist, create a new PostCategory with this data.
     */
    create: XOR<PostCategoryCreateInput, PostCategoryUncheckedCreateInput>
    /**
     * In case the PostCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostCategoryUpdateInput, PostCategoryUncheckedUpdateInput>
  }

  /**
   * PostCategory delete
   */
  export type PostCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostCategory
     */
    omit?: PostCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryInclude<ExtArgs> | null
    /**
     * Filter which PostCategory to delete.
     */
    where: PostCategoryWhereUniqueInput
  }

  /**
   * PostCategory deleteMany
   */
  export type PostCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostCategories to delete
     */
    where?: PostCategoryWhereInput
    /**
     * Limit how many PostCategories to delete.
     */
    limit?: number
  }

  /**
   * PostCategory without action
   */
  export type PostCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCategory
     */
    select?: PostCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostCategory
     */
    omit?: PostCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    version: number | null
  }

  export type TagSumAggregateOutputType = {
    version: number | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    version: number | null
    status: $Enums.ContentStatus | null
    isLatest: boolean | null
    rootId: string | null
    seoId: string | null
    firstPublishedAt: Date | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    version: number | null
    status: $Enums.ContentStatus | null
    isLatest: boolean | null
    rootId: string | null
    seoId: string | null
    firstPublishedAt: Date | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    description: number
    version: number
    status: number
    isLatest: number
    rootId: number
    seoId: number
    firstPublishedAt: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    version?: true
  }

  export type TagSumAggregateInputType = {
    version?: true
  }

  export type TagMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    version?: true
    status?: true
    isLatest?: true
    rootId?: true
    seoId?: true
    firstPublishedAt?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    version?: true
    status?: true
    isLatest?: true
    rootId?: true
    seoId?: true
    firstPublishedAt?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    version?: true
    status?: true
    isLatest?: true
    rootId?: true
    seoId?: true
    firstPublishedAt?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    title: string
    slug: string
    description: string | null
    version: number
    status: $Enums.ContentStatus
    isLatest: boolean
    rootId: string | null
    seoId: string | null
    firstPublishedAt: Date
    publishedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    version?: boolean
    status?: boolean
    isLatest?: boolean
    rootId?: boolean
    seoId?: boolean
    firstPublishedAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    root?: boolean | Tag$rootArgs<ExtArgs>
    rootChildren?: boolean | Tag$rootChildrenArgs<ExtArgs>
    posts?: boolean | Tag$postsArgs<ExtArgs>
    seo?: boolean | Tag$seoArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    version?: boolean
    status?: boolean
    isLatest?: boolean
    rootId?: boolean
    seoId?: boolean
    firstPublishedAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    root?: boolean | Tag$rootArgs<ExtArgs>
    seo?: boolean | Tag$seoArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    version?: boolean
    status?: boolean
    isLatest?: boolean
    rootId?: boolean
    seoId?: boolean
    firstPublishedAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    root?: boolean | Tag$rootArgs<ExtArgs>
    seo?: boolean | Tag$seoArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    version?: boolean
    status?: boolean
    isLatest?: boolean
    rootId?: boolean
    seoId?: boolean
    firstPublishedAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "description" | "version" | "status" | "isLatest" | "rootId" | "seoId" | "firstPublishedAt" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    root?: boolean | Tag$rootArgs<ExtArgs>
    rootChildren?: boolean | Tag$rootChildrenArgs<ExtArgs>
    posts?: boolean | Tag$postsArgs<ExtArgs>
    seo?: boolean | Tag$seoArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    root?: boolean | Tag$rootArgs<ExtArgs>
    seo?: boolean | Tag$seoArgs<ExtArgs>
  }
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    root?: boolean | Tag$rootArgs<ExtArgs>
    seo?: boolean | Tag$seoArgs<ExtArgs>
  }

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      root: Prisma.$TagPayload<ExtArgs> | null
      rootChildren: Prisma.$TagPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      seo: Prisma.$SeoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      description: string | null
      version: number
      status: $Enums.ContentStatus
      isLatest: boolean
      rootId: string | null
      seoId: string | null
      firstPublishedAt: Date
      publishedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    root<T extends Tag$rootArgs<ExtArgs> = {}>(args?: Subset<T, Tag$rootArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    rootChildren<T extends Tag$rootChildrenArgs<ExtArgs> = {}>(args?: Subset<T, Tag$rootChildrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends Tag$postsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seo<T extends Tag$seoArgs<ExtArgs> = {}>(args?: Subset<T, Tag$seoArgs<ExtArgs>>): Prisma__SeoClient<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly title: FieldRef<"Tag", 'String'>
    readonly slug: FieldRef<"Tag", 'String'>
    readonly description: FieldRef<"Tag", 'String'>
    readonly version: FieldRef<"Tag", 'Int'>
    readonly status: FieldRef<"Tag", 'ContentStatus'>
    readonly isLatest: FieldRef<"Tag", 'Boolean'>
    readonly rootId: FieldRef<"Tag", 'String'>
    readonly seoId: FieldRef<"Tag", 'String'>
    readonly firstPublishedAt: FieldRef<"Tag", 'DateTime'>
    readonly publishedAt: FieldRef<"Tag", 'DateTime'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.root
   */
  export type Tag$rootArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
  }

  /**
   * Tag.rootChildren
   */
  export type Tag$rootChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag.posts
   */
  export type Tag$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Tag.seo
   */
  export type Tag$seoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    where?: SeoWhereInput
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model EmailSetting
   */

  export type AggregateEmailSetting = {
    _count: EmailSettingCountAggregateOutputType | null
    _avg: EmailSettingAvgAggregateOutputType | null
    _sum: EmailSettingSumAggregateOutputType | null
    _min: EmailSettingMinAggregateOutputType | null
    _max: EmailSettingMaxAggregateOutputType | null
  }

  export type EmailSettingAvgAggregateOutputType = {
    maxEmailsPerDay: number | null
  }

  export type EmailSettingSumAggregateOutputType = {
    maxEmailsPerDay: number | null
  }

  export type EmailSettingMinAggregateOutputType = {
    id: string | null
    emailSender: string | null
    emailSenderName: string | null
    emailResponse: string | null
    emailProvider: $Enums.EmailProvider | null
    emailApiKey: string | null
    maxEmailsPerDay: number | null
    subscriptionTemplateId: string | null
    freeEbookTemplateId: string | null
    webinarTemplateId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailSettingMaxAggregateOutputType = {
    id: string | null
    emailSender: string | null
    emailSenderName: string | null
    emailResponse: string | null
    emailProvider: $Enums.EmailProvider | null
    emailApiKey: string | null
    maxEmailsPerDay: number | null
    subscriptionTemplateId: string | null
    freeEbookTemplateId: string | null
    webinarTemplateId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailSettingCountAggregateOutputType = {
    id: number
    emailSender: number
    emailSenderName: number
    emailResponse: number
    emailProvider: number
    emailApiKey: number
    maxEmailsPerDay: number
    subscriptionTemplateId: number
    freeEbookTemplateId: number
    webinarTemplateId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailSettingAvgAggregateInputType = {
    maxEmailsPerDay?: true
  }

  export type EmailSettingSumAggregateInputType = {
    maxEmailsPerDay?: true
  }

  export type EmailSettingMinAggregateInputType = {
    id?: true
    emailSender?: true
    emailSenderName?: true
    emailResponse?: true
    emailProvider?: true
    emailApiKey?: true
    maxEmailsPerDay?: true
    subscriptionTemplateId?: true
    freeEbookTemplateId?: true
    webinarTemplateId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailSettingMaxAggregateInputType = {
    id?: true
    emailSender?: true
    emailSenderName?: true
    emailResponse?: true
    emailProvider?: true
    emailApiKey?: true
    maxEmailsPerDay?: true
    subscriptionTemplateId?: true
    freeEbookTemplateId?: true
    webinarTemplateId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailSettingCountAggregateInputType = {
    id?: true
    emailSender?: true
    emailSenderName?: true
    emailResponse?: true
    emailProvider?: true
    emailApiKey?: true
    maxEmailsPerDay?: true
    subscriptionTemplateId?: true
    freeEbookTemplateId?: true
    webinarTemplateId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailSetting to aggregate.
     */
    where?: EmailSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSettings to fetch.
     */
    orderBy?: EmailSettingOrderByWithRelationInput | EmailSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailSettings
    **/
    _count?: true | EmailSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailSettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailSettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailSettingMaxAggregateInputType
  }

  export type GetEmailSettingAggregateType<T extends EmailSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailSetting[P]>
      : GetScalarType<T[P], AggregateEmailSetting[P]>
  }




  export type EmailSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailSettingWhereInput
    orderBy?: EmailSettingOrderByWithAggregationInput | EmailSettingOrderByWithAggregationInput[]
    by: EmailSettingScalarFieldEnum[] | EmailSettingScalarFieldEnum
    having?: EmailSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailSettingCountAggregateInputType | true
    _avg?: EmailSettingAvgAggregateInputType
    _sum?: EmailSettingSumAggregateInputType
    _min?: EmailSettingMinAggregateInputType
    _max?: EmailSettingMaxAggregateInputType
  }

  export type EmailSettingGroupByOutputType = {
    id: string
    emailSender: string | null
    emailSenderName: string | null
    emailResponse: string | null
    emailProvider: $Enums.EmailProvider | null
    emailApiKey: string | null
    maxEmailsPerDay: number | null
    subscriptionTemplateId: string | null
    freeEbookTemplateId: string | null
    webinarTemplateId: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmailSettingCountAggregateOutputType | null
    _avg: EmailSettingAvgAggregateOutputType | null
    _sum: EmailSettingSumAggregateOutputType | null
    _min: EmailSettingMinAggregateOutputType | null
    _max: EmailSettingMaxAggregateOutputType | null
  }

  type GetEmailSettingGroupByPayload<T extends EmailSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailSettingGroupByOutputType[P]>
            : GetScalarType<T[P], EmailSettingGroupByOutputType[P]>
        }
      >
    >


  export type EmailSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailSender?: boolean
    emailSenderName?: boolean
    emailResponse?: boolean
    emailProvider?: boolean
    emailApiKey?: boolean
    maxEmailsPerDay?: boolean
    subscriptionTemplateId?: boolean
    freeEbookTemplateId?: boolean
    webinarTemplateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptionTemplate?: boolean | EmailSetting$subscriptionTemplateArgs<ExtArgs>
    freeEbookTemplate?: boolean | EmailSetting$freeEbookTemplateArgs<ExtArgs>
    webinarTemplate?: boolean | EmailSetting$webinarTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["emailSetting"]>

  export type EmailSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailSender?: boolean
    emailSenderName?: boolean
    emailResponse?: boolean
    emailProvider?: boolean
    emailApiKey?: boolean
    maxEmailsPerDay?: boolean
    subscriptionTemplateId?: boolean
    freeEbookTemplateId?: boolean
    webinarTemplateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptionTemplate?: boolean | EmailSetting$subscriptionTemplateArgs<ExtArgs>
    freeEbookTemplate?: boolean | EmailSetting$freeEbookTemplateArgs<ExtArgs>
    webinarTemplate?: boolean | EmailSetting$webinarTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["emailSetting"]>

  export type EmailSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailSender?: boolean
    emailSenderName?: boolean
    emailResponse?: boolean
    emailProvider?: boolean
    emailApiKey?: boolean
    maxEmailsPerDay?: boolean
    subscriptionTemplateId?: boolean
    freeEbookTemplateId?: boolean
    webinarTemplateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptionTemplate?: boolean | EmailSetting$subscriptionTemplateArgs<ExtArgs>
    freeEbookTemplate?: boolean | EmailSetting$freeEbookTemplateArgs<ExtArgs>
    webinarTemplate?: boolean | EmailSetting$webinarTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["emailSetting"]>

  export type EmailSettingSelectScalar = {
    id?: boolean
    emailSender?: boolean
    emailSenderName?: boolean
    emailResponse?: boolean
    emailProvider?: boolean
    emailApiKey?: boolean
    maxEmailsPerDay?: boolean
    subscriptionTemplateId?: boolean
    freeEbookTemplateId?: boolean
    webinarTemplateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "emailSender" | "emailSenderName" | "emailResponse" | "emailProvider" | "emailApiKey" | "maxEmailsPerDay" | "subscriptionTemplateId" | "freeEbookTemplateId" | "webinarTemplateId" | "createdAt" | "updatedAt", ExtArgs["result"]["emailSetting"]>
  export type EmailSettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptionTemplate?: boolean | EmailSetting$subscriptionTemplateArgs<ExtArgs>
    freeEbookTemplate?: boolean | EmailSetting$freeEbookTemplateArgs<ExtArgs>
    webinarTemplate?: boolean | EmailSetting$webinarTemplateArgs<ExtArgs>
  }
  export type EmailSettingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptionTemplate?: boolean | EmailSetting$subscriptionTemplateArgs<ExtArgs>
    freeEbookTemplate?: boolean | EmailSetting$freeEbookTemplateArgs<ExtArgs>
    webinarTemplate?: boolean | EmailSetting$webinarTemplateArgs<ExtArgs>
  }
  export type EmailSettingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptionTemplate?: boolean | EmailSetting$subscriptionTemplateArgs<ExtArgs>
    freeEbookTemplate?: boolean | EmailSetting$freeEbookTemplateArgs<ExtArgs>
    webinarTemplate?: boolean | EmailSetting$webinarTemplateArgs<ExtArgs>
  }

  export type $EmailSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailSetting"
    objects: {
      subscriptionTemplate: Prisma.$EmailTemplatePayload<ExtArgs> | null
      freeEbookTemplate: Prisma.$EmailTemplatePayload<ExtArgs> | null
      webinarTemplate: Prisma.$EmailTemplatePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      emailSender: string | null
      emailSenderName: string | null
      emailResponse: string | null
      emailProvider: $Enums.EmailProvider | null
      emailApiKey: string | null
      maxEmailsPerDay: number | null
      subscriptionTemplateId: string | null
      freeEbookTemplateId: string | null
      webinarTemplateId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailSetting"]>
    composites: {}
  }

  type EmailSettingGetPayload<S extends boolean | null | undefined | EmailSettingDefaultArgs> = $Result.GetResult<Prisma.$EmailSettingPayload, S>

  type EmailSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailSettingCountAggregateInputType | true
    }

  export interface EmailSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailSetting'], meta: { name: 'EmailSetting' } }
    /**
     * Find zero or one EmailSetting that matches the filter.
     * @param {EmailSettingFindUniqueArgs} args - Arguments to find a EmailSetting
     * @example
     * // Get one EmailSetting
     * const emailSetting = await prisma.emailSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailSettingFindUniqueArgs>(args: SelectSubset<T, EmailSettingFindUniqueArgs<ExtArgs>>): Prisma__EmailSettingClient<$Result.GetResult<Prisma.$EmailSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailSettingFindUniqueOrThrowArgs} args - Arguments to find a EmailSetting
     * @example
     * // Get one EmailSetting
     * const emailSetting = await prisma.emailSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailSettingClient<$Result.GetResult<Prisma.$EmailSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSettingFindFirstArgs} args - Arguments to find a EmailSetting
     * @example
     * // Get one EmailSetting
     * const emailSetting = await prisma.emailSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailSettingFindFirstArgs>(args?: SelectSubset<T, EmailSettingFindFirstArgs<ExtArgs>>): Prisma__EmailSettingClient<$Result.GetResult<Prisma.$EmailSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSettingFindFirstOrThrowArgs} args - Arguments to find a EmailSetting
     * @example
     * // Get one EmailSetting
     * const emailSetting = await prisma.emailSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailSettingClient<$Result.GetResult<Prisma.$EmailSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailSettings
     * const emailSettings = await prisma.emailSetting.findMany()
     * 
     * // Get first 10 EmailSettings
     * const emailSettings = await prisma.emailSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailSettingWithIdOnly = await prisma.emailSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailSettingFindManyArgs>(args?: SelectSubset<T, EmailSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailSetting.
     * @param {EmailSettingCreateArgs} args - Arguments to create a EmailSetting.
     * @example
     * // Create one EmailSetting
     * const EmailSetting = await prisma.emailSetting.create({
     *   data: {
     *     // ... data to create a EmailSetting
     *   }
     * })
     * 
     */
    create<T extends EmailSettingCreateArgs>(args: SelectSubset<T, EmailSettingCreateArgs<ExtArgs>>): Prisma__EmailSettingClient<$Result.GetResult<Prisma.$EmailSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailSettings.
     * @param {EmailSettingCreateManyArgs} args - Arguments to create many EmailSettings.
     * @example
     * // Create many EmailSettings
     * const emailSetting = await prisma.emailSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailSettingCreateManyArgs>(args?: SelectSubset<T, EmailSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailSettings and returns the data saved in the database.
     * @param {EmailSettingCreateManyAndReturnArgs} args - Arguments to create many EmailSettings.
     * @example
     * // Create many EmailSettings
     * const emailSetting = await prisma.emailSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailSettings and only return the `id`
     * const emailSettingWithIdOnly = await prisma.emailSetting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailSetting.
     * @param {EmailSettingDeleteArgs} args - Arguments to delete one EmailSetting.
     * @example
     * // Delete one EmailSetting
     * const EmailSetting = await prisma.emailSetting.delete({
     *   where: {
     *     // ... filter to delete one EmailSetting
     *   }
     * })
     * 
     */
    delete<T extends EmailSettingDeleteArgs>(args: SelectSubset<T, EmailSettingDeleteArgs<ExtArgs>>): Prisma__EmailSettingClient<$Result.GetResult<Prisma.$EmailSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailSetting.
     * @param {EmailSettingUpdateArgs} args - Arguments to update one EmailSetting.
     * @example
     * // Update one EmailSetting
     * const emailSetting = await prisma.emailSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailSettingUpdateArgs>(args: SelectSubset<T, EmailSettingUpdateArgs<ExtArgs>>): Prisma__EmailSettingClient<$Result.GetResult<Prisma.$EmailSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailSettings.
     * @param {EmailSettingDeleteManyArgs} args - Arguments to filter EmailSettings to delete.
     * @example
     * // Delete a few EmailSettings
     * const { count } = await prisma.emailSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailSettingDeleteManyArgs>(args?: SelectSubset<T, EmailSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailSettings
     * const emailSetting = await prisma.emailSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailSettingUpdateManyArgs>(args: SelectSubset<T, EmailSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailSettings and returns the data updated in the database.
     * @param {EmailSettingUpdateManyAndReturnArgs} args - Arguments to update many EmailSettings.
     * @example
     * // Update many EmailSettings
     * const emailSetting = await prisma.emailSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailSettings and only return the `id`
     * const emailSettingWithIdOnly = await prisma.emailSetting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailSetting.
     * @param {EmailSettingUpsertArgs} args - Arguments to update or create a EmailSetting.
     * @example
     * // Update or create a EmailSetting
     * const emailSetting = await prisma.emailSetting.upsert({
     *   create: {
     *     // ... data to create a EmailSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailSetting we want to update
     *   }
     * })
     */
    upsert<T extends EmailSettingUpsertArgs>(args: SelectSubset<T, EmailSettingUpsertArgs<ExtArgs>>): Prisma__EmailSettingClient<$Result.GetResult<Prisma.$EmailSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSettingCountArgs} args - Arguments to filter EmailSettings to count.
     * @example
     * // Count the number of EmailSettings
     * const count = await prisma.emailSetting.count({
     *   where: {
     *     // ... the filter for the EmailSettings we want to count
     *   }
     * })
    **/
    count<T extends EmailSettingCountArgs>(
      args?: Subset<T, EmailSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailSettingAggregateArgs>(args: Subset<T, EmailSettingAggregateArgs>): Prisma.PrismaPromise<GetEmailSettingAggregateType<T>>

    /**
     * Group by EmailSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailSettingGroupByArgs['orderBy'] }
        : { orderBy?: EmailSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailSetting model
   */
  readonly fields: EmailSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptionTemplate<T extends EmailSetting$subscriptionTemplateArgs<ExtArgs> = {}>(args?: Subset<T, EmailSetting$subscriptionTemplateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    freeEbookTemplate<T extends EmailSetting$freeEbookTemplateArgs<ExtArgs> = {}>(args?: Subset<T, EmailSetting$freeEbookTemplateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    webinarTemplate<T extends EmailSetting$webinarTemplateArgs<ExtArgs> = {}>(args?: Subset<T, EmailSetting$webinarTemplateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailSetting model
   */
  interface EmailSettingFieldRefs {
    readonly id: FieldRef<"EmailSetting", 'String'>
    readonly emailSender: FieldRef<"EmailSetting", 'String'>
    readonly emailSenderName: FieldRef<"EmailSetting", 'String'>
    readonly emailResponse: FieldRef<"EmailSetting", 'String'>
    readonly emailProvider: FieldRef<"EmailSetting", 'EmailProvider'>
    readonly emailApiKey: FieldRef<"EmailSetting", 'String'>
    readonly maxEmailsPerDay: FieldRef<"EmailSetting", 'Int'>
    readonly subscriptionTemplateId: FieldRef<"EmailSetting", 'String'>
    readonly freeEbookTemplateId: FieldRef<"EmailSetting", 'String'>
    readonly webinarTemplateId: FieldRef<"EmailSetting", 'String'>
    readonly createdAt: FieldRef<"EmailSetting", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailSetting findUnique
   */
  export type EmailSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSetting
     */
    select?: EmailSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSetting
     */
    omit?: EmailSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSettingInclude<ExtArgs> | null
    /**
     * Filter, which EmailSetting to fetch.
     */
    where: EmailSettingWhereUniqueInput
  }

  /**
   * EmailSetting findUniqueOrThrow
   */
  export type EmailSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSetting
     */
    select?: EmailSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSetting
     */
    omit?: EmailSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSettingInclude<ExtArgs> | null
    /**
     * Filter, which EmailSetting to fetch.
     */
    where: EmailSettingWhereUniqueInput
  }

  /**
   * EmailSetting findFirst
   */
  export type EmailSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSetting
     */
    select?: EmailSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSetting
     */
    omit?: EmailSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSettingInclude<ExtArgs> | null
    /**
     * Filter, which EmailSetting to fetch.
     */
    where?: EmailSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSettings to fetch.
     */
    orderBy?: EmailSettingOrderByWithRelationInput | EmailSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailSettings.
     */
    cursor?: EmailSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailSettings.
     */
    distinct?: EmailSettingScalarFieldEnum | EmailSettingScalarFieldEnum[]
  }

  /**
   * EmailSetting findFirstOrThrow
   */
  export type EmailSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSetting
     */
    select?: EmailSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSetting
     */
    omit?: EmailSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSettingInclude<ExtArgs> | null
    /**
     * Filter, which EmailSetting to fetch.
     */
    where?: EmailSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSettings to fetch.
     */
    orderBy?: EmailSettingOrderByWithRelationInput | EmailSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailSettings.
     */
    cursor?: EmailSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailSettings.
     */
    distinct?: EmailSettingScalarFieldEnum | EmailSettingScalarFieldEnum[]
  }

  /**
   * EmailSetting findMany
   */
  export type EmailSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSetting
     */
    select?: EmailSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSetting
     */
    omit?: EmailSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSettingInclude<ExtArgs> | null
    /**
     * Filter, which EmailSettings to fetch.
     */
    where?: EmailSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSettings to fetch.
     */
    orderBy?: EmailSettingOrderByWithRelationInput | EmailSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailSettings.
     */
    cursor?: EmailSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSettings.
     */
    skip?: number
    distinct?: EmailSettingScalarFieldEnum | EmailSettingScalarFieldEnum[]
  }

  /**
   * EmailSetting create
   */
  export type EmailSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSetting
     */
    select?: EmailSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSetting
     */
    omit?: EmailSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailSetting.
     */
    data: XOR<EmailSettingCreateInput, EmailSettingUncheckedCreateInput>
  }

  /**
   * EmailSetting createMany
   */
  export type EmailSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailSettings.
     */
    data: EmailSettingCreateManyInput | EmailSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailSetting createManyAndReturn
   */
  export type EmailSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSetting
     */
    select?: EmailSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSetting
     */
    omit?: EmailSettingOmit<ExtArgs> | null
    /**
     * The data used to create many EmailSettings.
     */
    data: EmailSettingCreateManyInput | EmailSettingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSettingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailSetting update
   */
  export type EmailSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSetting
     */
    select?: EmailSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSetting
     */
    omit?: EmailSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailSetting.
     */
    data: XOR<EmailSettingUpdateInput, EmailSettingUncheckedUpdateInput>
    /**
     * Choose, which EmailSetting to update.
     */
    where: EmailSettingWhereUniqueInput
  }

  /**
   * EmailSetting updateMany
   */
  export type EmailSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailSettings.
     */
    data: XOR<EmailSettingUpdateManyMutationInput, EmailSettingUncheckedUpdateManyInput>
    /**
     * Filter which EmailSettings to update
     */
    where?: EmailSettingWhereInput
    /**
     * Limit how many EmailSettings to update.
     */
    limit?: number
  }

  /**
   * EmailSetting updateManyAndReturn
   */
  export type EmailSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSetting
     */
    select?: EmailSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSetting
     */
    omit?: EmailSettingOmit<ExtArgs> | null
    /**
     * The data used to update EmailSettings.
     */
    data: XOR<EmailSettingUpdateManyMutationInput, EmailSettingUncheckedUpdateManyInput>
    /**
     * Filter which EmailSettings to update
     */
    where?: EmailSettingWhereInput
    /**
     * Limit how many EmailSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSettingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailSetting upsert
   */
  export type EmailSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSetting
     */
    select?: EmailSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSetting
     */
    omit?: EmailSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailSetting to update in case it exists.
     */
    where: EmailSettingWhereUniqueInput
    /**
     * In case the EmailSetting found by the `where` argument doesn't exist, create a new EmailSetting with this data.
     */
    create: XOR<EmailSettingCreateInput, EmailSettingUncheckedCreateInput>
    /**
     * In case the EmailSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailSettingUpdateInput, EmailSettingUncheckedUpdateInput>
  }

  /**
   * EmailSetting delete
   */
  export type EmailSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSetting
     */
    select?: EmailSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSetting
     */
    omit?: EmailSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSettingInclude<ExtArgs> | null
    /**
     * Filter which EmailSetting to delete.
     */
    where: EmailSettingWhereUniqueInput
  }

  /**
   * EmailSetting deleteMany
   */
  export type EmailSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailSettings to delete
     */
    where?: EmailSettingWhereInput
    /**
     * Limit how many EmailSettings to delete.
     */
    limit?: number
  }

  /**
   * EmailSetting.subscriptionTemplate
   */
  export type EmailSetting$subscriptionTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    where?: EmailTemplateWhereInput
  }

  /**
   * EmailSetting.freeEbookTemplate
   */
  export type EmailSetting$freeEbookTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    where?: EmailTemplateWhereInput
  }

  /**
   * EmailSetting.webinarTemplate
   */
  export type EmailSetting$webinarTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    where?: EmailTemplateWhereInput
  }

  /**
   * EmailSetting without action
   */
  export type EmailSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSetting
     */
    select?: EmailSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSetting
     */
    omit?: EmailSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSettingInclude<ExtArgs> | null
  }


  /**
   * Model EmailTemplate
   */

  export type AggregateEmailTemplate = {
    _count: EmailTemplateCountAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  export type EmailTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    bodyHtml: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    bodyHtml: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    designData:PrismaJson.EmailDesignData
    bodyHtml: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailTemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    bodyHtml?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    bodyHtml?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    designData?: true
    bodyHtml?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplate to aggregate.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailTemplates
    **/
    _count?: true | EmailTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type GetEmailTemplateAggregateType<T extends EmailTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailTemplate[P]>
      : GetScalarType<T[P], AggregateEmailTemplate[P]>
  }




  export type EmailTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTemplateWhereInput
    orderBy?: EmailTemplateOrderByWithAggregationInput | EmailTemplateOrderByWithAggregationInput[]
    by: EmailTemplateScalarFieldEnum[] | EmailTemplateScalarFieldEnum
    having?: EmailTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailTemplateCountAggregateInputType | true
    _min?: EmailTemplateMinAggregateInputType
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type EmailTemplateGroupByOutputType = {
    id: string
    name: string
    description: string | null
    designData:PrismaJson.EmailDesignData | null
    bodyHtml: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmailTemplateCountAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  type GetEmailTemplateGroupByPayload<T extends EmailTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
        }
      >
    >


  export type EmailTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    designData?: boolean
    bodyHtml?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailSettingSubscription?: boolean | EmailTemplate$emailSettingSubscriptionArgs<ExtArgs>
    emailSettingFreeEbook?: boolean | EmailTemplate$emailSettingFreeEbookArgs<ExtArgs>
    emailSettingWebinar?: boolean | EmailTemplate$emailSettingWebinarArgs<ExtArgs>
    _count?: boolean | EmailTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    designData?: boolean
    bodyHtml?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    designData?: boolean
    bodyHtml?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    designData?: boolean
    bodyHtml?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "designData" | "bodyHtml" | "createdAt" | "updatedAt", ExtArgs["result"]["emailTemplate"]>
  export type EmailTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailSettingSubscription?: boolean | EmailTemplate$emailSettingSubscriptionArgs<ExtArgs>
    emailSettingFreeEbook?: boolean | EmailTemplate$emailSettingFreeEbookArgs<ExtArgs>
    emailSettingWebinar?: boolean | EmailTemplate$emailSettingWebinarArgs<ExtArgs>
    _count?: boolean | EmailTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmailTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EmailTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EmailTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailTemplate"
    objects: {
      emailSettingSubscription: Prisma.$EmailSettingPayload<ExtArgs>[]
      emailSettingFreeEbook: Prisma.$EmailSettingPayload<ExtArgs>[]
      emailSettingWebinar: Prisma.$EmailSettingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      /**
       * [EmailDesignData]
       */
      designData:PrismaJson.EmailDesignData | null
      bodyHtml: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailTemplate"]>
    composites: {}
  }

  type EmailTemplateGetPayload<S extends boolean | null | undefined | EmailTemplateDefaultArgs> = $Result.GetResult<Prisma.$EmailTemplatePayload, S>

  type EmailTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailTemplateCountAggregateInputType | true
    }

  export interface EmailTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailTemplate'], meta: { name: 'EmailTemplate' } }
    /**
     * Find zero or one EmailTemplate that matches the filter.
     * @param {EmailTemplateFindUniqueArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailTemplateFindUniqueArgs>(args: SelectSubset<T, EmailTemplateFindUniqueArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailTemplateFindUniqueOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailTemplateFindFirstArgs>(args?: SelectSubset<T, EmailTemplateFindFirstArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany()
     * 
     * // Get first 10 EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailTemplateFindManyArgs>(args?: SelectSubset<T, EmailTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailTemplate.
     * @param {EmailTemplateCreateArgs} args - Arguments to create a EmailTemplate.
     * @example
     * // Create one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.create({
     *   data: {
     *     // ... data to create a EmailTemplate
     *   }
     * })
     * 
     */
    create<T extends EmailTemplateCreateArgs>(args: SelectSubset<T, EmailTemplateCreateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailTemplates.
     * @param {EmailTemplateCreateManyArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailTemplateCreateManyArgs>(args?: SelectSubset<T, EmailTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailTemplates and returns the data saved in the database.
     * @param {EmailTemplateCreateManyAndReturnArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailTemplates and only return the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailTemplate.
     * @param {EmailTemplateDeleteArgs} args - Arguments to delete one EmailTemplate.
     * @example
     * // Delete one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.delete({
     *   where: {
     *     // ... filter to delete one EmailTemplate
     *   }
     * })
     * 
     */
    delete<T extends EmailTemplateDeleteArgs>(args: SelectSubset<T, EmailTemplateDeleteArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailTemplate.
     * @param {EmailTemplateUpdateArgs} args - Arguments to update one EmailTemplate.
     * @example
     * // Update one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailTemplateUpdateArgs>(args: SelectSubset<T, EmailTemplateUpdateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailTemplates.
     * @param {EmailTemplateDeleteManyArgs} args - Arguments to filter EmailTemplates to delete.
     * @example
     * // Delete a few EmailTemplates
     * const { count } = await prisma.emailTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailTemplateDeleteManyArgs>(args?: SelectSubset<T, EmailTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailTemplateUpdateManyArgs>(args: SelectSubset<T, EmailTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTemplates and returns the data updated in the database.
     * @param {EmailTemplateUpdateManyAndReturnArgs} args - Arguments to update many EmailTemplates.
     * @example
     * // Update many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailTemplates and only return the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailTemplate.
     * @param {EmailTemplateUpsertArgs} args - Arguments to update or create a EmailTemplate.
     * @example
     * // Update or create a EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.upsert({
     *   create: {
     *     // ... data to create a EmailTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailTemplate we want to update
     *   }
     * })
     */
    upsert<T extends EmailTemplateUpsertArgs>(args: SelectSubset<T, EmailTemplateUpsertArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateCountArgs} args - Arguments to filter EmailTemplates to count.
     * @example
     * // Count the number of EmailTemplates
     * const count = await prisma.emailTemplate.count({
     *   where: {
     *     // ... the filter for the EmailTemplates we want to count
     *   }
     * })
    **/
    count<T extends EmailTemplateCountArgs>(
      args?: Subset<T, EmailTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailTemplateAggregateArgs>(args: Subset<T, EmailTemplateAggregateArgs>): Prisma.PrismaPromise<GetEmailTemplateAggregateType<T>>

    /**
     * Group by EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailTemplateGroupByArgs['orderBy'] }
        : { orderBy?: EmailTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailTemplate model
   */
  readonly fields: EmailTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emailSettingSubscription<T extends EmailTemplate$emailSettingSubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, EmailTemplate$emailSettingSubscriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailSettingFreeEbook<T extends EmailTemplate$emailSettingFreeEbookArgs<ExtArgs> = {}>(args?: Subset<T, EmailTemplate$emailSettingFreeEbookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailSettingWebinar<T extends EmailTemplate$emailSettingWebinarArgs<ExtArgs> = {}>(args?: Subset<T, EmailTemplate$emailSettingWebinarArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailTemplate model
   */
  interface EmailTemplateFieldRefs {
    readonly id: FieldRef<"EmailTemplate", 'String'>
    readonly name: FieldRef<"EmailTemplate", 'String'>
    readonly description: FieldRef<"EmailTemplate", 'String'>
    readonly designData: FieldRef<"EmailTemplate", 'Json'>
    readonly bodyHtml: FieldRef<"EmailTemplate", 'String'>
    readonly createdAt: FieldRef<"EmailTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailTemplate findUnique
   */
  export type EmailTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findUniqueOrThrow
   */
  export type EmailTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findFirst
   */
  export type EmailTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findFirstOrThrow
   */
  export type EmailTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findMany
   */
  export type EmailTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplates to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate create
   */
  export type EmailTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailTemplate.
     */
    data: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
  }

  /**
   * EmailTemplate createMany
   */
  export type EmailTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailTemplate createManyAndReturn
   */
  export type EmailTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailTemplate update
   */
  export type EmailTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailTemplate.
     */
    data: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
    /**
     * Choose, which EmailTemplate to update.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate updateMany
   */
  export type EmailTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailTemplates.
     */
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EmailTemplates to update
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to update.
     */
    limit?: number
  }

  /**
   * EmailTemplate updateManyAndReturn
   */
  export type EmailTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The data used to update EmailTemplates.
     */
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EmailTemplates to update
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to update.
     */
    limit?: number
  }

  /**
   * EmailTemplate upsert
   */
  export type EmailTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailTemplate to update in case it exists.
     */
    where: EmailTemplateWhereUniqueInput
    /**
     * In case the EmailTemplate found by the `where` argument doesn't exist, create a new EmailTemplate with this data.
     */
    create: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
    /**
     * In case the EmailTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
  }

  /**
   * EmailTemplate delete
   */
  export type EmailTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter which EmailTemplate to delete.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate deleteMany
   */
  export type EmailTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplates to delete
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to delete.
     */
    limit?: number
  }

  /**
   * EmailTemplate.emailSettingSubscription
   */
  export type EmailTemplate$emailSettingSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSetting
     */
    select?: EmailSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSetting
     */
    omit?: EmailSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSettingInclude<ExtArgs> | null
    where?: EmailSettingWhereInput
    orderBy?: EmailSettingOrderByWithRelationInput | EmailSettingOrderByWithRelationInput[]
    cursor?: EmailSettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailSettingScalarFieldEnum | EmailSettingScalarFieldEnum[]
  }

  /**
   * EmailTemplate.emailSettingFreeEbook
   */
  export type EmailTemplate$emailSettingFreeEbookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSetting
     */
    select?: EmailSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSetting
     */
    omit?: EmailSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSettingInclude<ExtArgs> | null
    where?: EmailSettingWhereInput
    orderBy?: EmailSettingOrderByWithRelationInput | EmailSettingOrderByWithRelationInput[]
    cursor?: EmailSettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailSettingScalarFieldEnum | EmailSettingScalarFieldEnum[]
  }

  /**
   * EmailTemplate.emailSettingWebinar
   */
  export type EmailTemplate$emailSettingWebinarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSetting
     */
    select?: EmailSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSetting
     */
    omit?: EmailSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSettingInclude<ExtArgs> | null
    where?: EmailSettingWhereInput
    orderBy?: EmailSettingOrderByWithRelationInput | EmailSettingOrderByWithRelationInput[]
    cursor?: EmailSettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailSettingScalarFieldEnum | EmailSettingScalarFieldEnum[]
  }

  /**
   * EmailTemplate without action
   */
  export type EmailTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
  }


  /**
   * Model EmailAudience
   */

  export type AggregateEmailAudience = {
    _count: EmailAudienceCountAggregateOutputType | null
    _min: EmailAudienceMinAggregateOutputType | null
    _max: EmailAudienceMaxAggregateOutputType | null
  }

  export type EmailAudienceMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.AudienceType | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailAudienceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.AudienceType | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailAudienceCountAggregateOutputType = {
    id: number
    name: number
    type: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailAudienceMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailAudienceMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailAudienceCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailAudienceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAudience to aggregate.
     */
    where?: EmailAudienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAudiences to fetch.
     */
    orderBy?: EmailAudienceOrderByWithRelationInput | EmailAudienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailAudienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAudiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAudiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailAudiences
    **/
    _count?: true | EmailAudienceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailAudienceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailAudienceMaxAggregateInputType
  }

  export type GetEmailAudienceAggregateType<T extends EmailAudienceAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailAudience]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailAudience[P]>
      : GetScalarType<T[P], AggregateEmailAudience[P]>
  }




  export type EmailAudienceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAudienceWhereInput
    orderBy?: EmailAudienceOrderByWithAggregationInput | EmailAudienceOrderByWithAggregationInput[]
    by: EmailAudienceScalarFieldEnum[] | EmailAudienceScalarFieldEnum
    having?: EmailAudienceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailAudienceCountAggregateInputType | true
    _min?: EmailAudienceMinAggregateInputType
    _max?: EmailAudienceMaxAggregateInputType
  }

  export type EmailAudienceGroupByOutputType = {
    id: string
    name: string
    type: $Enums.AudienceType
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmailAudienceCountAggregateOutputType | null
    _min: EmailAudienceMinAggregateOutputType | null
    _max: EmailAudienceMaxAggregateOutputType | null
  }

  type GetEmailAudienceGroupByPayload<T extends EmailAudienceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailAudienceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailAudienceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailAudienceGroupByOutputType[P]>
            : GetScalarType<T[P], EmailAudienceGroupByOutputType[P]>
        }
      >
    >


  export type EmailAudienceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contacts?: boolean | EmailAudience$contactsArgs<ExtArgs>
    emailSingleSends?: boolean | EmailAudience$emailSingleSendsArgs<ExtArgs>
    _count?: boolean | EmailAudienceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAudience"]>

  export type EmailAudienceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailAudience"]>

  export type EmailAudienceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailAudience"]>

  export type EmailAudienceSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailAudienceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["emailAudience"]>
  export type EmailAudienceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | EmailAudience$contactsArgs<ExtArgs>
    emailSingleSends?: boolean | EmailAudience$emailSingleSendsArgs<ExtArgs>
    _count?: boolean | EmailAudienceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmailAudienceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EmailAudienceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EmailAudiencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailAudience"
    objects: {
      contacts: Prisma.$EmailContactPayload<ExtArgs>[]
      emailSingleSends: Prisma.$EmailSingleSendPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.AudienceType
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailAudience"]>
    composites: {}
  }

  type EmailAudienceGetPayload<S extends boolean | null | undefined | EmailAudienceDefaultArgs> = $Result.GetResult<Prisma.$EmailAudiencePayload, S>

  type EmailAudienceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailAudienceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailAudienceCountAggregateInputType | true
    }

  export interface EmailAudienceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailAudience'], meta: { name: 'EmailAudience' } }
    /**
     * Find zero or one EmailAudience that matches the filter.
     * @param {EmailAudienceFindUniqueArgs} args - Arguments to find a EmailAudience
     * @example
     * // Get one EmailAudience
     * const emailAudience = await prisma.emailAudience.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailAudienceFindUniqueArgs>(args: SelectSubset<T, EmailAudienceFindUniqueArgs<ExtArgs>>): Prisma__EmailAudienceClient<$Result.GetResult<Prisma.$EmailAudiencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailAudience that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailAudienceFindUniqueOrThrowArgs} args - Arguments to find a EmailAudience
     * @example
     * // Get one EmailAudience
     * const emailAudience = await prisma.emailAudience.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailAudienceFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailAudienceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailAudienceClient<$Result.GetResult<Prisma.$EmailAudiencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailAudience that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAudienceFindFirstArgs} args - Arguments to find a EmailAudience
     * @example
     * // Get one EmailAudience
     * const emailAudience = await prisma.emailAudience.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailAudienceFindFirstArgs>(args?: SelectSubset<T, EmailAudienceFindFirstArgs<ExtArgs>>): Prisma__EmailAudienceClient<$Result.GetResult<Prisma.$EmailAudiencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailAudience that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAudienceFindFirstOrThrowArgs} args - Arguments to find a EmailAudience
     * @example
     * // Get one EmailAudience
     * const emailAudience = await prisma.emailAudience.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailAudienceFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailAudienceFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailAudienceClient<$Result.GetResult<Prisma.$EmailAudiencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailAudiences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAudienceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailAudiences
     * const emailAudiences = await prisma.emailAudience.findMany()
     * 
     * // Get first 10 EmailAudiences
     * const emailAudiences = await prisma.emailAudience.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailAudienceWithIdOnly = await prisma.emailAudience.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailAudienceFindManyArgs>(args?: SelectSubset<T, EmailAudienceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAudiencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailAudience.
     * @param {EmailAudienceCreateArgs} args - Arguments to create a EmailAudience.
     * @example
     * // Create one EmailAudience
     * const EmailAudience = await prisma.emailAudience.create({
     *   data: {
     *     // ... data to create a EmailAudience
     *   }
     * })
     * 
     */
    create<T extends EmailAudienceCreateArgs>(args: SelectSubset<T, EmailAudienceCreateArgs<ExtArgs>>): Prisma__EmailAudienceClient<$Result.GetResult<Prisma.$EmailAudiencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailAudiences.
     * @param {EmailAudienceCreateManyArgs} args - Arguments to create many EmailAudiences.
     * @example
     * // Create many EmailAudiences
     * const emailAudience = await prisma.emailAudience.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailAudienceCreateManyArgs>(args?: SelectSubset<T, EmailAudienceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailAudiences and returns the data saved in the database.
     * @param {EmailAudienceCreateManyAndReturnArgs} args - Arguments to create many EmailAudiences.
     * @example
     * // Create many EmailAudiences
     * const emailAudience = await prisma.emailAudience.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailAudiences and only return the `id`
     * const emailAudienceWithIdOnly = await prisma.emailAudience.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailAudienceCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailAudienceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAudiencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailAudience.
     * @param {EmailAudienceDeleteArgs} args - Arguments to delete one EmailAudience.
     * @example
     * // Delete one EmailAudience
     * const EmailAudience = await prisma.emailAudience.delete({
     *   where: {
     *     // ... filter to delete one EmailAudience
     *   }
     * })
     * 
     */
    delete<T extends EmailAudienceDeleteArgs>(args: SelectSubset<T, EmailAudienceDeleteArgs<ExtArgs>>): Prisma__EmailAudienceClient<$Result.GetResult<Prisma.$EmailAudiencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailAudience.
     * @param {EmailAudienceUpdateArgs} args - Arguments to update one EmailAudience.
     * @example
     * // Update one EmailAudience
     * const emailAudience = await prisma.emailAudience.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailAudienceUpdateArgs>(args: SelectSubset<T, EmailAudienceUpdateArgs<ExtArgs>>): Prisma__EmailAudienceClient<$Result.GetResult<Prisma.$EmailAudiencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailAudiences.
     * @param {EmailAudienceDeleteManyArgs} args - Arguments to filter EmailAudiences to delete.
     * @example
     * // Delete a few EmailAudiences
     * const { count } = await prisma.emailAudience.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailAudienceDeleteManyArgs>(args?: SelectSubset<T, EmailAudienceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailAudiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAudienceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailAudiences
     * const emailAudience = await prisma.emailAudience.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailAudienceUpdateManyArgs>(args: SelectSubset<T, EmailAudienceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailAudiences and returns the data updated in the database.
     * @param {EmailAudienceUpdateManyAndReturnArgs} args - Arguments to update many EmailAudiences.
     * @example
     * // Update many EmailAudiences
     * const emailAudience = await prisma.emailAudience.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailAudiences and only return the `id`
     * const emailAudienceWithIdOnly = await prisma.emailAudience.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailAudienceUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailAudienceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAudiencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailAudience.
     * @param {EmailAudienceUpsertArgs} args - Arguments to update or create a EmailAudience.
     * @example
     * // Update or create a EmailAudience
     * const emailAudience = await prisma.emailAudience.upsert({
     *   create: {
     *     // ... data to create a EmailAudience
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailAudience we want to update
     *   }
     * })
     */
    upsert<T extends EmailAudienceUpsertArgs>(args: SelectSubset<T, EmailAudienceUpsertArgs<ExtArgs>>): Prisma__EmailAudienceClient<$Result.GetResult<Prisma.$EmailAudiencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailAudiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAudienceCountArgs} args - Arguments to filter EmailAudiences to count.
     * @example
     * // Count the number of EmailAudiences
     * const count = await prisma.emailAudience.count({
     *   where: {
     *     // ... the filter for the EmailAudiences we want to count
     *   }
     * })
    **/
    count<T extends EmailAudienceCountArgs>(
      args?: Subset<T, EmailAudienceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailAudienceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailAudience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAudienceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailAudienceAggregateArgs>(args: Subset<T, EmailAudienceAggregateArgs>): Prisma.PrismaPromise<GetEmailAudienceAggregateType<T>>

    /**
     * Group by EmailAudience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAudienceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailAudienceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailAudienceGroupByArgs['orderBy'] }
        : { orderBy?: EmailAudienceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailAudienceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailAudienceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailAudience model
   */
  readonly fields: EmailAudienceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailAudience.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailAudienceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contacts<T extends EmailAudience$contactsArgs<ExtArgs> = {}>(args?: Subset<T, EmailAudience$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailSingleSends<T extends EmailAudience$emailSingleSendsArgs<ExtArgs> = {}>(args?: Subset<T, EmailAudience$emailSingleSendsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSingleSendPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailAudience model
   */
  interface EmailAudienceFieldRefs {
    readonly id: FieldRef<"EmailAudience", 'String'>
    readonly name: FieldRef<"EmailAudience", 'String'>
    readonly type: FieldRef<"EmailAudience", 'AudienceType'>
    readonly description: FieldRef<"EmailAudience", 'String'>
    readonly createdAt: FieldRef<"EmailAudience", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailAudience", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailAudience findUnique
   */
  export type EmailAudienceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAudience
     */
    select?: EmailAudienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAudience
     */
    omit?: EmailAudienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAudienceInclude<ExtArgs> | null
    /**
     * Filter, which EmailAudience to fetch.
     */
    where: EmailAudienceWhereUniqueInput
  }

  /**
   * EmailAudience findUniqueOrThrow
   */
  export type EmailAudienceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAudience
     */
    select?: EmailAudienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAudience
     */
    omit?: EmailAudienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAudienceInclude<ExtArgs> | null
    /**
     * Filter, which EmailAudience to fetch.
     */
    where: EmailAudienceWhereUniqueInput
  }

  /**
   * EmailAudience findFirst
   */
  export type EmailAudienceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAudience
     */
    select?: EmailAudienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAudience
     */
    omit?: EmailAudienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAudienceInclude<ExtArgs> | null
    /**
     * Filter, which EmailAudience to fetch.
     */
    where?: EmailAudienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAudiences to fetch.
     */
    orderBy?: EmailAudienceOrderByWithRelationInput | EmailAudienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAudiences.
     */
    cursor?: EmailAudienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAudiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAudiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAudiences.
     */
    distinct?: EmailAudienceScalarFieldEnum | EmailAudienceScalarFieldEnum[]
  }

  /**
   * EmailAudience findFirstOrThrow
   */
  export type EmailAudienceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAudience
     */
    select?: EmailAudienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAudience
     */
    omit?: EmailAudienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAudienceInclude<ExtArgs> | null
    /**
     * Filter, which EmailAudience to fetch.
     */
    where?: EmailAudienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAudiences to fetch.
     */
    orderBy?: EmailAudienceOrderByWithRelationInput | EmailAudienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAudiences.
     */
    cursor?: EmailAudienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAudiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAudiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAudiences.
     */
    distinct?: EmailAudienceScalarFieldEnum | EmailAudienceScalarFieldEnum[]
  }

  /**
   * EmailAudience findMany
   */
  export type EmailAudienceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAudience
     */
    select?: EmailAudienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAudience
     */
    omit?: EmailAudienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAudienceInclude<ExtArgs> | null
    /**
     * Filter, which EmailAudiences to fetch.
     */
    where?: EmailAudienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAudiences to fetch.
     */
    orderBy?: EmailAudienceOrderByWithRelationInput | EmailAudienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailAudiences.
     */
    cursor?: EmailAudienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAudiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAudiences.
     */
    skip?: number
    distinct?: EmailAudienceScalarFieldEnum | EmailAudienceScalarFieldEnum[]
  }

  /**
   * EmailAudience create
   */
  export type EmailAudienceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAudience
     */
    select?: EmailAudienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAudience
     */
    omit?: EmailAudienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAudienceInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailAudience.
     */
    data: XOR<EmailAudienceCreateInput, EmailAudienceUncheckedCreateInput>
  }

  /**
   * EmailAudience createMany
   */
  export type EmailAudienceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailAudiences.
     */
    data: EmailAudienceCreateManyInput | EmailAudienceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailAudience createManyAndReturn
   */
  export type EmailAudienceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAudience
     */
    select?: EmailAudienceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAudience
     */
    omit?: EmailAudienceOmit<ExtArgs> | null
    /**
     * The data used to create many EmailAudiences.
     */
    data: EmailAudienceCreateManyInput | EmailAudienceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailAudience update
   */
  export type EmailAudienceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAudience
     */
    select?: EmailAudienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAudience
     */
    omit?: EmailAudienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAudienceInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailAudience.
     */
    data: XOR<EmailAudienceUpdateInput, EmailAudienceUncheckedUpdateInput>
    /**
     * Choose, which EmailAudience to update.
     */
    where: EmailAudienceWhereUniqueInput
  }

  /**
   * EmailAudience updateMany
   */
  export type EmailAudienceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailAudiences.
     */
    data: XOR<EmailAudienceUpdateManyMutationInput, EmailAudienceUncheckedUpdateManyInput>
    /**
     * Filter which EmailAudiences to update
     */
    where?: EmailAudienceWhereInput
    /**
     * Limit how many EmailAudiences to update.
     */
    limit?: number
  }

  /**
   * EmailAudience updateManyAndReturn
   */
  export type EmailAudienceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAudience
     */
    select?: EmailAudienceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAudience
     */
    omit?: EmailAudienceOmit<ExtArgs> | null
    /**
     * The data used to update EmailAudiences.
     */
    data: XOR<EmailAudienceUpdateManyMutationInput, EmailAudienceUncheckedUpdateManyInput>
    /**
     * Filter which EmailAudiences to update
     */
    where?: EmailAudienceWhereInput
    /**
     * Limit how many EmailAudiences to update.
     */
    limit?: number
  }

  /**
   * EmailAudience upsert
   */
  export type EmailAudienceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAudience
     */
    select?: EmailAudienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAudience
     */
    omit?: EmailAudienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAudienceInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailAudience to update in case it exists.
     */
    where: EmailAudienceWhereUniqueInput
    /**
     * In case the EmailAudience found by the `where` argument doesn't exist, create a new EmailAudience with this data.
     */
    create: XOR<EmailAudienceCreateInput, EmailAudienceUncheckedCreateInput>
    /**
     * In case the EmailAudience was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailAudienceUpdateInput, EmailAudienceUncheckedUpdateInput>
  }

  /**
   * EmailAudience delete
   */
  export type EmailAudienceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAudience
     */
    select?: EmailAudienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAudience
     */
    omit?: EmailAudienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAudienceInclude<ExtArgs> | null
    /**
     * Filter which EmailAudience to delete.
     */
    where: EmailAudienceWhereUniqueInput
  }

  /**
   * EmailAudience deleteMany
   */
  export type EmailAudienceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAudiences to delete
     */
    where?: EmailAudienceWhereInput
    /**
     * Limit how many EmailAudiences to delete.
     */
    limit?: number
  }

  /**
   * EmailAudience.contacts
   */
  export type EmailAudience$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInclude<ExtArgs> | null
    where?: EmailContactWhereInput
    orderBy?: EmailContactOrderByWithRelationInput | EmailContactOrderByWithRelationInput[]
    cursor?: EmailContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailContactScalarFieldEnum | EmailContactScalarFieldEnum[]
  }

  /**
   * EmailAudience.emailSingleSends
   */
  export type EmailAudience$emailSingleSendsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSend
     */
    select?: EmailSingleSendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSend
     */
    omit?: EmailSingleSendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendInclude<ExtArgs> | null
    where?: EmailSingleSendWhereInput
    orderBy?: EmailSingleSendOrderByWithRelationInput | EmailSingleSendOrderByWithRelationInput[]
    cursor?: EmailSingleSendWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailSingleSendScalarFieldEnum | EmailSingleSendScalarFieldEnum[]
  }

  /**
   * EmailAudience without action
   */
  export type EmailAudienceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAudience
     */
    select?: EmailAudienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAudience
     */
    omit?: EmailAudienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAudienceInclude<ExtArgs> | null
  }


  /**
   * Model EmailContact
   */

  export type AggregateEmailContact = {
    _count: EmailContactCountAggregateOutputType | null
    _min: EmailContactMinAggregateOutputType | null
    _max: EmailContactMaxAggregateOutputType | null
  }

  export type EmailContactMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    emailVerified: Date | null
    isSubscriber: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailContactMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    emailVerified: Date | null
    isSubscriber: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailContactCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    emailVerified: number
    isSubscriber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailContactMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    emailVerified?: true
    isSubscriber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailContactMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    emailVerified?: true
    isSubscriber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailContactCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    emailVerified?: true
    isSubscriber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailContact to aggregate.
     */
    where?: EmailContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailContacts to fetch.
     */
    orderBy?: EmailContactOrderByWithRelationInput | EmailContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailContacts
    **/
    _count?: true | EmailContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailContactMaxAggregateInputType
  }

  export type GetEmailContactAggregateType<T extends EmailContactAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailContact[P]>
      : GetScalarType<T[P], AggregateEmailContact[P]>
  }




  export type EmailContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailContactWhereInput
    orderBy?: EmailContactOrderByWithAggregationInput | EmailContactOrderByWithAggregationInput[]
    by: EmailContactScalarFieldEnum[] | EmailContactScalarFieldEnum
    having?: EmailContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailContactCountAggregateInputType | true
    _min?: EmailContactMinAggregateInputType
    _max?: EmailContactMaxAggregateInputType
  }

  export type EmailContactGroupByOutputType = {
    id: string
    firstName: string | null
    lastName: string | null
    email: string
    emailVerified: Date | null
    isSubscriber: boolean
    createdAt: Date
    updatedAt: Date
    _count: EmailContactCountAggregateOutputType | null
    _min: EmailContactMinAggregateOutputType | null
    _max: EmailContactMaxAggregateOutputType | null
  }

  type GetEmailContactGroupByPayload<T extends EmailContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailContactGroupByOutputType[P]>
            : GetScalarType<T[P], EmailContactGroupByOutputType[P]>
        }
      >
    >


  export type EmailContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    emailVerified?: boolean
    isSubscriber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audiences?: boolean | EmailContact$audiencesArgs<ExtArgs>
    interactions?: boolean | EmailContact$interactionsArgs<ExtArgs>
    emailSingleSendLogs?: boolean | EmailContact$emailSingleSendLogsArgs<ExtArgs>
    _count?: boolean | EmailContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailContact"]>

  export type EmailContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    emailVerified?: boolean
    isSubscriber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailContact"]>

  export type EmailContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    emailVerified?: boolean
    isSubscriber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailContact"]>

  export type EmailContactSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    emailVerified?: boolean
    isSubscriber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "email" | "emailVerified" | "isSubscriber" | "createdAt" | "updatedAt", ExtArgs["result"]["emailContact"]>
  export type EmailContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audiences?: boolean | EmailContact$audiencesArgs<ExtArgs>
    interactions?: boolean | EmailContact$interactionsArgs<ExtArgs>
    emailSingleSendLogs?: boolean | EmailContact$emailSingleSendLogsArgs<ExtArgs>
    _count?: boolean | EmailContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmailContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EmailContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EmailContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailContact"
    objects: {
      audiences: Prisma.$EmailAudiencePayload<ExtArgs>[]
      interactions: Prisma.$EmailContactInteractionPayload<ExtArgs>[]
      emailSingleSendLogs: Prisma.$EmailSingleSendLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string | null
      lastName: string | null
      email: string
      emailVerified: Date | null
      isSubscriber: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailContact"]>
    composites: {}
  }

  type EmailContactGetPayload<S extends boolean | null | undefined | EmailContactDefaultArgs> = $Result.GetResult<Prisma.$EmailContactPayload, S>

  type EmailContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailContactCountAggregateInputType | true
    }

  export interface EmailContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailContact'], meta: { name: 'EmailContact' } }
    /**
     * Find zero or one EmailContact that matches the filter.
     * @param {EmailContactFindUniqueArgs} args - Arguments to find a EmailContact
     * @example
     * // Get one EmailContact
     * const emailContact = await prisma.emailContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailContactFindUniqueArgs>(args: SelectSubset<T, EmailContactFindUniqueArgs<ExtArgs>>): Prisma__EmailContactClient<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailContactFindUniqueOrThrowArgs} args - Arguments to find a EmailContact
     * @example
     * // Get one EmailContact
     * const emailContact = await prisma.emailContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailContactFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailContactClient<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailContactFindFirstArgs} args - Arguments to find a EmailContact
     * @example
     * // Get one EmailContact
     * const emailContact = await prisma.emailContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailContactFindFirstArgs>(args?: SelectSubset<T, EmailContactFindFirstArgs<ExtArgs>>): Prisma__EmailContactClient<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailContactFindFirstOrThrowArgs} args - Arguments to find a EmailContact
     * @example
     * // Get one EmailContact
     * const emailContact = await prisma.emailContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailContactFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailContactClient<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailContacts
     * const emailContacts = await prisma.emailContact.findMany()
     * 
     * // Get first 10 EmailContacts
     * const emailContacts = await prisma.emailContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailContactWithIdOnly = await prisma.emailContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailContactFindManyArgs>(args?: SelectSubset<T, EmailContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailContact.
     * @param {EmailContactCreateArgs} args - Arguments to create a EmailContact.
     * @example
     * // Create one EmailContact
     * const EmailContact = await prisma.emailContact.create({
     *   data: {
     *     // ... data to create a EmailContact
     *   }
     * })
     * 
     */
    create<T extends EmailContactCreateArgs>(args: SelectSubset<T, EmailContactCreateArgs<ExtArgs>>): Prisma__EmailContactClient<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailContacts.
     * @param {EmailContactCreateManyArgs} args - Arguments to create many EmailContacts.
     * @example
     * // Create many EmailContacts
     * const emailContact = await prisma.emailContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailContactCreateManyArgs>(args?: SelectSubset<T, EmailContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailContacts and returns the data saved in the database.
     * @param {EmailContactCreateManyAndReturnArgs} args - Arguments to create many EmailContacts.
     * @example
     * // Create many EmailContacts
     * const emailContact = await prisma.emailContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailContacts and only return the `id`
     * const emailContactWithIdOnly = await prisma.emailContact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailContactCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailContact.
     * @param {EmailContactDeleteArgs} args - Arguments to delete one EmailContact.
     * @example
     * // Delete one EmailContact
     * const EmailContact = await prisma.emailContact.delete({
     *   where: {
     *     // ... filter to delete one EmailContact
     *   }
     * })
     * 
     */
    delete<T extends EmailContactDeleteArgs>(args: SelectSubset<T, EmailContactDeleteArgs<ExtArgs>>): Prisma__EmailContactClient<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailContact.
     * @param {EmailContactUpdateArgs} args - Arguments to update one EmailContact.
     * @example
     * // Update one EmailContact
     * const emailContact = await prisma.emailContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailContactUpdateArgs>(args: SelectSubset<T, EmailContactUpdateArgs<ExtArgs>>): Prisma__EmailContactClient<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailContacts.
     * @param {EmailContactDeleteManyArgs} args - Arguments to filter EmailContacts to delete.
     * @example
     * // Delete a few EmailContacts
     * const { count } = await prisma.emailContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailContactDeleteManyArgs>(args?: SelectSubset<T, EmailContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailContacts
     * const emailContact = await prisma.emailContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailContactUpdateManyArgs>(args: SelectSubset<T, EmailContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailContacts and returns the data updated in the database.
     * @param {EmailContactUpdateManyAndReturnArgs} args - Arguments to update many EmailContacts.
     * @example
     * // Update many EmailContacts
     * const emailContact = await prisma.emailContact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailContacts and only return the `id`
     * const emailContactWithIdOnly = await prisma.emailContact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailContactUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailContact.
     * @param {EmailContactUpsertArgs} args - Arguments to update or create a EmailContact.
     * @example
     * // Update or create a EmailContact
     * const emailContact = await prisma.emailContact.upsert({
     *   create: {
     *     // ... data to create a EmailContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailContact we want to update
     *   }
     * })
     */
    upsert<T extends EmailContactUpsertArgs>(args: SelectSubset<T, EmailContactUpsertArgs<ExtArgs>>): Prisma__EmailContactClient<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailContactCountArgs} args - Arguments to filter EmailContacts to count.
     * @example
     * // Count the number of EmailContacts
     * const count = await prisma.emailContact.count({
     *   where: {
     *     // ... the filter for the EmailContacts we want to count
     *   }
     * })
    **/
    count<T extends EmailContactCountArgs>(
      args?: Subset<T, EmailContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailContactAggregateArgs>(args: Subset<T, EmailContactAggregateArgs>): Prisma.PrismaPromise<GetEmailContactAggregateType<T>>

    /**
     * Group by EmailContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailContactGroupByArgs['orderBy'] }
        : { orderBy?: EmailContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailContact model
   */
  readonly fields: EmailContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    audiences<T extends EmailContact$audiencesArgs<ExtArgs> = {}>(args?: Subset<T, EmailContact$audiencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAudiencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    interactions<T extends EmailContact$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, EmailContact$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailContactInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailSingleSendLogs<T extends EmailContact$emailSingleSendLogsArgs<ExtArgs> = {}>(args?: Subset<T, EmailContact$emailSingleSendLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSingleSendLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailContact model
   */
  interface EmailContactFieldRefs {
    readonly id: FieldRef<"EmailContact", 'String'>
    readonly firstName: FieldRef<"EmailContact", 'String'>
    readonly lastName: FieldRef<"EmailContact", 'String'>
    readonly email: FieldRef<"EmailContact", 'String'>
    readonly emailVerified: FieldRef<"EmailContact", 'DateTime'>
    readonly isSubscriber: FieldRef<"EmailContact", 'Boolean'>
    readonly createdAt: FieldRef<"EmailContact", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailContact findUnique
   */
  export type EmailContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInclude<ExtArgs> | null
    /**
     * Filter, which EmailContact to fetch.
     */
    where: EmailContactWhereUniqueInput
  }

  /**
   * EmailContact findUniqueOrThrow
   */
  export type EmailContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInclude<ExtArgs> | null
    /**
     * Filter, which EmailContact to fetch.
     */
    where: EmailContactWhereUniqueInput
  }

  /**
   * EmailContact findFirst
   */
  export type EmailContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInclude<ExtArgs> | null
    /**
     * Filter, which EmailContact to fetch.
     */
    where?: EmailContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailContacts to fetch.
     */
    orderBy?: EmailContactOrderByWithRelationInput | EmailContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailContacts.
     */
    cursor?: EmailContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailContacts.
     */
    distinct?: EmailContactScalarFieldEnum | EmailContactScalarFieldEnum[]
  }

  /**
   * EmailContact findFirstOrThrow
   */
  export type EmailContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInclude<ExtArgs> | null
    /**
     * Filter, which EmailContact to fetch.
     */
    where?: EmailContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailContacts to fetch.
     */
    orderBy?: EmailContactOrderByWithRelationInput | EmailContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailContacts.
     */
    cursor?: EmailContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailContacts.
     */
    distinct?: EmailContactScalarFieldEnum | EmailContactScalarFieldEnum[]
  }

  /**
   * EmailContact findMany
   */
  export type EmailContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInclude<ExtArgs> | null
    /**
     * Filter, which EmailContacts to fetch.
     */
    where?: EmailContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailContacts to fetch.
     */
    orderBy?: EmailContactOrderByWithRelationInput | EmailContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailContacts.
     */
    cursor?: EmailContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailContacts.
     */
    skip?: number
    distinct?: EmailContactScalarFieldEnum | EmailContactScalarFieldEnum[]
  }

  /**
   * EmailContact create
   */
  export type EmailContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailContact.
     */
    data: XOR<EmailContactCreateInput, EmailContactUncheckedCreateInput>
  }

  /**
   * EmailContact createMany
   */
  export type EmailContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailContacts.
     */
    data: EmailContactCreateManyInput | EmailContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailContact createManyAndReturn
   */
  export type EmailContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * The data used to create many EmailContacts.
     */
    data: EmailContactCreateManyInput | EmailContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailContact update
   */
  export type EmailContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailContact.
     */
    data: XOR<EmailContactUpdateInput, EmailContactUncheckedUpdateInput>
    /**
     * Choose, which EmailContact to update.
     */
    where: EmailContactWhereUniqueInput
  }

  /**
   * EmailContact updateMany
   */
  export type EmailContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailContacts.
     */
    data: XOR<EmailContactUpdateManyMutationInput, EmailContactUncheckedUpdateManyInput>
    /**
     * Filter which EmailContacts to update
     */
    where?: EmailContactWhereInput
    /**
     * Limit how many EmailContacts to update.
     */
    limit?: number
  }

  /**
   * EmailContact updateManyAndReturn
   */
  export type EmailContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * The data used to update EmailContacts.
     */
    data: XOR<EmailContactUpdateManyMutationInput, EmailContactUncheckedUpdateManyInput>
    /**
     * Filter which EmailContacts to update
     */
    where?: EmailContactWhereInput
    /**
     * Limit how many EmailContacts to update.
     */
    limit?: number
  }

  /**
   * EmailContact upsert
   */
  export type EmailContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailContact to update in case it exists.
     */
    where: EmailContactWhereUniqueInput
    /**
     * In case the EmailContact found by the `where` argument doesn't exist, create a new EmailContact with this data.
     */
    create: XOR<EmailContactCreateInput, EmailContactUncheckedCreateInput>
    /**
     * In case the EmailContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailContactUpdateInput, EmailContactUncheckedUpdateInput>
  }

  /**
   * EmailContact delete
   */
  export type EmailContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInclude<ExtArgs> | null
    /**
     * Filter which EmailContact to delete.
     */
    where: EmailContactWhereUniqueInput
  }

  /**
   * EmailContact deleteMany
   */
  export type EmailContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailContacts to delete
     */
    where?: EmailContactWhereInput
    /**
     * Limit how many EmailContacts to delete.
     */
    limit?: number
  }

  /**
   * EmailContact.audiences
   */
  export type EmailContact$audiencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAudience
     */
    select?: EmailAudienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAudience
     */
    omit?: EmailAudienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAudienceInclude<ExtArgs> | null
    where?: EmailAudienceWhereInput
    orderBy?: EmailAudienceOrderByWithRelationInput | EmailAudienceOrderByWithRelationInput[]
    cursor?: EmailAudienceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailAudienceScalarFieldEnum | EmailAudienceScalarFieldEnum[]
  }

  /**
   * EmailContact.interactions
   */
  export type EmailContact$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContactInteraction
     */
    select?: EmailContactInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContactInteraction
     */
    omit?: EmailContactInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInteractionInclude<ExtArgs> | null
    where?: EmailContactInteractionWhereInput
    orderBy?: EmailContactInteractionOrderByWithRelationInput | EmailContactInteractionOrderByWithRelationInput[]
    cursor?: EmailContactInteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailContactInteractionScalarFieldEnum | EmailContactInteractionScalarFieldEnum[]
  }

  /**
   * EmailContact.emailSingleSendLogs
   */
  export type EmailContact$emailSingleSendLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSendLog
     */
    select?: EmailSingleSendLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSendLog
     */
    omit?: EmailSingleSendLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendLogInclude<ExtArgs> | null
    where?: EmailSingleSendLogWhereInput
    orderBy?: EmailSingleSendLogOrderByWithRelationInput | EmailSingleSendLogOrderByWithRelationInput[]
    cursor?: EmailSingleSendLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailSingleSendLogScalarFieldEnum | EmailSingleSendLogScalarFieldEnum[]
  }

  /**
   * EmailContact without action
   */
  export type EmailContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContact
     */
    select?: EmailContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContact
     */
    omit?: EmailContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInclude<ExtArgs> | null
  }


  /**
   * Model EmailContactInteraction
   */

  export type AggregateEmailContactInteraction = {
    _count: EmailContactInteractionCountAggregateOutputType | null
    _min: EmailContactInteractionMinAggregateOutputType | null
    _max: EmailContactInteractionMaxAggregateOutputType | null
  }

  export type EmailContactInteractionMinAggregateOutputType = {
    id: string | null
    interactionType: string | null
    interactionDate: Date | null
    contactId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailContactInteractionMaxAggregateOutputType = {
    id: string | null
    interactionType: string | null
    interactionDate: Date | null
    contactId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailContactInteractionCountAggregateOutputType = {
    id: number
    interactionType: number
    interactionDate: number
    contactId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailContactInteractionMinAggregateInputType = {
    id?: true
    interactionType?: true
    interactionDate?: true
    contactId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailContactInteractionMaxAggregateInputType = {
    id?: true
    interactionType?: true
    interactionDate?: true
    contactId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailContactInteractionCountAggregateInputType = {
    id?: true
    interactionType?: true
    interactionDate?: true
    contactId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailContactInteractionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailContactInteraction to aggregate.
     */
    where?: EmailContactInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailContactInteractions to fetch.
     */
    orderBy?: EmailContactInteractionOrderByWithRelationInput | EmailContactInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailContactInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailContactInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailContactInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailContactInteractions
    **/
    _count?: true | EmailContactInteractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailContactInteractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailContactInteractionMaxAggregateInputType
  }

  export type GetEmailContactInteractionAggregateType<T extends EmailContactInteractionAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailContactInteraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailContactInteraction[P]>
      : GetScalarType<T[P], AggregateEmailContactInteraction[P]>
  }




  export type EmailContactInteractionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailContactInteractionWhereInput
    orderBy?: EmailContactInteractionOrderByWithAggregationInput | EmailContactInteractionOrderByWithAggregationInput[]
    by: EmailContactInteractionScalarFieldEnum[] | EmailContactInteractionScalarFieldEnum
    having?: EmailContactInteractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailContactInteractionCountAggregateInputType | true
    _min?: EmailContactInteractionMinAggregateInputType
    _max?: EmailContactInteractionMaxAggregateInputType
  }

  export type EmailContactInteractionGroupByOutputType = {
    id: string
    interactionType: string
    interactionDate: Date
    contactId: string
    createdAt: Date
    updatedAt: Date
    _count: EmailContactInteractionCountAggregateOutputType | null
    _min: EmailContactInteractionMinAggregateOutputType | null
    _max: EmailContactInteractionMaxAggregateOutputType | null
  }

  type GetEmailContactInteractionGroupByPayload<T extends EmailContactInteractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailContactInteractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailContactInteractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailContactInteractionGroupByOutputType[P]>
            : GetScalarType<T[P], EmailContactInteractionGroupByOutputType[P]>
        }
      >
    >


  export type EmailContactInteractionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interactionType?: boolean
    interactionDate?: boolean
    contactId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | EmailContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailContactInteraction"]>

  export type EmailContactInteractionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interactionType?: boolean
    interactionDate?: boolean
    contactId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | EmailContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailContactInteraction"]>

  export type EmailContactInteractionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interactionType?: boolean
    interactionDate?: boolean
    contactId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | EmailContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailContactInteraction"]>

  export type EmailContactInteractionSelectScalar = {
    id?: boolean
    interactionType?: boolean
    interactionDate?: boolean
    contactId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailContactInteractionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "interactionType" | "interactionDate" | "contactId" | "createdAt" | "updatedAt", ExtArgs["result"]["emailContactInteraction"]>
  export type EmailContactInteractionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | EmailContactDefaultArgs<ExtArgs>
  }
  export type EmailContactInteractionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | EmailContactDefaultArgs<ExtArgs>
  }
  export type EmailContactInteractionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | EmailContactDefaultArgs<ExtArgs>
  }

  export type $EmailContactInteractionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailContactInteraction"
    objects: {
      contact: Prisma.$EmailContactPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      interactionType: string
      interactionDate: Date
      contactId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailContactInteraction"]>
    composites: {}
  }

  type EmailContactInteractionGetPayload<S extends boolean | null | undefined | EmailContactInteractionDefaultArgs> = $Result.GetResult<Prisma.$EmailContactInteractionPayload, S>

  type EmailContactInteractionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailContactInteractionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailContactInteractionCountAggregateInputType | true
    }

  export interface EmailContactInteractionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailContactInteraction'], meta: { name: 'EmailContactInteraction' } }
    /**
     * Find zero or one EmailContactInteraction that matches the filter.
     * @param {EmailContactInteractionFindUniqueArgs} args - Arguments to find a EmailContactInteraction
     * @example
     * // Get one EmailContactInteraction
     * const emailContactInteraction = await prisma.emailContactInteraction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailContactInteractionFindUniqueArgs>(args: SelectSubset<T, EmailContactInteractionFindUniqueArgs<ExtArgs>>): Prisma__EmailContactInteractionClient<$Result.GetResult<Prisma.$EmailContactInteractionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailContactInteraction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailContactInteractionFindUniqueOrThrowArgs} args - Arguments to find a EmailContactInteraction
     * @example
     * // Get one EmailContactInteraction
     * const emailContactInteraction = await prisma.emailContactInteraction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailContactInteractionFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailContactInteractionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailContactInteractionClient<$Result.GetResult<Prisma.$EmailContactInteractionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailContactInteraction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailContactInteractionFindFirstArgs} args - Arguments to find a EmailContactInteraction
     * @example
     * // Get one EmailContactInteraction
     * const emailContactInteraction = await prisma.emailContactInteraction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailContactInteractionFindFirstArgs>(args?: SelectSubset<T, EmailContactInteractionFindFirstArgs<ExtArgs>>): Prisma__EmailContactInteractionClient<$Result.GetResult<Prisma.$EmailContactInteractionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailContactInteraction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailContactInteractionFindFirstOrThrowArgs} args - Arguments to find a EmailContactInteraction
     * @example
     * // Get one EmailContactInteraction
     * const emailContactInteraction = await prisma.emailContactInteraction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailContactInteractionFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailContactInteractionFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailContactInteractionClient<$Result.GetResult<Prisma.$EmailContactInteractionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailContactInteractions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailContactInteractionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailContactInteractions
     * const emailContactInteractions = await prisma.emailContactInteraction.findMany()
     * 
     * // Get first 10 EmailContactInteractions
     * const emailContactInteractions = await prisma.emailContactInteraction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailContactInteractionWithIdOnly = await prisma.emailContactInteraction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailContactInteractionFindManyArgs>(args?: SelectSubset<T, EmailContactInteractionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailContactInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailContactInteraction.
     * @param {EmailContactInteractionCreateArgs} args - Arguments to create a EmailContactInteraction.
     * @example
     * // Create one EmailContactInteraction
     * const EmailContactInteraction = await prisma.emailContactInteraction.create({
     *   data: {
     *     // ... data to create a EmailContactInteraction
     *   }
     * })
     * 
     */
    create<T extends EmailContactInteractionCreateArgs>(args: SelectSubset<T, EmailContactInteractionCreateArgs<ExtArgs>>): Prisma__EmailContactInteractionClient<$Result.GetResult<Prisma.$EmailContactInteractionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailContactInteractions.
     * @param {EmailContactInteractionCreateManyArgs} args - Arguments to create many EmailContactInteractions.
     * @example
     * // Create many EmailContactInteractions
     * const emailContactInteraction = await prisma.emailContactInteraction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailContactInteractionCreateManyArgs>(args?: SelectSubset<T, EmailContactInteractionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailContactInteractions and returns the data saved in the database.
     * @param {EmailContactInteractionCreateManyAndReturnArgs} args - Arguments to create many EmailContactInteractions.
     * @example
     * // Create many EmailContactInteractions
     * const emailContactInteraction = await prisma.emailContactInteraction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailContactInteractions and only return the `id`
     * const emailContactInteractionWithIdOnly = await prisma.emailContactInteraction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailContactInteractionCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailContactInteractionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailContactInteractionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailContactInteraction.
     * @param {EmailContactInteractionDeleteArgs} args - Arguments to delete one EmailContactInteraction.
     * @example
     * // Delete one EmailContactInteraction
     * const EmailContactInteraction = await prisma.emailContactInteraction.delete({
     *   where: {
     *     // ... filter to delete one EmailContactInteraction
     *   }
     * })
     * 
     */
    delete<T extends EmailContactInteractionDeleteArgs>(args: SelectSubset<T, EmailContactInteractionDeleteArgs<ExtArgs>>): Prisma__EmailContactInteractionClient<$Result.GetResult<Prisma.$EmailContactInteractionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailContactInteraction.
     * @param {EmailContactInteractionUpdateArgs} args - Arguments to update one EmailContactInteraction.
     * @example
     * // Update one EmailContactInteraction
     * const emailContactInteraction = await prisma.emailContactInteraction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailContactInteractionUpdateArgs>(args: SelectSubset<T, EmailContactInteractionUpdateArgs<ExtArgs>>): Prisma__EmailContactInteractionClient<$Result.GetResult<Prisma.$EmailContactInteractionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailContactInteractions.
     * @param {EmailContactInteractionDeleteManyArgs} args - Arguments to filter EmailContactInteractions to delete.
     * @example
     * // Delete a few EmailContactInteractions
     * const { count } = await prisma.emailContactInteraction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailContactInteractionDeleteManyArgs>(args?: SelectSubset<T, EmailContactInteractionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailContactInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailContactInteractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailContactInteractions
     * const emailContactInteraction = await prisma.emailContactInteraction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailContactInteractionUpdateManyArgs>(args: SelectSubset<T, EmailContactInteractionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailContactInteractions and returns the data updated in the database.
     * @param {EmailContactInteractionUpdateManyAndReturnArgs} args - Arguments to update many EmailContactInteractions.
     * @example
     * // Update many EmailContactInteractions
     * const emailContactInteraction = await prisma.emailContactInteraction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailContactInteractions and only return the `id`
     * const emailContactInteractionWithIdOnly = await prisma.emailContactInteraction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailContactInteractionUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailContactInteractionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailContactInteractionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailContactInteraction.
     * @param {EmailContactInteractionUpsertArgs} args - Arguments to update or create a EmailContactInteraction.
     * @example
     * // Update or create a EmailContactInteraction
     * const emailContactInteraction = await prisma.emailContactInteraction.upsert({
     *   create: {
     *     // ... data to create a EmailContactInteraction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailContactInteraction we want to update
     *   }
     * })
     */
    upsert<T extends EmailContactInteractionUpsertArgs>(args: SelectSubset<T, EmailContactInteractionUpsertArgs<ExtArgs>>): Prisma__EmailContactInteractionClient<$Result.GetResult<Prisma.$EmailContactInteractionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailContactInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailContactInteractionCountArgs} args - Arguments to filter EmailContactInteractions to count.
     * @example
     * // Count the number of EmailContactInteractions
     * const count = await prisma.emailContactInteraction.count({
     *   where: {
     *     // ... the filter for the EmailContactInteractions we want to count
     *   }
     * })
    **/
    count<T extends EmailContactInteractionCountArgs>(
      args?: Subset<T, EmailContactInteractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailContactInteractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailContactInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailContactInteractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailContactInteractionAggregateArgs>(args: Subset<T, EmailContactInteractionAggregateArgs>): Prisma.PrismaPromise<GetEmailContactInteractionAggregateType<T>>

    /**
     * Group by EmailContactInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailContactInteractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailContactInteractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailContactInteractionGroupByArgs['orderBy'] }
        : { orderBy?: EmailContactInteractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailContactInteractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailContactInteractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailContactInteraction model
   */
  readonly fields: EmailContactInteractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailContactInteraction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailContactInteractionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends EmailContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailContactDefaultArgs<ExtArgs>>): Prisma__EmailContactClient<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailContactInteraction model
   */
  interface EmailContactInteractionFieldRefs {
    readonly id: FieldRef<"EmailContactInteraction", 'String'>
    readonly interactionType: FieldRef<"EmailContactInteraction", 'String'>
    readonly interactionDate: FieldRef<"EmailContactInteraction", 'DateTime'>
    readonly contactId: FieldRef<"EmailContactInteraction", 'String'>
    readonly createdAt: FieldRef<"EmailContactInteraction", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailContactInteraction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailContactInteraction findUnique
   */
  export type EmailContactInteractionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContactInteraction
     */
    select?: EmailContactInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContactInteraction
     */
    omit?: EmailContactInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInteractionInclude<ExtArgs> | null
    /**
     * Filter, which EmailContactInteraction to fetch.
     */
    where: EmailContactInteractionWhereUniqueInput
  }

  /**
   * EmailContactInteraction findUniqueOrThrow
   */
  export type EmailContactInteractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContactInteraction
     */
    select?: EmailContactInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContactInteraction
     */
    omit?: EmailContactInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInteractionInclude<ExtArgs> | null
    /**
     * Filter, which EmailContactInteraction to fetch.
     */
    where: EmailContactInteractionWhereUniqueInput
  }

  /**
   * EmailContactInteraction findFirst
   */
  export type EmailContactInteractionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContactInteraction
     */
    select?: EmailContactInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContactInteraction
     */
    omit?: EmailContactInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInteractionInclude<ExtArgs> | null
    /**
     * Filter, which EmailContactInteraction to fetch.
     */
    where?: EmailContactInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailContactInteractions to fetch.
     */
    orderBy?: EmailContactInteractionOrderByWithRelationInput | EmailContactInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailContactInteractions.
     */
    cursor?: EmailContactInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailContactInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailContactInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailContactInteractions.
     */
    distinct?: EmailContactInteractionScalarFieldEnum | EmailContactInteractionScalarFieldEnum[]
  }

  /**
   * EmailContactInteraction findFirstOrThrow
   */
  export type EmailContactInteractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContactInteraction
     */
    select?: EmailContactInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContactInteraction
     */
    omit?: EmailContactInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInteractionInclude<ExtArgs> | null
    /**
     * Filter, which EmailContactInteraction to fetch.
     */
    where?: EmailContactInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailContactInteractions to fetch.
     */
    orderBy?: EmailContactInteractionOrderByWithRelationInput | EmailContactInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailContactInteractions.
     */
    cursor?: EmailContactInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailContactInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailContactInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailContactInteractions.
     */
    distinct?: EmailContactInteractionScalarFieldEnum | EmailContactInteractionScalarFieldEnum[]
  }

  /**
   * EmailContactInteraction findMany
   */
  export type EmailContactInteractionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContactInteraction
     */
    select?: EmailContactInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContactInteraction
     */
    omit?: EmailContactInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInteractionInclude<ExtArgs> | null
    /**
     * Filter, which EmailContactInteractions to fetch.
     */
    where?: EmailContactInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailContactInteractions to fetch.
     */
    orderBy?: EmailContactInteractionOrderByWithRelationInput | EmailContactInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailContactInteractions.
     */
    cursor?: EmailContactInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailContactInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailContactInteractions.
     */
    skip?: number
    distinct?: EmailContactInteractionScalarFieldEnum | EmailContactInteractionScalarFieldEnum[]
  }

  /**
   * EmailContactInteraction create
   */
  export type EmailContactInteractionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContactInteraction
     */
    select?: EmailContactInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContactInteraction
     */
    omit?: EmailContactInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInteractionInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailContactInteraction.
     */
    data: XOR<EmailContactInteractionCreateInput, EmailContactInteractionUncheckedCreateInput>
  }

  /**
   * EmailContactInteraction createMany
   */
  export type EmailContactInteractionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailContactInteractions.
     */
    data: EmailContactInteractionCreateManyInput | EmailContactInteractionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailContactInteraction createManyAndReturn
   */
  export type EmailContactInteractionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContactInteraction
     */
    select?: EmailContactInteractionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContactInteraction
     */
    omit?: EmailContactInteractionOmit<ExtArgs> | null
    /**
     * The data used to create many EmailContactInteractions.
     */
    data: EmailContactInteractionCreateManyInput | EmailContactInteractionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInteractionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailContactInteraction update
   */
  export type EmailContactInteractionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContactInteraction
     */
    select?: EmailContactInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContactInteraction
     */
    omit?: EmailContactInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInteractionInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailContactInteraction.
     */
    data: XOR<EmailContactInteractionUpdateInput, EmailContactInteractionUncheckedUpdateInput>
    /**
     * Choose, which EmailContactInteraction to update.
     */
    where: EmailContactInteractionWhereUniqueInput
  }

  /**
   * EmailContactInteraction updateMany
   */
  export type EmailContactInteractionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailContactInteractions.
     */
    data: XOR<EmailContactInteractionUpdateManyMutationInput, EmailContactInteractionUncheckedUpdateManyInput>
    /**
     * Filter which EmailContactInteractions to update
     */
    where?: EmailContactInteractionWhereInput
    /**
     * Limit how many EmailContactInteractions to update.
     */
    limit?: number
  }

  /**
   * EmailContactInteraction updateManyAndReturn
   */
  export type EmailContactInteractionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContactInteraction
     */
    select?: EmailContactInteractionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContactInteraction
     */
    omit?: EmailContactInteractionOmit<ExtArgs> | null
    /**
     * The data used to update EmailContactInteractions.
     */
    data: XOR<EmailContactInteractionUpdateManyMutationInput, EmailContactInteractionUncheckedUpdateManyInput>
    /**
     * Filter which EmailContactInteractions to update
     */
    where?: EmailContactInteractionWhereInput
    /**
     * Limit how many EmailContactInteractions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInteractionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailContactInteraction upsert
   */
  export type EmailContactInteractionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContactInteraction
     */
    select?: EmailContactInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContactInteraction
     */
    omit?: EmailContactInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInteractionInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailContactInteraction to update in case it exists.
     */
    where: EmailContactInteractionWhereUniqueInput
    /**
     * In case the EmailContactInteraction found by the `where` argument doesn't exist, create a new EmailContactInteraction with this data.
     */
    create: XOR<EmailContactInteractionCreateInput, EmailContactInteractionUncheckedCreateInput>
    /**
     * In case the EmailContactInteraction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailContactInteractionUpdateInput, EmailContactInteractionUncheckedUpdateInput>
  }

  /**
   * EmailContactInteraction delete
   */
  export type EmailContactInteractionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContactInteraction
     */
    select?: EmailContactInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContactInteraction
     */
    omit?: EmailContactInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInteractionInclude<ExtArgs> | null
    /**
     * Filter which EmailContactInteraction to delete.
     */
    where: EmailContactInteractionWhereUniqueInput
  }

  /**
   * EmailContactInteraction deleteMany
   */
  export type EmailContactInteractionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailContactInteractions to delete
     */
    where?: EmailContactInteractionWhereInput
    /**
     * Limit how many EmailContactInteractions to delete.
     */
    limit?: number
  }

  /**
   * EmailContactInteraction without action
   */
  export type EmailContactInteractionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailContactInteraction
     */
    select?: EmailContactInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailContactInteraction
     */
    omit?: EmailContactInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailContactInteractionInclude<ExtArgs> | null
  }


  /**
   * Model EmailSingleSend
   */

  export type AggregateEmailSingleSend = {
    _count: EmailSingleSendCountAggregateOutputType | null
    _min: EmailSingleSendMinAggregateOutputType | null
    _max: EmailSingleSendMaxAggregateOutputType | null
  }

  export type EmailSingleSendMinAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    bodyHtml: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailSingleSendMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    bodyHtml: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailSingleSendCountAggregateOutputType = {
    id: number
    name: number
    subject: number
    designData:PrismaJson.EmailDesignData
    bodyHtml: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailSingleSendMinAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    bodyHtml?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailSingleSendMaxAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    bodyHtml?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailSingleSendCountAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    designData?: true
    bodyHtml?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailSingleSendAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailSingleSend to aggregate.
     */
    where?: EmailSingleSendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSingleSends to fetch.
     */
    orderBy?: EmailSingleSendOrderByWithRelationInput | EmailSingleSendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailSingleSendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSingleSends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSingleSends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailSingleSends
    **/
    _count?: true | EmailSingleSendCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailSingleSendMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailSingleSendMaxAggregateInputType
  }

  export type GetEmailSingleSendAggregateType<T extends EmailSingleSendAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailSingleSend]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailSingleSend[P]>
      : GetScalarType<T[P], AggregateEmailSingleSend[P]>
  }




  export type EmailSingleSendGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailSingleSendWhereInput
    orderBy?: EmailSingleSendOrderByWithAggregationInput | EmailSingleSendOrderByWithAggregationInput[]
    by: EmailSingleSendScalarFieldEnum[] | EmailSingleSendScalarFieldEnum
    having?: EmailSingleSendScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailSingleSendCountAggregateInputType | true
    _min?: EmailSingleSendMinAggregateInputType
    _max?: EmailSingleSendMaxAggregateInputType
  }

  export type EmailSingleSendGroupByOutputType = {
    id: string
    name: string
    subject: string | null
    designData:PrismaJson.EmailDesignData | null
    bodyHtml: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmailSingleSendCountAggregateOutputType | null
    _min: EmailSingleSendMinAggregateOutputType | null
    _max: EmailSingleSendMaxAggregateOutputType | null
  }

  type GetEmailSingleSendGroupByPayload<T extends EmailSingleSendGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailSingleSendGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailSingleSendGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailSingleSendGroupByOutputType[P]>
            : GetScalarType<T[P], EmailSingleSendGroupByOutputType[P]>
        }
      >
    >


  export type EmailSingleSendSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    designData?: boolean
    bodyHtml?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audiences?: boolean | EmailSingleSend$audiencesArgs<ExtArgs>
    emailSingleSendLogs?: boolean | EmailSingleSend$emailSingleSendLogsArgs<ExtArgs>
    _count?: boolean | EmailSingleSendCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailSingleSend"]>

  export type EmailSingleSendSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    designData?: boolean
    bodyHtml?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailSingleSend"]>

  export type EmailSingleSendSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    designData?: boolean
    bodyHtml?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailSingleSend"]>

  export type EmailSingleSendSelectScalar = {
    id?: boolean
    name?: boolean
    subject?: boolean
    designData?: boolean
    bodyHtml?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailSingleSendOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "subject" | "designData" | "bodyHtml" | "createdAt" | "updatedAt", ExtArgs["result"]["emailSingleSend"]>
  export type EmailSingleSendInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audiences?: boolean | EmailSingleSend$audiencesArgs<ExtArgs>
    emailSingleSendLogs?: boolean | EmailSingleSend$emailSingleSendLogsArgs<ExtArgs>
    _count?: boolean | EmailSingleSendCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmailSingleSendIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EmailSingleSendIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EmailSingleSendPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailSingleSend"
    objects: {
      audiences: Prisma.$EmailAudiencePayload<ExtArgs>[]
      emailSingleSendLogs: Prisma.$EmailSingleSendLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      subject: string | null
      /**
       * [EmailDesignData]
       */
      designData:PrismaJson.EmailDesignData | null
      bodyHtml: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailSingleSend"]>
    composites: {}
  }

  type EmailSingleSendGetPayload<S extends boolean | null | undefined | EmailSingleSendDefaultArgs> = $Result.GetResult<Prisma.$EmailSingleSendPayload, S>

  type EmailSingleSendCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailSingleSendFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailSingleSendCountAggregateInputType | true
    }

  export interface EmailSingleSendDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailSingleSend'], meta: { name: 'EmailSingleSend' } }
    /**
     * Find zero or one EmailSingleSend that matches the filter.
     * @param {EmailSingleSendFindUniqueArgs} args - Arguments to find a EmailSingleSend
     * @example
     * // Get one EmailSingleSend
     * const emailSingleSend = await prisma.emailSingleSend.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailSingleSendFindUniqueArgs>(args: SelectSubset<T, EmailSingleSendFindUniqueArgs<ExtArgs>>): Prisma__EmailSingleSendClient<$Result.GetResult<Prisma.$EmailSingleSendPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailSingleSend that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailSingleSendFindUniqueOrThrowArgs} args - Arguments to find a EmailSingleSend
     * @example
     * // Get one EmailSingleSend
     * const emailSingleSend = await prisma.emailSingleSend.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailSingleSendFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailSingleSendFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailSingleSendClient<$Result.GetResult<Prisma.$EmailSingleSendPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailSingleSend that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSingleSendFindFirstArgs} args - Arguments to find a EmailSingleSend
     * @example
     * // Get one EmailSingleSend
     * const emailSingleSend = await prisma.emailSingleSend.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailSingleSendFindFirstArgs>(args?: SelectSubset<T, EmailSingleSendFindFirstArgs<ExtArgs>>): Prisma__EmailSingleSendClient<$Result.GetResult<Prisma.$EmailSingleSendPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailSingleSend that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSingleSendFindFirstOrThrowArgs} args - Arguments to find a EmailSingleSend
     * @example
     * // Get one EmailSingleSend
     * const emailSingleSend = await prisma.emailSingleSend.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailSingleSendFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailSingleSendFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailSingleSendClient<$Result.GetResult<Prisma.$EmailSingleSendPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailSingleSends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSingleSendFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailSingleSends
     * const emailSingleSends = await prisma.emailSingleSend.findMany()
     * 
     * // Get first 10 EmailSingleSends
     * const emailSingleSends = await prisma.emailSingleSend.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailSingleSendWithIdOnly = await prisma.emailSingleSend.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailSingleSendFindManyArgs>(args?: SelectSubset<T, EmailSingleSendFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSingleSendPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailSingleSend.
     * @param {EmailSingleSendCreateArgs} args - Arguments to create a EmailSingleSend.
     * @example
     * // Create one EmailSingleSend
     * const EmailSingleSend = await prisma.emailSingleSend.create({
     *   data: {
     *     // ... data to create a EmailSingleSend
     *   }
     * })
     * 
     */
    create<T extends EmailSingleSendCreateArgs>(args: SelectSubset<T, EmailSingleSendCreateArgs<ExtArgs>>): Prisma__EmailSingleSendClient<$Result.GetResult<Prisma.$EmailSingleSendPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailSingleSends.
     * @param {EmailSingleSendCreateManyArgs} args - Arguments to create many EmailSingleSends.
     * @example
     * // Create many EmailSingleSends
     * const emailSingleSend = await prisma.emailSingleSend.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailSingleSendCreateManyArgs>(args?: SelectSubset<T, EmailSingleSendCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailSingleSends and returns the data saved in the database.
     * @param {EmailSingleSendCreateManyAndReturnArgs} args - Arguments to create many EmailSingleSends.
     * @example
     * // Create many EmailSingleSends
     * const emailSingleSend = await prisma.emailSingleSend.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailSingleSends and only return the `id`
     * const emailSingleSendWithIdOnly = await prisma.emailSingleSend.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailSingleSendCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailSingleSendCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSingleSendPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailSingleSend.
     * @param {EmailSingleSendDeleteArgs} args - Arguments to delete one EmailSingleSend.
     * @example
     * // Delete one EmailSingleSend
     * const EmailSingleSend = await prisma.emailSingleSend.delete({
     *   where: {
     *     // ... filter to delete one EmailSingleSend
     *   }
     * })
     * 
     */
    delete<T extends EmailSingleSendDeleteArgs>(args: SelectSubset<T, EmailSingleSendDeleteArgs<ExtArgs>>): Prisma__EmailSingleSendClient<$Result.GetResult<Prisma.$EmailSingleSendPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailSingleSend.
     * @param {EmailSingleSendUpdateArgs} args - Arguments to update one EmailSingleSend.
     * @example
     * // Update one EmailSingleSend
     * const emailSingleSend = await prisma.emailSingleSend.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailSingleSendUpdateArgs>(args: SelectSubset<T, EmailSingleSendUpdateArgs<ExtArgs>>): Prisma__EmailSingleSendClient<$Result.GetResult<Prisma.$EmailSingleSendPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailSingleSends.
     * @param {EmailSingleSendDeleteManyArgs} args - Arguments to filter EmailSingleSends to delete.
     * @example
     * // Delete a few EmailSingleSends
     * const { count } = await prisma.emailSingleSend.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailSingleSendDeleteManyArgs>(args?: SelectSubset<T, EmailSingleSendDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailSingleSends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSingleSendUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailSingleSends
     * const emailSingleSend = await prisma.emailSingleSend.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailSingleSendUpdateManyArgs>(args: SelectSubset<T, EmailSingleSendUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailSingleSends and returns the data updated in the database.
     * @param {EmailSingleSendUpdateManyAndReturnArgs} args - Arguments to update many EmailSingleSends.
     * @example
     * // Update many EmailSingleSends
     * const emailSingleSend = await prisma.emailSingleSend.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailSingleSends and only return the `id`
     * const emailSingleSendWithIdOnly = await prisma.emailSingleSend.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailSingleSendUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailSingleSendUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSingleSendPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailSingleSend.
     * @param {EmailSingleSendUpsertArgs} args - Arguments to update or create a EmailSingleSend.
     * @example
     * // Update or create a EmailSingleSend
     * const emailSingleSend = await prisma.emailSingleSend.upsert({
     *   create: {
     *     // ... data to create a EmailSingleSend
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailSingleSend we want to update
     *   }
     * })
     */
    upsert<T extends EmailSingleSendUpsertArgs>(args: SelectSubset<T, EmailSingleSendUpsertArgs<ExtArgs>>): Prisma__EmailSingleSendClient<$Result.GetResult<Prisma.$EmailSingleSendPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailSingleSends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSingleSendCountArgs} args - Arguments to filter EmailSingleSends to count.
     * @example
     * // Count the number of EmailSingleSends
     * const count = await prisma.emailSingleSend.count({
     *   where: {
     *     // ... the filter for the EmailSingleSends we want to count
     *   }
     * })
    **/
    count<T extends EmailSingleSendCountArgs>(
      args?: Subset<T, EmailSingleSendCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailSingleSendCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailSingleSend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSingleSendAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailSingleSendAggregateArgs>(args: Subset<T, EmailSingleSendAggregateArgs>): Prisma.PrismaPromise<GetEmailSingleSendAggregateType<T>>

    /**
     * Group by EmailSingleSend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSingleSendGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailSingleSendGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailSingleSendGroupByArgs['orderBy'] }
        : { orderBy?: EmailSingleSendGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailSingleSendGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailSingleSendGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailSingleSend model
   */
  readonly fields: EmailSingleSendFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailSingleSend.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailSingleSendClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    audiences<T extends EmailSingleSend$audiencesArgs<ExtArgs> = {}>(args?: Subset<T, EmailSingleSend$audiencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAudiencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailSingleSendLogs<T extends EmailSingleSend$emailSingleSendLogsArgs<ExtArgs> = {}>(args?: Subset<T, EmailSingleSend$emailSingleSendLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSingleSendLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailSingleSend model
   */
  interface EmailSingleSendFieldRefs {
    readonly id: FieldRef<"EmailSingleSend", 'String'>
    readonly name: FieldRef<"EmailSingleSend", 'String'>
    readonly subject: FieldRef<"EmailSingleSend", 'String'>
    readonly designData: FieldRef<"EmailSingleSend", 'Json'>
    readonly bodyHtml: FieldRef<"EmailSingleSend", 'String'>
    readonly createdAt: FieldRef<"EmailSingleSend", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailSingleSend", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailSingleSend findUnique
   */
  export type EmailSingleSendFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSend
     */
    select?: EmailSingleSendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSend
     */
    omit?: EmailSingleSendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendInclude<ExtArgs> | null
    /**
     * Filter, which EmailSingleSend to fetch.
     */
    where: EmailSingleSendWhereUniqueInput
  }

  /**
   * EmailSingleSend findUniqueOrThrow
   */
  export type EmailSingleSendFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSend
     */
    select?: EmailSingleSendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSend
     */
    omit?: EmailSingleSendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendInclude<ExtArgs> | null
    /**
     * Filter, which EmailSingleSend to fetch.
     */
    where: EmailSingleSendWhereUniqueInput
  }

  /**
   * EmailSingleSend findFirst
   */
  export type EmailSingleSendFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSend
     */
    select?: EmailSingleSendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSend
     */
    omit?: EmailSingleSendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendInclude<ExtArgs> | null
    /**
     * Filter, which EmailSingleSend to fetch.
     */
    where?: EmailSingleSendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSingleSends to fetch.
     */
    orderBy?: EmailSingleSendOrderByWithRelationInput | EmailSingleSendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailSingleSends.
     */
    cursor?: EmailSingleSendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSingleSends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSingleSends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailSingleSends.
     */
    distinct?: EmailSingleSendScalarFieldEnum | EmailSingleSendScalarFieldEnum[]
  }

  /**
   * EmailSingleSend findFirstOrThrow
   */
  export type EmailSingleSendFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSend
     */
    select?: EmailSingleSendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSend
     */
    omit?: EmailSingleSendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendInclude<ExtArgs> | null
    /**
     * Filter, which EmailSingleSend to fetch.
     */
    where?: EmailSingleSendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSingleSends to fetch.
     */
    orderBy?: EmailSingleSendOrderByWithRelationInput | EmailSingleSendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailSingleSends.
     */
    cursor?: EmailSingleSendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSingleSends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSingleSends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailSingleSends.
     */
    distinct?: EmailSingleSendScalarFieldEnum | EmailSingleSendScalarFieldEnum[]
  }

  /**
   * EmailSingleSend findMany
   */
  export type EmailSingleSendFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSend
     */
    select?: EmailSingleSendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSend
     */
    omit?: EmailSingleSendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendInclude<ExtArgs> | null
    /**
     * Filter, which EmailSingleSends to fetch.
     */
    where?: EmailSingleSendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSingleSends to fetch.
     */
    orderBy?: EmailSingleSendOrderByWithRelationInput | EmailSingleSendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailSingleSends.
     */
    cursor?: EmailSingleSendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSingleSends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSingleSends.
     */
    skip?: number
    distinct?: EmailSingleSendScalarFieldEnum | EmailSingleSendScalarFieldEnum[]
  }

  /**
   * EmailSingleSend create
   */
  export type EmailSingleSendCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSend
     */
    select?: EmailSingleSendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSend
     */
    omit?: EmailSingleSendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailSingleSend.
     */
    data: XOR<EmailSingleSendCreateInput, EmailSingleSendUncheckedCreateInput>
  }

  /**
   * EmailSingleSend createMany
   */
  export type EmailSingleSendCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailSingleSends.
     */
    data: EmailSingleSendCreateManyInput | EmailSingleSendCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailSingleSend createManyAndReturn
   */
  export type EmailSingleSendCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSend
     */
    select?: EmailSingleSendSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSend
     */
    omit?: EmailSingleSendOmit<ExtArgs> | null
    /**
     * The data used to create many EmailSingleSends.
     */
    data: EmailSingleSendCreateManyInput | EmailSingleSendCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailSingleSend update
   */
  export type EmailSingleSendUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSend
     */
    select?: EmailSingleSendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSend
     */
    omit?: EmailSingleSendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailSingleSend.
     */
    data: XOR<EmailSingleSendUpdateInput, EmailSingleSendUncheckedUpdateInput>
    /**
     * Choose, which EmailSingleSend to update.
     */
    where: EmailSingleSendWhereUniqueInput
  }

  /**
   * EmailSingleSend updateMany
   */
  export type EmailSingleSendUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailSingleSends.
     */
    data: XOR<EmailSingleSendUpdateManyMutationInput, EmailSingleSendUncheckedUpdateManyInput>
    /**
     * Filter which EmailSingleSends to update
     */
    where?: EmailSingleSendWhereInput
    /**
     * Limit how many EmailSingleSends to update.
     */
    limit?: number
  }

  /**
   * EmailSingleSend updateManyAndReturn
   */
  export type EmailSingleSendUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSend
     */
    select?: EmailSingleSendSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSend
     */
    omit?: EmailSingleSendOmit<ExtArgs> | null
    /**
     * The data used to update EmailSingleSends.
     */
    data: XOR<EmailSingleSendUpdateManyMutationInput, EmailSingleSendUncheckedUpdateManyInput>
    /**
     * Filter which EmailSingleSends to update
     */
    where?: EmailSingleSendWhereInput
    /**
     * Limit how many EmailSingleSends to update.
     */
    limit?: number
  }

  /**
   * EmailSingleSend upsert
   */
  export type EmailSingleSendUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSend
     */
    select?: EmailSingleSendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSend
     */
    omit?: EmailSingleSendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailSingleSend to update in case it exists.
     */
    where: EmailSingleSendWhereUniqueInput
    /**
     * In case the EmailSingleSend found by the `where` argument doesn't exist, create a new EmailSingleSend with this data.
     */
    create: XOR<EmailSingleSendCreateInput, EmailSingleSendUncheckedCreateInput>
    /**
     * In case the EmailSingleSend was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailSingleSendUpdateInput, EmailSingleSendUncheckedUpdateInput>
  }

  /**
   * EmailSingleSend delete
   */
  export type EmailSingleSendDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSend
     */
    select?: EmailSingleSendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSend
     */
    omit?: EmailSingleSendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendInclude<ExtArgs> | null
    /**
     * Filter which EmailSingleSend to delete.
     */
    where: EmailSingleSendWhereUniqueInput
  }

  /**
   * EmailSingleSend deleteMany
   */
  export type EmailSingleSendDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailSingleSends to delete
     */
    where?: EmailSingleSendWhereInput
    /**
     * Limit how many EmailSingleSends to delete.
     */
    limit?: number
  }

  /**
   * EmailSingleSend.audiences
   */
  export type EmailSingleSend$audiencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAudience
     */
    select?: EmailAudienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAudience
     */
    omit?: EmailAudienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAudienceInclude<ExtArgs> | null
    where?: EmailAudienceWhereInput
    orderBy?: EmailAudienceOrderByWithRelationInput | EmailAudienceOrderByWithRelationInput[]
    cursor?: EmailAudienceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailAudienceScalarFieldEnum | EmailAudienceScalarFieldEnum[]
  }

  /**
   * EmailSingleSend.emailSingleSendLogs
   */
  export type EmailSingleSend$emailSingleSendLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSendLog
     */
    select?: EmailSingleSendLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSendLog
     */
    omit?: EmailSingleSendLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendLogInclude<ExtArgs> | null
    where?: EmailSingleSendLogWhereInput
    orderBy?: EmailSingleSendLogOrderByWithRelationInput | EmailSingleSendLogOrderByWithRelationInput[]
    cursor?: EmailSingleSendLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailSingleSendLogScalarFieldEnum | EmailSingleSendLogScalarFieldEnum[]
  }

  /**
   * EmailSingleSend without action
   */
  export type EmailSingleSendDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSend
     */
    select?: EmailSingleSendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSend
     */
    omit?: EmailSingleSendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendInclude<ExtArgs> | null
  }


  /**
   * Model EmailSubscriptionToken
   */

  export type AggregateEmailSubscriptionToken = {
    _count: EmailSubscriptionTokenCountAggregateOutputType | null
    _min: EmailSubscriptionTokenMinAggregateOutputType | null
    _max: EmailSubscriptionTokenMaxAggregateOutputType | null
  }

  export type EmailSubscriptionTokenMinAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailSubscriptionTokenMaxAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailSubscriptionTokenCountAggregateOutputType = {
    id: number
    email: number
    token: number
    expires: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailSubscriptionTokenMinAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailSubscriptionTokenMaxAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailSubscriptionTokenCountAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailSubscriptionTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailSubscriptionToken to aggregate.
     */
    where?: EmailSubscriptionTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSubscriptionTokens to fetch.
     */
    orderBy?: EmailSubscriptionTokenOrderByWithRelationInput | EmailSubscriptionTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailSubscriptionTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSubscriptionTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSubscriptionTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailSubscriptionTokens
    **/
    _count?: true | EmailSubscriptionTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailSubscriptionTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailSubscriptionTokenMaxAggregateInputType
  }

  export type GetEmailSubscriptionTokenAggregateType<T extends EmailSubscriptionTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailSubscriptionToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailSubscriptionToken[P]>
      : GetScalarType<T[P], AggregateEmailSubscriptionToken[P]>
  }




  export type EmailSubscriptionTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailSubscriptionTokenWhereInput
    orderBy?: EmailSubscriptionTokenOrderByWithAggregationInput | EmailSubscriptionTokenOrderByWithAggregationInput[]
    by: EmailSubscriptionTokenScalarFieldEnum[] | EmailSubscriptionTokenScalarFieldEnum
    having?: EmailSubscriptionTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailSubscriptionTokenCountAggregateInputType | true
    _min?: EmailSubscriptionTokenMinAggregateInputType
    _max?: EmailSubscriptionTokenMaxAggregateInputType
  }

  export type EmailSubscriptionTokenGroupByOutputType = {
    id: string
    email: string
    token: string
    expires: Date
    createdAt: Date
    updatedAt: Date
    _count: EmailSubscriptionTokenCountAggregateOutputType | null
    _min: EmailSubscriptionTokenMinAggregateOutputType | null
    _max: EmailSubscriptionTokenMaxAggregateOutputType | null
  }

  type GetEmailSubscriptionTokenGroupByPayload<T extends EmailSubscriptionTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailSubscriptionTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailSubscriptionTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailSubscriptionTokenGroupByOutputType[P]>
            : GetScalarType<T[P], EmailSubscriptionTokenGroupByOutputType[P]>
        }
      >
    >


  export type EmailSubscriptionTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailSubscriptionToken"]>

  export type EmailSubscriptionTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailSubscriptionToken"]>

  export type EmailSubscriptionTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailSubscriptionToken"]>

  export type EmailSubscriptionTokenSelectScalar = {
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailSubscriptionTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "token" | "expires" | "createdAt" | "updatedAt", ExtArgs["result"]["emailSubscriptionToken"]>

  export type $EmailSubscriptionTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailSubscriptionToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      token: string
      expires: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailSubscriptionToken"]>
    composites: {}
  }

  type EmailSubscriptionTokenGetPayload<S extends boolean | null | undefined | EmailSubscriptionTokenDefaultArgs> = $Result.GetResult<Prisma.$EmailSubscriptionTokenPayload, S>

  type EmailSubscriptionTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailSubscriptionTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailSubscriptionTokenCountAggregateInputType | true
    }

  export interface EmailSubscriptionTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailSubscriptionToken'], meta: { name: 'EmailSubscriptionToken' } }
    /**
     * Find zero or one EmailSubscriptionToken that matches the filter.
     * @param {EmailSubscriptionTokenFindUniqueArgs} args - Arguments to find a EmailSubscriptionToken
     * @example
     * // Get one EmailSubscriptionToken
     * const emailSubscriptionToken = await prisma.emailSubscriptionToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailSubscriptionTokenFindUniqueArgs>(args: SelectSubset<T, EmailSubscriptionTokenFindUniqueArgs<ExtArgs>>): Prisma__EmailSubscriptionTokenClient<$Result.GetResult<Prisma.$EmailSubscriptionTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailSubscriptionToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailSubscriptionTokenFindUniqueOrThrowArgs} args - Arguments to find a EmailSubscriptionToken
     * @example
     * // Get one EmailSubscriptionToken
     * const emailSubscriptionToken = await prisma.emailSubscriptionToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailSubscriptionTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailSubscriptionTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailSubscriptionTokenClient<$Result.GetResult<Prisma.$EmailSubscriptionTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailSubscriptionToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSubscriptionTokenFindFirstArgs} args - Arguments to find a EmailSubscriptionToken
     * @example
     * // Get one EmailSubscriptionToken
     * const emailSubscriptionToken = await prisma.emailSubscriptionToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailSubscriptionTokenFindFirstArgs>(args?: SelectSubset<T, EmailSubscriptionTokenFindFirstArgs<ExtArgs>>): Prisma__EmailSubscriptionTokenClient<$Result.GetResult<Prisma.$EmailSubscriptionTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailSubscriptionToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSubscriptionTokenFindFirstOrThrowArgs} args - Arguments to find a EmailSubscriptionToken
     * @example
     * // Get one EmailSubscriptionToken
     * const emailSubscriptionToken = await prisma.emailSubscriptionToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailSubscriptionTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailSubscriptionTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailSubscriptionTokenClient<$Result.GetResult<Prisma.$EmailSubscriptionTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailSubscriptionTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSubscriptionTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailSubscriptionTokens
     * const emailSubscriptionTokens = await prisma.emailSubscriptionToken.findMany()
     * 
     * // Get first 10 EmailSubscriptionTokens
     * const emailSubscriptionTokens = await prisma.emailSubscriptionToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailSubscriptionTokenWithIdOnly = await prisma.emailSubscriptionToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailSubscriptionTokenFindManyArgs>(args?: SelectSubset<T, EmailSubscriptionTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSubscriptionTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailSubscriptionToken.
     * @param {EmailSubscriptionTokenCreateArgs} args - Arguments to create a EmailSubscriptionToken.
     * @example
     * // Create one EmailSubscriptionToken
     * const EmailSubscriptionToken = await prisma.emailSubscriptionToken.create({
     *   data: {
     *     // ... data to create a EmailSubscriptionToken
     *   }
     * })
     * 
     */
    create<T extends EmailSubscriptionTokenCreateArgs>(args: SelectSubset<T, EmailSubscriptionTokenCreateArgs<ExtArgs>>): Prisma__EmailSubscriptionTokenClient<$Result.GetResult<Prisma.$EmailSubscriptionTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailSubscriptionTokens.
     * @param {EmailSubscriptionTokenCreateManyArgs} args - Arguments to create many EmailSubscriptionTokens.
     * @example
     * // Create many EmailSubscriptionTokens
     * const emailSubscriptionToken = await prisma.emailSubscriptionToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailSubscriptionTokenCreateManyArgs>(args?: SelectSubset<T, EmailSubscriptionTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailSubscriptionTokens and returns the data saved in the database.
     * @param {EmailSubscriptionTokenCreateManyAndReturnArgs} args - Arguments to create many EmailSubscriptionTokens.
     * @example
     * // Create many EmailSubscriptionTokens
     * const emailSubscriptionToken = await prisma.emailSubscriptionToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailSubscriptionTokens and only return the `id`
     * const emailSubscriptionTokenWithIdOnly = await prisma.emailSubscriptionToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailSubscriptionTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailSubscriptionTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSubscriptionTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailSubscriptionToken.
     * @param {EmailSubscriptionTokenDeleteArgs} args - Arguments to delete one EmailSubscriptionToken.
     * @example
     * // Delete one EmailSubscriptionToken
     * const EmailSubscriptionToken = await prisma.emailSubscriptionToken.delete({
     *   where: {
     *     // ... filter to delete one EmailSubscriptionToken
     *   }
     * })
     * 
     */
    delete<T extends EmailSubscriptionTokenDeleteArgs>(args: SelectSubset<T, EmailSubscriptionTokenDeleteArgs<ExtArgs>>): Prisma__EmailSubscriptionTokenClient<$Result.GetResult<Prisma.$EmailSubscriptionTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailSubscriptionToken.
     * @param {EmailSubscriptionTokenUpdateArgs} args - Arguments to update one EmailSubscriptionToken.
     * @example
     * // Update one EmailSubscriptionToken
     * const emailSubscriptionToken = await prisma.emailSubscriptionToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailSubscriptionTokenUpdateArgs>(args: SelectSubset<T, EmailSubscriptionTokenUpdateArgs<ExtArgs>>): Prisma__EmailSubscriptionTokenClient<$Result.GetResult<Prisma.$EmailSubscriptionTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailSubscriptionTokens.
     * @param {EmailSubscriptionTokenDeleteManyArgs} args - Arguments to filter EmailSubscriptionTokens to delete.
     * @example
     * // Delete a few EmailSubscriptionTokens
     * const { count } = await prisma.emailSubscriptionToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailSubscriptionTokenDeleteManyArgs>(args?: SelectSubset<T, EmailSubscriptionTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailSubscriptionTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSubscriptionTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailSubscriptionTokens
     * const emailSubscriptionToken = await prisma.emailSubscriptionToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailSubscriptionTokenUpdateManyArgs>(args: SelectSubset<T, EmailSubscriptionTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailSubscriptionTokens and returns the data updated in the database.
     * @param {EmailSubscriptionTokenUpdateManyAndReturnArgs} args - Arguments to update many EmailSubscriptionTokens.
     * @example
     * // Update many EmailSubscriptionTokens
     * const emailSubscriptionToken = await prisma.emailSubscriptionToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailSubscriptionTokens and only return the `id`
     * const emailSubscriptionTokenWithIdOnly = await prisma.emailSubscriptionToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailSubscriptionTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailSubscriptionTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSubscriptionTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailSubscriptionToken.
     * @param {EmailSubscriptionTokenUpsertArgs} args - Arguments to update or create a EmailSubscriptionToken.
     * @example
     * // Update or create a EmailSubscriptionToken
     * const emailSubscriptionToken = await prisma.emailSubscriptionToken.upsert({
     *   create: {
     *     // ... data to create a EmailSubscriptionToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailSubscriptionToken we want to update
     *   }
     * })
     */
    upsert<T extends EmailSubscriptionTokenUpsertArgs>(args: SelectSubset<T, EmailSubscriptionTokenUpsertArgs<ExtArgs>>): Prisma__EmailSubscriptionTokenClient<$Result.GetResult<Prisma.$EmailSubscriptionTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailSubscriptionTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSubscriptionTokenCountArgs} args - Arguments to filter EmailSubscriptionTokens to count.
     * @example
     * // Count the number of EmailSubscriptionTokens
     * const count = await prisma.emailSubscriptionToken.count({
     *   where: {
     *     // ... the filter for the EmailSubscriptionTokens we want to count
     *   }
     * })
    **/
    count<T extends EmailSubscriptionTokenCountArgs>(
      args?: Subset<T, EmailSubscriptionTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailSubscriptionTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailSubscriptionToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSubscriptionTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailSubscriptionTokenAggregateArgs>(args: Subset<T, EmailSubscriptionTokenAggregateArgs>): Prisma.PrismaPromise<GetEmailSubscriptionTokenAggregateType<T>>

    /**
     * Group by EmailSubscriptionToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSubscriptionTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailSubscriptionTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailSubscriptionTokenGroupByArgs['orderBy'] }
        : { orderBy?: EmailSubscriptionTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailSubscriptionTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailSubscriptionTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailSubscriptionToken model
   */
  readonly fields: EmailSubscriptionTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailSubscriptionToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailSubscriptionTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailSubscriptionToken model
   */
  interface EmailSubscriptionTokenFieldRefs {
    readonly id: FieldRef<"EmailSubscriptionToken", 'String'>
    readonly email: FieldRef<"EmailSubscriptionToken", 'String'>
    readonly token: FieldRef<"EmailSubscriptionToken", 'String'>
    readonly expires: FieldRef<"EmailSubscriptionToken", 'DateTime'>
    readonly createdAt: FieldRef<"EmailSubscriptionToken", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailSubscriptionToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailSubscriptionToken findUnique
   */
  export type EmailSubscriptionTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSubscriptionToken
     */
    select?: EmailSubscriptionTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSubscriptionToken
     */
    omit?: EmailSubscriptionTokenOmit<ExtArgs> | null
    /**
     * Filter, which EmailSubscriptionToken to fetch.
     */
    where: EmailSubscriptionTokenWhereUniqueInput
  }

  /**
   * EmailSubscriptionToken findUniqueOrThrow
   */
  export type EmailSubscriptionTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSubscriptionToken
     */
    select?: EmailSubscriptionTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSubscriptionToken
     */
    omit?: EmailSubscriptionTokenOmit<ExtArgs> | null
    /**
     * Filter, which EmailSubscriptionToken to fetch.
     */
    where: EmailSubscriptionTokenWhereUniqueInput
  }

  /**
   * EmailSubscriptionToken findFirst
   */
  export type EmailSubscriptionTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSubscriptionToken
     */
    select?: EmailSubscriptionTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSubscriptionToken
     */
    omit?: EmailSubscriptionTokenOmit<ExtArgs> | null
    /**
     * Filter, which EmailSubscriptionToken to fetch.
     */
    where?: EmailSubscriptionTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSubscriptionTokens to fetch.
     */
    orderBy?: EmailSubscriptionTokenOrderByWithRelationInput | EmailSubscriptionTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailSubscriptionTokens.
     */
    cursor?: EmailSubscriptionTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSubscriptionTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSubscriptionTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailSubscriptionTokens.
     */
    distinct?: EmailSubscriptionTokenScalarFieldEnum | EmailSubscriptionTokenScalarFieldEnum[]
  }

  /**
   * EmailSubscriptionToken findFirstOrThrow
   */
  export type EmailSubscriptionTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSubscriptionToken
     */
    select?: EmailSubscriptionTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSubscriptionToken
     */
    omit?: EmailSubscriptionTokenOmit<ExtArgs> | null
    /**
     * Filter, which EmailSubscriptionToken to fetch.
     */
    where?: EmailSubscriptionTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSubscriptionTokens to fetch.
     */
    orderBy?: EmailSubscriptionTokenOrderByWithRelationInput | EmailSubscriptionTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailSubscriptionTokens.
     */
    cursor?: EmailSubscriptionTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSubscriptionTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSubscriptionTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailSubscriptionTokens.
     */
    distinct?: EmailSubscriptionTokenScalarFieldEnum | EmailSubscriptionTokenScalarFieldEnum[]
  }

  /**
   * EmailSubscriptionToken findMany
   */
  export type EmailSubscriptionTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSubscriptionToken
     */
    select?: EmailSubscriptionTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSubscriptionToken
     */
    omit?: EmailSubscriptionTokenOmit<ExtArgs> | null
    /**
     * Filter, which EmailSubscriptionTokens to fetch.
     */
    where?: EmailSubscriptionTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSubscriptionTokens to fetch.
     */
    orderBy?: EmailSubscriptionTokenOrderByWithRelationInput | EmailSubscriptionTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailSubscriptionTokens.
     */
    cursor?: EmailSubscriptionTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSubscriptionTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSubscriptionTokens.
     */
    skip?: number
    distinct?: EmailSubscriptionTokenScalarFieldEnum | EmailSubscriptionTokenScalarFieldEnum[]
  }

  /**
   * EmailSubscriptionToken create
   */
  export type EmailSubscriptionTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSubscriptionToken
     */
    select?: EmailSubscriptionTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSubscriptionToken
     */
    omit?: EmailSubscriptionTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a EmailSubscriptionToken.
     */
    data: XOR<EmailSubscriptionTokenCreateInput, EmailSubscriptionTokenUncheckedCreateInput>
  }

  /**
   * EmailSubscriptionToken createMany
   */
  export type EmailSubscriptionTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailSubscriptionTokens.
     */
    data: EmailSubscriptionTokenCreateManyInput | EmailSubscriptionTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailSubscriptionToken createManyAndReturn
   */
  export type EmailSubscriptionTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSubscriptionToken
     */
    select?: EmailSubscriptionTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSubscriptionToken
     */
    omit?: EmailSubscriptionTokenOmit<ExtArgs> | null
    /**
     * The data used to create many EmailSubscriptionTokens.
     */
    data: EmailSubscriptionTokenCreateManyInput | EmailSubscriptionTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailSubscriptionToken update
   */
  export type EmailSubscriptionTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSubscriptionToken
     */
    select?: EmailSubscriptionTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSubscriptionToken
     */
    omit?: EmailSubscriptionTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a EmailSubscriptionToken.
     */
    data: XOR<EmailSubscriptionTokenUpdateInput, EmailSubscriptionTokenUncheckedUpdateInput>
    /**
     * Choose, which EmailSubscriptionToken to update.
     */
    where: EmailSubscriptionTokenWhereUniqueInput
  }

  /**
   * EmailSubscriptionToken updateMany
   */
  export type EmailSubscriptionTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailSubscriptionTokens.
     */
    data: XOR<EmailSubscriptionTokenUpdateManyMutationInput, EmailSubscriptionTokenUncheckedUpdateManyInput>
    /**
     * Filter which EmailSubscriptionTokens to update
     */
    where?: EmailSubscriptionTokenWhereInput
    /**
     * Limit how many EmailSubscriptionTokens to update.
     */
    limit?: number
  }

  /**
   * EmailSubscriptionToken updateManyAndReturn
   */
  export type EmailSubscriptionTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSubscriptionToken
     */
    select?: EmailSubscriptionTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSubscriptionToken
     */
    omit?: EmailSubscriptionTokenOmit<ExtArgs> | null
    /**
     * The data used to update EmailSubscriptionTokens.
     */
    data: XOR<EmailSubscriptionTokenUpdateManyMutationInput, EmailSubscriptionTokenUncheckedUpdateManyInput>
    /**
     * Filter which EmailSubscriptionTokens to update
     */
    where?: EmailSubscriptionTokenWhereInput
    /**
     * Limit how many EmailSubscriptionTokens to update.
     */
    limit?: number
  }

  /**
   * EmailSubscriptionToken upsert
   */
  export type EmailSubscriptionTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSubscriptionToken
     */
    select?: EmailSubscriptionTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSubscriptionToken
     */
    omit?: EmailSubscriptionTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the EmailSubscriptionToken to update in case it exists.
     */
    where: EmailSubscriptionTokenWhereUniqueInput
    /**
     * In case the EmailSubscriptionToken found by the `where` argument doesn't exist, create a new EmailSubscriptionToken with this data.
     */
    create: XOR<EmailSubscriptionTokenCreateInput, EmailSubscriptionTokenUncheckedCreateInput>
    /**
     * In case the EmailSubscriptionToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailSubscriptionTokenUpdateInput, EmailSubscriptionTokenUncheckedUpdateInput>
  }

  /**
   * EmailSubscriptionToken delete
   */
  export type EmailSubscriptionTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSubscriptionToken
     */
    select?: EmailSubscriptionTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSubscriptionToken
     */
    omit?: EmailSubscriptionTokenOmit<ExtArgs> | null
    /**
     * Filter which EmailSubscriptionToken to delete.
     */
    where: EmailSubscriptionTokenWhereUniqueInput
  }

  /**
   * EmailSubscriptionToken deleteMany
   */
  export type EmailSubscriptionTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailSubscriptionTokens to delete
     */
    where?: EmailSubscriptionTokenWhereInput
    /**
     * Limit how many EmailSubscriptionTokens to delete.
     */
    limit?: number
  }

  /**
   * EmailSubscriptionToken without action
   */
  export type EmailSubscriptionTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSubscriptionToken
     */
    select?: EmailSubscriptionTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSubscriptionToken
     */
    omit?: EmailSubscriptionTokenOmit<ExtArgs> | null
  }


  /**
   * Model EmailSendLog
   */

  export type AggregateEmailSendLog = {
    _count: EmailSendLogCountAggregateOutputType | null
    _min: EmailSendLogMinAggregateOutputType | null
    _max: EmailSendLogMaxAggregateOutputType | null
  }

  export type EmailSendLogMinAggregateOutputType = {
    id: string | null
    to: string | null
    from: string | null
    subject: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailSendLogMaxAggregateOutputType = {
    id: string | null
    to: string | null
    from: string | null
    subject: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailSendLogCountAggregateOutputType = {
    id: number
    to: number
    from: number
    subject: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailSendLogMinAggregateInputType = {
    id?: true
    to?: true
    from?: true
    subject?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailSendLogMaxAggregateInputType = {
    id?: true
    to?: true
    from?: true
    subject?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailSendLogCountAggregateInputType = {
    id?: true
    to?: true
    from?: true
    subject?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailSendLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailSendLog to aggregate.
     */
    where?: EmailSendLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSendLogs to fetch.
     */
    orderBy?: EmailSendLogOrderByWithRelationInput | EmailSendLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailSendLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSendLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSendLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailSendLogs
    **/
    _count?: true | EmailSendLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailSendLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailSendLogMaxAggregateInputType
  }

  export type GetEmailSendLogAggregateType<T extends EmailSendLogAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailSendLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailSendLog[P]>
      : GetScalarType<T[P], AggregateEmailSendLog[P]>
  }




  export type EmailSendLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailSendLogWhereInput
    orderBy?: EmailSendLogOrderByWithAggregationInput | EmailSendLogOrderByWithAggregationInput[]
    by: EmailSendLogScalarFieldEnum[] | EmailSendLogScalarFieldEnum
    having?: EmailSendLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailSendLogCountAggregateInputType | true
    _min?: EmailSendLogMinAggregateInputType
    _max?: EmailSendLogMaxAggregateInputType
  }

  export type EmailSendLogGroupByOutputType = {
    id: string
    to: string
    from: string
    subject: string | null
    type: string
    createdAt: Date
    updatedAt: Date
    _count: EmailSendLogCountAggregateOutputType | null
    _min: EmailSendLogMinAggregateOutputType | null
    _max: EmailSendLogMaxAggregateOutputType | null
  }

  type GetEmailSendLogGroupByPayload<T extends EmailSendLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailSendLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailSendLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailSendLogGroupByOutputType[P]>
            : GetScalarType<T[P], EmailSendLogGroupByOutputType[P]>
        }
      >
    >


  export type EmailSendLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    to?: boolean
    from?: boolean
    subject?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailSendLog"]>

  export type EmailSendLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    to?: boolean
    from?: boolean
    subject?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailSendLog"]>

  export type EmailSendLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    to?: boolean
    from?: boolean
    subject?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailSendLog"]>

  export type EmailSendLogSelectScalar = {
    id?: boolean
    to?: boolean
    from?: boolean
    subject?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailSendLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "to" | "from" | "subject" | "type" | "createdAt" | "updatedAt", ExtArgs["result"]["emailSendLog"]>

  export type $EmailSendLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailSendLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      to: string
      from: string
      subject: string | null
      type: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailSendLog"]>
    composites: {}
  }

  type EmailSendLogGetPayload<S extends boolean | null | undefined | EmailSendLogDefaultArgs> = $Result.GetResult<Prisma.$EmailSendLogPayload, S>

  type EmailSendLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailSendLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailSendLogCountAggregateInputType | true
    }

  export interface EmailSendLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailSendLog'], meta: { name: 'EmailSendLog' } }
    /**
     * Find zero or one EmailSendLog that matches the filter.
     * @param {EmailSendLogFindUniqueArgs} args - Arguments to find a EmailSendLog
     * @example
     * // Get one EmailSendLog
     * const emailSendLog = await prisma.emailSendLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailSendLogFindUniqueArgs>(args: SelectSubset<T, EmailSendLogFindUniqueArgs<ExtArgs>>): Prisma__EmailSendLogClient<$Result.GetResult<Prisma.$EmailSendLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailSendLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailSendLogFindUniqueOrThrowArgs} args - Arguments to find a EmailSendLog
     * @example
     * // Get one EmailSendLog
     * const emailSendLog = await prisma.emailSendLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailSendLogFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailSendLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailSendLogClient<$Result.GetResult<Prisma.$EmailSendLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailSendLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSendLogFindFirstArgs} args - Arguments to find a EmailSendLog
     * @example
     * // Get one EmailSendLog
     * const emailSendLog = await prisma.emailSendLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailSendLogFindFirstArgs>(args?: SelectSubset<T, EmailSendLogFindFirstArgs<ExtArgs>>): Prisma__EmailSendLogClient<$Result.GetResult<Prisma.$EmailSendLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailSendLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSendLogFindFirstOrThrowArgs} args - Arguments to find a EmailSendLog
     * @example
     * // Get one EmailSendLog
     * const emailSendLog = await prisma.emailSendLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailSendLogFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailSendLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailSendLogClient<$Result.GetResult<Prisma.$EmailSendLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailSendLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSendLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailSendLogs
     * const emailSendLogs = await prisma.emailSendLog.findMany()
     * 
     * // Get first 10 EmailSendLogs
     * const emailSendLogs = await prisma.emailSendLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailSendLogWithIdOnly = await prisma.emailSendLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailSendLogFindManyArgs>(args?: SelectSubset<T, EmailSendLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSendLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailSendLog.
     * @param {EmailSendLogCreateArgs} args - Arguments to create a EmailSendLog.
     * @example
     * // Create one EmailSendLog
     * const EmailSendLog = await prisma.emailSendLog.create({
     *   data: {
     *     // ... data to create a EmailSendLog
     *   }
     * })
     * 
     */
    create<T extends EmailSendLogCreateArgs>(args: SelectSubset<T, EmailSendLogCreateArgs<ExtArgs>>): Prisma__EmailSendLogClient<$Result.GetResult<Prisma.$EmailSendLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailSendLogs.
     * @param {EmailSendLogCreateManyArgs} args - Arguments to create many EmailSendLogs.
     * @example
     * // Create many EmailSendLogs
     * const emailSendLog = await prisma.emailSendLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailSendLogCreateManyArgs>(args?: SelectSubset<T, EmailSendLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailSendLogs and returns the data saved in the database.
     * @param {EmailSendLogCreateManyAndReturnArgs} args - Arguments to create many EmailSendLogs.
     * @example
     * // Create many EmailSendLogs
     * const emailSendLog = await prisma.emailSendLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailSendLogs and only return the `id`
     * const emailSendLogWithIdOnly = await prisma.emailSendLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailSendLogCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailSendLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSendLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailSendLog.
     * @param {EmailSendLogDeleteArgs} args - Arguments to delete one EmailSendLog.
     * @example
     * // Delete one EmailSendLog
     * const EmailSendLog = await prisma.emailSendLog.delete({
     *   where: {
     *     // ... filter to delete one EmailSendLog
     *   }
     * })
     * 
     */
    delete<T extends EmailSendLogDeleteArgs>(args: SelectSubset<T, EmailSendLogDeleteArgs<ExtArgs>>): Prisma__EmailSendLogClient<$Result.GetResult<Prisma.$EmailSendLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailSendLog.
     * @param {EmailSendLogUpdateArgs} args - Arguments to update one EmailSendLog.
     * @example
     * // Update one EmailSendLog
     * const emailSendLog = await prisma.emailSendLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailSendLogUpdateArgs>(args: SelectSubset<T, EmailSendLogUpdateArgs<ExtArgs>>): Prisma__EmailSendLogClient<$Result.GetResult<Prisma.$EmailSendLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailSendLogs.
     * @param {EmailSendLogDeleteManyArgs} args - Arguments to filter EmailSendLogs to delete.
     * @example
     * // Delete a few EmailSendLogs
     * const { count } = await prisma.emailSendLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailSendLogDeleteManyArgs>(args?: SelectSubset<T, EmailSendLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailSendLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSendLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailSendLogs
     * const emailSendLog = await prisma.emailSendLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailSendLogUpdateManyArgs>(args: SelectSubset<T, EmailSendLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailSendLogs and returns the data updated in the database.
     * @param {EmailSendLogUpdateManyAndReturnArgs} args - Arguments to update many EmailSendLogs.
     * @example
     * // Update many EmailSendLogs
     * const emailSendLog = await prisma.emailSendLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailSendLogs and only return the `id`
     * const emailSendLogWithIdOnly = await prisma.emailSendLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailSendLogUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailSendLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSendLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailSendLog.
     * @param {EmailSendLogUpsertArgs} args - Arguments to update or create a EmailSendLog.
     * @example
     * // Update or create a EmailSendLog
     * const emailSendLog = await prisma.emailSendLog.upsert({
     *   create: {
     *     // ... data to create a EmailSendLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailSendLog we want to update
     *   }
     * })
     */
    upsert<T extends EmailSendLogUpsertArgs>(args: SelectSubset<T, EmailSendLogUpsertArgs<ExtArgs>>): Prisma__EmailSendLogClient<$Result.GetResult<Prisma.$EmailSendLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailSendLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSendLogCountArgs} args - Arguments to filter EmailSendLogs to count.
     * @example
     * // Count the number of EmailSendLogs
     * const count = await prisma.emailSendLog.count({
     *   where: {
     *     // ... the filter for the EmailSendLogs we want to count
     *   }
     * })
    **/
    count<T extends EmailSendLogCountArgs>(
      args?: Subset<T, EmailSendLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailSendLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailSendLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSendLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailSendLogAggregateArgs>(args: Subset<T, EmailSendLogAggregateArgs>): Prisma.PrismaPromise<GetEmailSendLogAggregateType<T>>

    /**
     * Group by EmailSendLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSendLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailSendLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailSendLogGroupByArgs['orderBy'] }
        : { orderBy?: EmailSendLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailSendLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailSendLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailSendLog model
   */
  readonly fields: EmailSendLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailSendLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailSendLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailSendLog model
   */
  interface EmailSendLogFieldRefs {
    readonly id: FieldRef<"EmailSendLog", 'String'>
    readonly to: FieldRef<"EmailSendLog", 'String'>
    readonly from: FieldRef<"EmailSendLog", 'String'>
    readonly subject: FieldRef<"EmailSendLog", 'String'>
    readonly type: FieldRef<"EmailSendLog", 'String'>
    readonly createdAt: FieldRef<"EmailSendLog", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailSendLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailSendLog findUnique
   */
  export type EmailSendLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSendLog
     */
    select?: EmailSendLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSendLog
     */
    omit?: EmailSendLogOmit<ExtArgs> | null
    /**
     * Filter, which EmailSendLog to fetch.
     */
    where: EmailSendLogWhereUniqueInput
  }

  /**
   * EmailSendLog findUniqueOrThrow
   */
  export type EmailSendLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSendLog
     */
    select?: EmailSendLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSendLog
     */
    omit?: EmailSendLogOmit<ExtArgs> | null
    /**
     * Filter, which EmailSendLog to fetch.
     */
    where: EmailSendLogWhereUniqueInput
  }

  /**
   * EmailSendLog findFirst
   */
  export type EmailSendLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSendLog
     */
    select?: EmailSendLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSendLog
     */
    omit?: EmailSendLogOmit<ExtArgs> | null
    /**
     * Filter, which EmailSendLog to fetch.
     */
    where?: EmailSendLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSendLogs to fetch.
     */
    orderBy?: EmailSendLogOrderByWithRelationInput | EmailSendLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailSendLogs.
     */
    cursor?: EmailSendLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSendLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSendLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailSendLogs.
     */
    distinct?: EmailSendLogScalarFieldEnum | EmailSendLogScalarFieldEnum[]
  }

  /**
   * EmailSendLog findFirstOrThrow
   */
  export type EmailSendLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSendLog
     */
    select?: EmailSendLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSendLog
     */
    omit?: EmailSendLogOmit<ExtArgs> | null
    /**
     * Filter, which EmailSendLog to fetch.
     */
    where?: EmailSendLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSendLogs to fetch.
     */
    orderBy?: EmailSendLogOrderByWithRelationInput | EmailSendLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailSendLogs.
     */
    cursor?: EmailSendLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSendLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSendLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailSendLogs.
     */
    distinct?: EmailSendLogScalarFieldEnum | EmailSendLogScalarFieldEnum[]
  }

  /**
   * EmailSendLog findMany
   */
  export type EmailSendLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSendLog
     */
    select?: EmailSendLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSendLog
     */
    omit?: EmailSendLogOmit<ExtArgs> | null
    /**
     * Filter, which EmailSendLogs to fetch.
     */
    where?: EmailSendLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSendLogs to fetch.
     */
    orderBy?: EmailSendLogOrderByWithRelationInput | EmailSendLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailSendLogs.
     */
    cursor?: EmailSendLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSendLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSendLogs.
     */
    skip?: number
    distinct?: EmailSendLogScalarFieldEnum | EmailSendLogScalarFieldEnum[]
  }

  /**
   * EmailSendLog create
   */
  export type EmailSendLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSendLog
     */
    select?: EmailSendLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSendLog
     */
    omit?: EmailSendLogOmit<ExtArgs> | null
    /**
     * The data needed to create a EmailSendLog.
     */
    data: XOR<EmailSendLogCreateInput, EmailSendLogUncheckedCreateInput>
  }

  /**
   * EmailSendLog createMany
   */
  export type EmailSendLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailSendLogs.
     */
    data: EmailSendLogCreateManyInput | EmailSendLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailSendLog createManyAndReturn
   */
  export type EmailSendLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSendLog
     */
    select?: EmailSendLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSendLog
     */
    omit?: EmailSendLogOmit<ExtArgs> | null
    /**
     * The data used to create many EmailSendLogs.
     */
    data: EmailSendLogCreateManyInput | EmailSendLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailSendLog update
   */
  export type EmailSendLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSendLog
     */
    select?: EmailSendLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSendLog
     */
    omit?: EmailSendLogOmit<ExtArgs> | null
    /**
     * The data needed to update a EmailSendLog.
     */
    data: XOR<EmailSendLogUpdateInput, EmailSendLogUncheckedUpdateInput>
    /**
     * Choose, which EmailSendLog to update.
     */
    where: EmailSendLogWhereUniqueInput
  }

  /**
   * EmailSendLog updateMany
   */
  export type EmailSendLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailSendLogs.
     */
    data: XOR<EmailSendLogUpdateManyMutationInput, EmailSendLogUncheckedUpdateManyInput>
    /**
     * Filter which EmailSendLogs to update
     */
    where?: EmailSendLogWhereInput
    /**
     * Limit how many EmailSendLogs to update.
     */
    limit?: number
  }

  /**
   * EmailSendLog updateManyAndReturn
   */
  export type EmailSendLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSendLog
     */
    select?: EmailSendLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSendLog
     */
    omit?: EmailSendLogOmit<ExtArgs> | null
    /**
     * The data used to update EmailSendLogs.
     */
    data: XOR<EmailSendLogUpdateManyMutationInput, EmailSendLogUncheckedUpdateManyInput>
    /**
     * Filter which EmailSendLogs to update
     */
    where?: EmailSendLogWhereInput
    /**
     * Limit how many EmailSendLogs to update.
     */
    limit?: number
  }

  /**
   * EmailSendLog upsert
   */
  export type EmailSendLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSendLog
     */
    select?: EmailSendLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSendLog
     */
    omit?: EmailSendLogOmit<ExtArgs> | null
    /**
     * The filter to search for the EmailSendLog to update in case it exists.
     */
    where: EmailSendLogWhereUniqueInput
    /**
     * In case the EmailSendLog found by the `where` argument doesn't exist, create a new EmailSendLog with this data.
     */
    create: XOR<EmailSendLogCreateInput, EmailSendLogUncheckedCreateInput>
    /**
     * In case the EmailSendLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailSendLogUpdateInput, EmailSendLogUncheckedUpdateInput>
  }

  /**
   * EmailSendLog delete
   */
  export type EmailSendLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSendLog
     */
    select?: EmailSendLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSendLog
     */
    omit?: EmailSendLogOmit<ExtArgs> | null
    /**
     * Filter which EmailSendLog to delete.
     */
    where: EmailSendLogWhereUniqueInput
  }

  /**
   * EmailSendLog deleteMany
   */
  export type EmailSendLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailSendLogs to delete
     */
    where?: EmailSendLogWhereInput
    /**
     * Limit how many EmailSendLogs to delete.
     */
    limit?: number
  }

  /**
   * EmailSendLog without action
   */
  export type EmailSendLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSendLog
     */
    select?: EmailSendLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSendLog
     */
    omit?: EmailSendLogOmit<ExtArgs> | null
  }


  /**
   * Model EmailSingleSendLog
   */

  export type AggregateEmailSingleSendLog = {
    _count: EmailSingleSendLogCountAggregateOutputType | null
    _min: EmailSingleSendLogMinAggregateOutputType | null
    _max: EmailSingleSendLogMaxAggregateOutputType | null
  }

  export type EmailSingleSendLogMinAggregateOutputType = {
    id: string | null
    contactId: string | null
    singleSendId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailSingleSendLogMaxAggregateOutputType = {
    id: string | null
    contactId: string | null
    singleSendId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailSingleSendLogCountAggregateOutputType = {
    id: number
    contactId: number
    singleSendId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailSingleSendLogMinAggregateInputType = {
    id?: true
    contactId?: true
    singleSendId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailSingleSendLogMaxAggregateInputType = {
    id?: true
    contactId?: true
    singleSendId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailSingleSendLogCountAggregateInputType = {
    id?: true
    contactId?: true
    singleSendId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailSingleSendLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailSingleSendLog to aggregate.
     */
    where?: EmailSingleSendLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSingleSendLogs to fetch.
     */
    orderBy?: EmailSingleSendLogOrderByWithRelationInput | EmailSingleSendLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailSingleSendLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSingleSendLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSingleSendLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailSingleSendLogs
    **/
    _count?: true | EmailSingleSendLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailSingleSendLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailSingleSendLogMaxAggregateInputType
  }

  export type GetEmailSingleSendLogAggregateType<T extends EmailSingleSendLogAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailSingleSendLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailSingleSendLog[P]>
      : GetScalarType<T[P], AggregateEmailSingleSendLog[P]>
  }




  export type EmailSingleSendLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailSingleSendLogWhereInput
    orderBy?: EmailSingleSendLogOrderByWithAggregationInput | EmailSingleSendLogOrderByWithAggregationInput[]
    by: EmailSingleSendLogScalarFieldEnum[] | EmailSingleSendLogScalarFieldEnum
    having?: EmailSingleSendLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailSingleSendLogCountAggregateInputType | true
    _min?: EmailSingleSendLogMinAggregateInputType
    _max?: EmailSingleSendLogMaxAggregateInputType
  }

  export type EmailSingleSendLogGroupByOutputType = {
    id: string
    contactId: string
    singleSendId: string
    createdAt: Date
    updatedAt: Date
    _count: EmailSingleSendLogCountAggregateOutputType | null
    _min: EmailSingleSendLogMinAggregateOutputType | null
    _max: EmailSingleSendLogMaxAggregateOutputType | null
  }

  type GetEmailSingleSendLogGroupByPayload<T extends EmailSingleSendLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailSingleSendLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailSingleSendLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailSingleSendLogGroupByOutputType[P]>
            : GetScalarType<T[P], EmailSingleSendLogGroupByOutputType[P]>
        }
      >
    >


  export type EmailSingleSendLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contactId?: boolean
    singleSendId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | EmailContactDefaultArgs<ExtArgs>
    singleSend?: boolean | EmailSingleSendDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailSingleSendLog"]>

  export type EmailSingleSendLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contactId?: boolean
    singleSendId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | EmailContactDefaultArgs<ExtArgs>
    singleSend?: boolean | EmailSingleSendDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailSingleSendLog"]>

  export type EmailSingleSendLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contactId?: boolean
    singleSendId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | EmailContactDefaultArgs<ExtArgs>
    singleSend?: boolean | EmailSingleSendDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailSingleSendLog"]>

  export type EmailSingleSendLogSelectScalar = {
    id?: boolean
    contactId?: boolean
    singleSendId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailSingleSendLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contactId" | "singleSendId" | "createdAt" | "updatedAt", ExtArgs["result"]["emailSingleSendLog"]>
  export type EmailSingleSendLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | EmailContactDefaultArgs<ExtArgs>
    singleSend?: boolean | EmailSingleSendDefaultArgs<ExtArgs>
  }
  export type EmailSingleSendLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | EmailContactDefaultArgs<ExtArgs>
    singleSend?: boolean | EmailSingleSendDefaultArgs<ExtArgs>
  }
  export type EmailSingleSendLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | EmailContactDefaultArgs<ExtArgs>
    singleSend?: boolean | EmailSingleSendDefaultArgs<ExtArgs>
  }

  export type $EmailSingleSendLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailSingleSendLog"
    objects: {
      contact: Prisma.$EmailContactPayload<ExtArgs>
      singleSend: Prisma.$EmailSingleSendPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contactId: string
      singleSendId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailSingleSendLog"]>
    composites: {}
  }

  type EmailSingleSendLogGetPayload<S extends boolean | null | undefined | EmailSingleSendLogDefaultArgs> = $Result.GetResult<Prisma.$EmailSingleSendLogPayload, S>

  type EmailSingleSendLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailSingleSendLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailSingleSendLogCountAggregateInputType | true
    }

  export interface EmailSingleSendLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailSingleSendLog'], meta: { name: 'EmailSingleSendLog' } }
    /**
     * Find zero or one EmailSingleSendLog that matches the filter.
     * @param {EmailSingleSendLogFindUniqueArgs} args - Arguments to find a EmailSingleSendLog
     * @example
     * // Get one EmailSingleSendLog
     * const emailSingleSendLog = await prisma.emailSingleSendLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailSingleSendLogFindUniqueArgs>(args: SelectSubset<T, EmailSingleSendLogFindUniqueArgs<ExtArgs>>): Prisma__EmailSingleSendLogClient<$Result.GetResult<Prisma.$EmailSingleSendLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailSingleSendLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailSingleSendLogFindUniqueOrThrowArgs} args - Arguments to find a EmailSingleSendLog
     * @example
     * // Get one EmailSingleSendLog
     * const emailSingleSendLog = await prisma.emailSingleSendLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailSingleSendLogFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailSingleSendLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailSingleSendLogClient<$Result.GetResult<Prisma.$EmailSingleSendLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailSingleSendLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSingleSendLogFindFirstArgs} args - Arguments to find a EmailSingleSendLog
     * @example
     * // Get one EmailSingleSendLog
     * const emailSingleSendLog = await prisma.emailSingleSendLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailSingleSendLogFindFirstArgs>(args?: SelectSubset<T, EmailSingleSendLogFindFirstArgs<ExtArgs>>): Prisma__EmailSingleSendLogClient<$Result.GetResult<Prisma.$EmailSingleSendLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailSingleSendLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSingleSendLogFindFirstOrThrowArgs} args - Arguments to find a EmailSingleSendLog
     * @example
     * // Get one EmailSingleSendLog
     * const emailSingleSendLog = await prisma.emailSingleSendLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailSingleSendLogFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailSingleSendLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailSingleSendLogClient<$Result.GetResult<Prisma.$EmailSingleSendLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailSingleSendLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSingleSendLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailSingleSendLogs
     * const emailSingleSendLogs = await prisma.emailSingleSendLog.findMany()
     * 
     * // Get first 10 EmailSingleSendLogs
     * const emailSingleSendLogs = await prisma.emailSingleSendLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailSingleSendLogWithIdOnly = await prisma.emailSingleSendLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailSingleSendLogFindManyArgs>(args?: SelectSubset<T, EmailSingleSendLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSingleSendLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailSingleSendLog.
     * @param {EmailSingleSendLogCreateArgs} args - Arguments to create a EmailSingleSendLog.
     * @example
     * // Create one EmailSingleSendLog
     * const EmailSingleSendLog = await prisma.emailSingleSendLog.create({
     *   data: {
     *     // ... data to create a EmailSingleSendLog
     *   }
     * })
     * 
     */
    create<T extends EmailSingleSendLogCreateArgs>(args: SelectSubset<T, EmailSingleSendLogCreateArgs<ExtArgs>>): Prisma__EmailSingleSendLogClient<$Result.GetResult<Prisma.$EmailSingleSendLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailSingleSendLogs.
     * @param {EmailSingleSendLogCreateManyArgs} args - Arguments to create many EmailSingleSendLogs.
     * @example
     * // Create many EmailSingleSendLogs
     * const emailSingleSendLog = await prisma.emailSingleSendLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailSingleSendLogCreateManyArgs>(args?: SelectSubset<T, EmailSingleSendLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailSingleSendLogs and returns the data saved in the database.
     * @param {EmailSingleSendLogCreateManyAndReturnArgs} args - Arguments to create many EmailSingleSendLogs.
     * @example
     * // Create many EmailSingleSendLogs
     * const emailSingleSendLog = await prisma.emailSingleSendLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailSingleSendLogs and only return the `id`
     * const emailSingleSendLogWithIdOnly = await prisma.emailSingleSendLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailSingleSendLogCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailSingleSendLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSingleSendLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailSingleSendLog.
     * @param {EmailSingleSendLogDeleteArgs} args - Arguments to delete one EmailSingleSendLog.
     * @example
     * // Delete one EmailSingleSendLog
     * const EmailSingleSendLog = await prisma.emailSingleSendLog.delete({
     *   where: {
     *     // ... filter to delete one EmailSingleSendLog
     *   }
     * })
     * 
     */
    delete<T extends EmailSingleSendLogDeleteArgs>(args: SelectSubset<T, EmailSingleSendLogDeleteArgs<ExtArgs>>): Prisma__EmailSingleSendLogClient<$Result.GetResult<Prisma.$EmailSingleSendLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailSingleSendLog.
     * @param {EmailSingleSendLogUpdateArgs} args - Arguments to update one EmailSingleSendLog.
     * @example
     * // Update one EmailSingleSendLog
     * const emailSingleSendLog = await prisma.emailSingleSendLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailSingleSendLogUpdateArgs>(args: SelectSubset<T, EmailSingleSendLogUpdateArgs<ExtArgs>>): Prisma__EmailSingleSendLogClient<$Result.GetResult<Prisma.$EmailSingleSendLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailSingleSendLogs.
     * @param {EmailSingleSendLogDeleteManyArgs} args - Arguments to filter EmailSingleSendLogs to delete.
     * @example
     * // Delete a few EmailSingleSendLogs
     * const { count } = await prisma.emailSingleSendLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailSingleSendLogDeleteManyArgs>(args?: SelectSubset<T, EmailSingleSendLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailSingleSendLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSingleSendLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailSingleSendLogs
     * const emailSingleSendLog = await prisma.emailSingleSendLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailSingleSendLogUpdateManyArgs>(args: SelectSubset<T, EmailSingleSendLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailSingleSendLogs and returns the data updated in the database.
     * @param {EmailSingleSendLogUpdateManyAndReturnArgs} args - Arguments to update many EmailSingleSendLogs.
     * @example
     * // Update many EmailSingleSendLogs
     * const emailSingleSendLog = await prisma.emailSingleSendLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailSingleSendLogs and only return the `id`
     * const emailSingleSendLogWithIdOnly = await prisma.emailSingleSendLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailSingleSendLogUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailSingleSendLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSingleSendLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailSingleSendLog.
     * @param {EmailSingleSendLogUpsertArgs} args - Arguments to update or create a EmailSingleSendLog.
     * @example
     * // Update or create a EmailSingleSendLog
     * const emailSingleSendLog = await prisma.emailSingleSendLog.upsert({
     *   create: {
     *     // ... data to create a EmailSingleSendLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailSingleSendLog we want to update
     *   }
     * })
     */
    upsert<T extends EmailSingleSendLogUpsertArgs>(args: SelectSubset<T, EmailSingleSendLogUpsertArgs<ExtArgs>>): Prisma__EmailSingleSendLogClient<$Result.GetResult<Prisma.$EmailSingleSendLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailSingleSendLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSingleSendLogCountArgs} args - Arguments to filter EmailSingleSendLogs to count.
     * @example
     * // Count the number of EmailSingleSendLogs
     * const count = await prisma.emailSingleSendLog.count({
     *   where: {
     *     // ... the filter for the EmailSingleSendLogs we want to count
     *   }
     * })
    **/
    count<T extends EmailSingleSendLogCountArgs>(
      args?: Subset<T, EmailSingleSendLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailSingleSendLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailSingleSendLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSingleSendLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailSingleSendLogAggregateArgs>(args: Subset<T, EmailSingleSendLogAggregateArgs>): Prisma.PrismaPromise<GetEmailSingleSendLogAggregateType<T>>

    /**
     * Group by EmailSingleSendLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSingleSendLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailSingleSendLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailSingleSendLogGroupByArgs['orderBy'] }
        : { orderBy?: EmailSingleSendLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailSingleSendLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailSingleSendLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailSingleSendLog model
   */
  readonly fields: EmailSingleSendLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailSingleSendLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailSingleSendLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends EmailContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailContactDefaultArgs<ExtArgs>>): Prisma__EmailContactClient<$Result.GetResult<Prisma.$EmailContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    singleSend<T extends EmailSingleSendDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailSingleSendDefaultArgs<ExtArgs>>): Prisma__EmailSingleSendClient<$Result.GetResult<Prisma.$EmailSingleSendPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailSingleSendLog model
   */
  interface EmailSingleSendLogFieldRefs {
    readonly id: FieldRef<"EmailSingleSendLog", 'String'>
    readonly contactId: FieldRef<"EmailSingleSendLog", 'String'>
    readonly singleSendId: FieldRef<"EmailSingleSendLog", 'String'>
    readonly createdAt: FieldRef<"EmailSingleSendLog", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailSingleSendLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailSingleSendLog findUnique
   */
  export type EmailSingleSendLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSendLog
     */
    select?: EmailSingleSendLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSendLog
     */
    omit?: EmailSingleSendLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailSingleSendLog to fetch.
     */
    where: EmailSingleSendLogWhereUniqueInput
  }

  /**
   * EmailSingleSendLog findUniqueOrThrow
   */
  export type EmailSingleSendLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSendLog
     */
    select?: EmailSingleSendLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSendLog
     */
    omit?: EmailSingleSendLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailSingleSendLog to fetch.
     */
    where: EmailSingleSendLogWhereUniqueInput
  }

  /**
   * EmailSingleSendLog findFirst
   */
  export type EmailSingleSendLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSendLog
     */
    select?: EmailSingleSendLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSendLog
     */
    omit?: EmailSingleSendLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailSingleSendLog to fetch.
     */
    where?: EmailSingleSendLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSingleSendLogs to fetch.
     */
    orderBy?: EmailSingleSendLogOrderByWithRelationInput | EmailSingleSendLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailSingleSendLogs.
     */
    cursor?: EmailSingleSendLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSingleSendLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSingleSendLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailSingleSendLogs.
     */
    distinct?: EmailSingleSendLogScalarFieldEnum | EmailSingleSendLogScalarFieldEnum[]
  }

  /**
   * EmailSingleSendLog findFirstOrThrow
   */
  export type EmailSingleSendLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSendLog
     */
    select?: EmailSingleSendLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSendLog
     */
    omit?: EmailSingleSendLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailSingleSendLog to fetch.
     */
    where?: EmailSingleSendLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSingleSendLogs to fetch.
     */
    orderBy?: EmailSingleSendLogOrderByWithRelationInput | EmailSingleSendLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailSingleSendLogs.
     */
    cursor?: EmailSingleSendLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSingleSendLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSingleSendLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailSingleSendLogs.
     */
    distinct?: EmailSingleSendLogScalarFieldEnum | EmailSingleSendLogScalarFieldEnum[]
  }

  /**
   * EmailSingleSendLog findMany
   */
  export type EmailSingleSendLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSendLog
     */
    select?: EmailSingleSendLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSendLog
     */
    omit?: EmailSingleSendLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailSingleSendLogs to fetch.
     */
    where?: EmailSingleSendLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSingleSendLogs to fetch.
     */
    orderBy?: EmailSingleSendLogOrderByWithRelationInput | EmailSingleSendLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailSingleSendLogs.
     */
    cursor?: EmailSingleSendLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSingleSendLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSingleSendLogs.
     */
    skip?: number
    distinct?: EmailSingleSendLogScalarFieldEnum | EmailSingleSendLogScalarFieldEnum[]
  }

  /**
   * EmailSingleSendLog create
   */
  export type EmailSingleSendLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSendLog
     */
    select?: EmailSingleSendLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSendLog
     */
    omit?: EmailSingleSendLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendLogInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailSingleSendLog.
     */
    data: XOR<EmailSingleSendLogCreateInput, EmailSingleSendLogUncheckedCreateInput>
  }

  /**
   * EmailSingleSendLog createMany
   */
  export type EmailSingleSendLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailSingleSendLogs.
     */
    data: EmailSingleSendLogCreateManyInput | EmailSingleSendLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailSingleSendLog createManyAndReturn
   */
  export type EmailSingleSendLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSendLog
     */
    select?: EmailSingleSendLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSendLog
     */
    omit?: EmailSingleSendLogOmit<ExtArgs> | null
    /**
     * The data used to create many EmailSingleSendLogs.
     */
    data: EmailSingleSendLogCreateManyInput | EmailSingleSendLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailSingleSendLog update
   */
  export type EmailSingleSendLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSendLog
     */
    select?: EmailSingleSendLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSendLog
     */
    omit?: EmailSingleSendLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendLogInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailSingleSendLog.
     */
    data: XOR<EmailSingleSendLogUpdateInput, EmailSingleSendLogUncheckedUpdateInput>
    /**
     * Choose, which EmailSingleSendLog to update.
     */
    where: EmailSingleSendLogWhereUniqueInput
  }

  /**
   * EmailSingleSendLog updateMany
   */
  export type EmailSingleSendLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailSingleSendLogs.
     */
    data: XOR<EmailSingleSendLogUpdateManyMutationInput, EmailSingleSendLogUncheckedUpdateManyInput>
    /**
     * Filter which EmailSingleSendLogs to update
     */
    where?: EmailSingleSendLogWhereInput
    /**
     * Limit how many EmailSingleSendLogs to update.
     */
    limit?: number
  }

  /**
   * EmailSingleSendLog updateManyAndReturn
   */
  export type EmailSingleSendLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSendLog
     */
    select?: EmailSingleSendLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSendLog
     */
    omit?: EmailSingleSendLogOmit<ExtArgs> | null
    /**
     * The data used to update EmailSingleSendLogs.
     */
    data: XOR<EmailSingleSendLogUpdateManyMutationInput, EmailSingleSendLogUncheckedUpdateManyInput>
    /**
     * Filter which EmailSingleSendLogs to update
     */
    where?: EmailSingleSendLogWhereInput
    /**
     * Limit how many EmailSingleSendLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailSingleSendLog upsert
   */
  export type EmailSingleSendLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSendLog
     */
    select?: EmailSingleSendLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSendLog
     */
    omit?: EmailSingleSendLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendLogInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailSingleSendLog to update in case it exists.
     */
    where: EmailSingleSendLogWhereUniqueInput
    /**
     * In case the EmailSingleSendLog found by the `where` argument doesn't exist, create a new EmailSingleSendLog with this data.
     */
    create: XOR<EmailSingleSendLogCreateInput, EmailSingleSendLogUncheckedCreateInput>
    /**
     * In case the EmailSingleSendLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailSingleSendLogUpdateInput, EmailSingleSendLogUncheckedUpdateInput>
  }

  /**
   * EmailSingleSendLog delete
   */
  export type EmailSingleSendLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSendLog
     */
    select?: EmailSingleSendLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSendLog
     */
    omit?: EmailSingleSendLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendLogInclude<ExtArgs> | null
    /**
     * Filter which EmailSingleSendLog to delete.
     */
    where: EmailSingleSendLogWhereUniqueInput
  }

  /**
   * EmailSingleSendLog deleteMany
   */
  export type EmailSingleSendLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailSingleSendLogs to delete
     */
    where?: EmailSingleSendLogWhereInput
    /**
     * Limit how many EmailSingleSendLogs to delete.
     */
    limit?: number
  }

  /**
   * EmailSingleSendLog without action
   */
  export type EmailSingleSendLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSingleSendLog
     */
    select?: EmailSingleSendLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSingleSendLog
     */
    omit?: EmailSingleSendLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailSingleSendLogInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    version: number | null
    price: number | null
    discountedPrice: number | null
  }

  export type ProductSumAggregateOutputType = {
    version: number | null
    price: number | null
    discountedPrice: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    type: $Enums.ProductType | null
    version: number | null
    status: $Enums.ContentStatus | null
    isLatest: boolean | null
    imageCoverId: string | null
    categoryId: string | null
    acquisitionMode: $Enums.ProductAcquisitionMode | null
    price: number | null
    discountedPrice: number | null
    isFree: boolean | null
    formId: string | null
    rootId: string | null
    seoId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    type: $Enums.ProductType | null
    version: number | null
    status: $Enums.ContentStatus | null
    isLatest: boolean | null
    imageCoverId: string | null
    categoryId: string | null
    acquisitionMode: $Enums.ProductAcquisitionMode | null
    price: number | null
    discountedPrice: number | null
    isFree: boolean | null
    formId: string | null
    rootId: string | null
    seoId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    description:PrismaJson.BodyData
    tiptapDescription:PrismaJson.TipTapBodyData
    type: number
    version: number
    status: number
    isLatest: number
    imageCoverId: number
    categoryId: number
    acquisitionMode: number
    price: number
    discountedPrice: number
    isFree: number
    metadata:PrismaJson.ProductMetadata
    formId: number
    rootId: number
    seoId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    version?: true
    price?: true
    discountedPrice?: true
  }

  export type ProductSumAggregateInputType = {
    version?: true
    price?: true
    discountedPrice?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    type?: true
    version?: true
    status?: true
    isLatest?: true
    imageCoverId?: true
    categoryId?: true
    acquisitionMode?: true
    price?: true
    discountedPrice?: true
    isFree?: true
    formId?: true
    rootId?: true
    seoId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    type?: true
    version?: true
    status?: true
    isLatest?: true
    imageCoverId?: true
    categoryId?: true
    acquisitionMode?: true
    price?: true
    discountedPrice?: true
    isFree?: true
    formId?: true
    rootId?: true
    seoId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    tiptapDescription?: true
    type?: true
    version?: true
    status?: true
    isLatest?: true
    imageCoverId?: true
    categoryId?: true
    acquisitionMode?: true
    price?: true
    discountedPrice?: true
    isFree?: true
    metadata?: true
    formId?: true
    rootId?: true
    seoId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription:PrismaJson.TipTapBodyData | null
    type: $Enums.ProductType
    version: number
    status: $Enums.ContentStatus
    isLatest: boolean
    imageCoverId: string | null
    categoryId: string | null
    acquisitionMode: $Enums.ProductAcquisitionMode
    price: number | null
    discountedPrice: number | null
    isFree: boolean
    metadata:PrismaJson.ProductMetadata | null
    formId: string | null
    rootId: string | null
    seoId: string | null
    userId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    tiptapDescription?: boolean
    type?: boolean
    version?: boolean
    status?: boolean
    isLatest?: boolean
    imageCoverId?: boolean
    categoryId?: boolean
    acquisitionMode?: boolean
    price?: boolean
    discountedPrice?: boolean
    isFree?: boolean
    metadata?: boolean
    formId?: boolean
    rootId?: boolean
    seoId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    imageCover?: boolean | Product$imageCoverArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    extras?: boolean | Product$extrasArgs<ExtArgs>
    form?: boolean | Product$formArgs<ExtArgs>
    root?: boolean | Product$rootArgs<ExtArgs>
    rootChildren?: boolean | Product$rootChildrenArgs<ExtArgs>
    gallery?: boolean | Product$galleryArgs<ExtArgs>
    faqs?: boolean | Product$faqsArgs<ExtArgs>
    purchases?: boolean | Product$purchasesArgs<ExtArgs>
    seo?: boolean | Product$seoArgs<ExtArgs>
    user?: boolean | Product$userArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    tiptapDescription?: boolean
    type?: boolean
    version?: boolean
    status?: boolean
    isLatest?: boolean
    imageCoverId?: boolean
    categoryId?: boolean
    acquisitionMode?: boolean
    price?: boolean
    discountedPrice?: boolean
    isFree?: boolean
    metadata?: boolean
    formId?: boolean
    rootId?: boolean
    seoId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    imageCover?: boolean | Product$imageCoverArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    form?: boolean | Product$formArgs<ExtArgs>
    root?: boolean | Product$rootArgs<ExtArgs>
    seo?: boolean | Product$seoArgs<ExtArgs>
    user?: boolean | Product$userArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    tiptapDescription?: boolean
    type?: boolean
    version?: boolean
    status?: boolean
    isLatest?: boolean
    imageCoverId?: boolean
    categoryId?: boolean
    acquisitionMode?: boolean
    price?: boolean
    discountedPrice?: boolean
    isFree?: boolean
    metadata?: boolean
    formId?: boolean
    rootId?: boolean
    seoId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    imageCover?: boolean | Product$imageCoverArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    form?: boolean | Product$formArgs<ExtArgs>
    root?: boolean | Product$rootArgs<ExtArgs>
    seo?: boolean | Product$seoArgs<ExtArgs>
    user?: boolean | Product$userArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    tiptapDescription?: boolean
    type?: boolean
    version?: boolean
    status?: boolean
    isLatest?: boolean
    imageCoverId?: boolean
    categoryId?: boolean
    acquisitionMode?: boolean
    price?: boolean
    discountedPrice?: boolean
    isFree?: boolean
    metadata?: boolean
    formId?: boolean
    rootId?: boolean
    seoId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "description" | "tiptapDescription" | "type" | "version" | "status" | "isLatest" | "imageCoverId" | "categoryId" | "acquisitionMode" | "price" | "discountedPrice" | "isFree" | "metadata" | "formId" | "rootId" | "seoId" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    imageCover?: boolean | Product$imageCoverArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    extras?: boolean | Product$extrasArgs<ExtArgs>
    form?: boolean | Product$formArgs<ExtArgs>
    root?: boolean | Product$rootArgs<ExtArgs>
    rootChildren?: boolean | Product$rootChildrenArgs<ExtArgs>
    gallery?: boolean | Product$galleryArgs<ExtArgs>
    faqs?: boolean | Product$faqsArgs<ExtArgs>
    purchases?: boolean | Product$purchasesArgs<ExtArgs>
    seo?: boolean | Product$seoArgs<ExtArgs>
    user?: boolean | Product$userArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    imageCover?: boolean | Product$imageCoverArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    form?: boolean | Product$formArgs<ExtArgs>
    root?: boolean | Product$rootArgs<ExtArgs>
    seo?: boolean | Product$seoArgs<ExtArgs>
    user?: boolean | Product$userArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    imageCover?: boolean | Product$imageCoverArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    form?: boolean | Product$formArgs<ExtArgs>
    root?: boolean | Product$rootArgs<ExtArgs>
    seo?: boolean | Product$seoArgs<ExtArgs>
    user?: boolean | Product$userArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      imageCover: Prisma.$MediaPayload<ExtArgs> | null
      category: Prisma.$ProductCategoryPayload<ExtArgs> | null
      extras: Prisma.$ProductExtraPayload<ExtArgs>[]
      form: Prisma.$FormPayload<ExtArgs> | null
      root: Prisma.$ProductPayload<ExtArgs> | null
      rootChildren: Prisma.$ProductPayload<ExtArgs>[]
      gallery: Prisma.$ProductGalleryPayload<ExtArgs>[]
      faqs: Prisma.$ProductFAQPayload<ExtArgs>[]
      purchases: Prisma.$PurchasePayload<ExtArgs>[]
      seo: Prisma.$SeoPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      /**
       * [BodyData]
       */
      description:PrismaJson.BodyData
      /**
       * [TipTapBodyData]
       */
      tiptapDescription:PrismaJson.TipTapBodyData | null
      type: $Enums.ProductType
      version: number
      status: $Enums.ContentStatus
      isLatest: boolean
      imageCoverId: string | null
      categoryId: string | null
      acquisitionMode: $Enums.ProductAcquisitionMode
      price: number | null
      discountedPrice: number | null
      isFree: boolean
      /**
       * [ProductMetadata]
       */
      metadata:PrismaJson.ProductMetadata | null
      formId: string | null
      rootId: string | null
      seoId: string | null
      userId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    imageCover<T extends Product$imageCoverArgs<ExtArgs> = {}>(args?: Subset<T, Product$imageCoverArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    category<T extends Product$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$categoryArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    extras<T extends Product$extrasArgs<ExtArgs> = {}>(args?: Subset<T, Product$extrasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductExtraPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    form<T extends Product$formArgs<ExtArgs> = {}>(args?: Subset<T, Product$formArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    root<T extends Product$rootArgs<ExtArgs> = {}>(args?: Subset<T, Product$rootArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    rootChildren<T extends Product$rootChildrenArgs<ExtArgs> = {}>(args?: Subset<T, Product$rootChildrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gallery<T extends Product$galleryArgs<ExtArgs> = {}>(args?: Subset<T, Product$galleryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    faqs<T extends Product$faqsArgs<ExtArgs> = {}>(args?: Subset<T, Product$faqsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductFAQPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchases<T extends Product$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, Product$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seo<T extends Product$seoArgs<ExtArgs> = {}>(args?: Subset<T, Product$seoArgs<ExtArgs>>): Prisma__SeoClient<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends Product$userArgs<ExtArgs> = {}>(args?: Subset<T, Product$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly title: FieldRef<"Product", 'String'>
    readonly slug: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'Json'>
    readonly tiptapDescription: FieldRef<"Product", 'Json'>
    readonly type: FieldRef<"Product", 'ProductType'>
    readonly version: FieldRef<"Product", 'Int'>
    readonly status: FieldRef<"Product", 'ContentStatus'>
    readonly isLatest: FieldRef<"Product", 'Boolean'>
    readonly imageCoverId: FieldRef<"Product", 'String'>
    readonly categoryId: FieldRef<"Product", 'String'>
    readonly acquisitionMode: FieldRef<"Product", 'ProductAcquisitionMode'>
    readonly price: FieldRef<"Product", 'Float'>
    readonly discountedPrice: FieldRef<"Product", 'Float'>
    readonly isFree: FieldRef<"Product", 'Boolean'>
    readonly metadata: FieldRef<"Product", 'Json'>
    readonly formId: FieldRef<"Product", 'String'>
    readonly rootId: FieldRef<"Product", 'String'>
    readonly seoId: FieldRef<"Product", 'String'>
    readonly userId: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.imageCover
   */
  export type Product$imageCoverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Product.category
   */
  export type Product$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
  }

  /**
   * Product.extras
   */
  export type Product$extrasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductExtra
     */
    select?: ProductExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductExtra
     */
    omit?: ProductExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductExtraInclude<ExtArgs> | null
    where?: ProductExtraWhereInput
    orderBy?: ProductExtraOrderByWithRelationInput | ProductExtraOrderByWithRelationInput[]
    cursor?: ProductExtraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductExtraScalarFieldEnum | ProductExtraScalarFieldEnum[]
  }

  /**
   * Product.form
   */
  export type Product$formArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    where?: FormWhereInput
  }

  /**
   * Product.root
   */
  export type Product$rootArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * Product.rootChildren
   */
  export type Product$rootChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product.gallery
   */
  export type Product$galleryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryInclude<ExtArgs> | null
    where?: ProductGalleryWhereInput
    orderBy?: ProductGalleryOrderByWithRelationInput | ProductGalleryOrderByWithRelationInput[]
    cursor?: ProductGalleryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductGalleryScalarFieldEnum | ProductGalleryScalarFieldEnum[]
  }

  /**
   * Product.faqs
   */
  export type Product$faqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFAQ
     */
    select?: ProductFAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFAQ
     */
    omit?: ProductFAQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFAQInclude<ExtArgs> | null
    where?: ProductFAQWhereInput
    orderBy?: ProductFAQOrderByWithRelationInput | ProductFAQOrderByWithRelationInput[]
    cursor?: ProductFAQWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductFAQScalarFieldEnum | ProductFAQScalarFieldEnum[]
  }

  /**
   * Product.purchases
   */
  export type Product$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Product.seo
   */
  export type Product$seoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    where?: SeoWhereInput
  }

  /**
   * Product.user
   */
  export type Product$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductCategory
   */

  export type AggregateProductCategory = {
    _count: ProductCategoryCountAggregateOutputType | null
    _avg: ProductCategoryAvgAggregateOutputType | null
    _sum: ProductCategorySumAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  export type ProductCategoryAvgAggregateOutputType = {
    version: number | null
  }

  export type ProductCategorySumAggregateOutputType = {
    version: number | null
  }

  export type ProductCategoryMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    version: number | null
    status: $Enums.ContentStatus | null
    isLatest: boolean | null
    rootId: string | null
    seoId: string | null
    firstPublishedAt: Date | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCategoryMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    version: number | null
    status: $Enums.ContentStatus | null
    isLatest: boolean | null
    rootId: string | null
    seoId: string | null
    firstPublishedAt: Date | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCategoryCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    description: number
    version: number
    status: number
    isLatest: number
    rootId: number
    seoId: number
    firstPublishedAt: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductCategoryAvgAggregateInputType = {
    version?: true
  }

  export type ProductCategorySumAggregateInputType = {
    version?: true
  }

  export type ProductCategoryMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    version?: true
    status?: true
    isLatest?: true
    rootId?: true
    seoId?: true
    firstPublishedAt?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCategoryMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    version?: true
    status?: true
    isLatest?: true
    rootId?: true
    seoId?: true
    firstPublishedAt?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCategoryCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    version?: true
    status?: true
    isLatest?: true
    rootId?: true
    seoId?: true
    firstPublishedAt?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategory to aggregate.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCategories
    **/
    _count?: true | ProductCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type GetProductCategoryAggregateType<T extends ProductCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCategory[P]>
      : GetScalarType<T[P], AggregateProductCategory[P]>
  }




  export type ProductCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithAggregationInput | ProductCategoryOrderByWithAggregationInput[]
    by: ProductCategoryScalarFieldEnum[] | ProductCategoryScalarFieldEnum
    having?: ProductCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCategoryCountAggregateInputType | true
    _avg?: ProductCategoryAvgAggregateInputType
    _sum?: ProductCategorySumAggregateInputType
    _min?: ProductCategoryMinAggregateInputType
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type ProductCategoryGroupByOutputType = {
    id: string
    title: string
    slug: string
    description: string | null
    version: number
    status: $Enums.ContentStatus
    isLatest: boolean
    rootId: string | null
    seoId: string | null
    firstPublishedAt: Date
    publishedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: ProductCategoryCountAggregateOutputType | null
    _avg: ProductCategoryAvgAggregateOutputType | null
    _sum: ProductCategorySumAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  type GetProductCategoryGroupByPayload<T extends ProductCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    version?: boolean
    status?: boolean
    isLatest?: boolean
    rootId?: boolean
    seoId?: boolean
    firstPublishedAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    root?: boolean | ProductCategory$rootArgs<ExtArgs>
    rootChildren?: boolean | ProductCategory$rootChildrenArgs<ExtArgs>
    products?: boolean | ProductCategory$productsArgs<ExtArgs>
    seo?: boolean | ProductCategory$seoArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    version?: boolean
    status?: boolean
    isLatest?: boolean
    rootId?: boolean
    seoId?: boolean
    firstPublishedAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    root?: boolean | ProductCategory$rootArgs<ExtArgs>
    seo?: boolean | ProductCategory$seoArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    version?: boolean
    status?: boolean
    isLatest?: boolean
    rootId?: boolean
    seoId?: boolean
    firstPublishedAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    root?: boolean | ProductCategory$rootArgs<ExtArgs>
    seo?: boolean | ProductCategory$seoArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    version?: boolean
    status?: boolean
    isLatest?: boolean
    rootId?: boolean
    seoId?: boolean
    firstPublishedAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "description" | "version" | "status" | "isLatest" | "rootId" | "seoId" | "firstPublishedAt" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["productCategory"]>
  export type ProductCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    root?: boolean | ProductCategory$rootArgs<ExtArgs>
    rootChildren?: boolean | ProductCategory$rootChildrenArgs<ExtArgs>
    products?: boolean | ProductCategory$productsArgs<ExtArgs>
    seo?: boolean | ProductCategory$seoArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    root?: boolean | ProductCategory$rootArgs<ExtArgs>
    seo?: boolean | ProductCategory$seoArgs<ExtArgs>
  }
  export type ProductCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    root?: boolean | ProductCategory$rootArgs<ExtArgs>
    seo?: boolean | ProductCategory$seoArgs<ExtArgs>
  }

  export type $ProductCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCategory"
    objects: {
      root: Prisma.$ProductCategoryPayload<ExtArgs> | null
      rootChildren: Prisma.$ProductCategoryPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      seo: Prisma.$SeoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      description: string | null
      version: number
      status: $Enums.ContentStatus
      isLatest: boolean
      rootId: string | null
      seoId: string | null
      firstPublishedAt: Date
      publishedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productCategory"]>
    composites: {}
  }

  type ProductCategoryGetPayload<S extends boolean | null | undefined | ProductCategoryDefaultArgs> = $Result.GetResult<Prisma.$ProductCategoryPayload, S>

  type ProductCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCategoryCountAggregateInputType | true
    }

  export interface ProductCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCategory'], meta: { name: 'ProductCategory' } }
    /**
     * Find zero or one ProductCategory that matches the filter.
     * @param {ProductCategoryFindUniqueArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCategoryFindUniqueArgs>(args: SelectSubset<T, ProductCategoryFindUniqueArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCategoryFindFirstArgs>(args?: SelectSubset<T, ProductCategoryFindFirstArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCategories
     * const productCategories = await prisma.productCategory.findMany()
     * 
     * // Get first 10 ProductCategories
     * const productCategories = await prisma.productCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductCategoryFindManyArgs>(args?: SelectSubset<T, ProductCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductCategory.
     * @param {ProductCategoryCreateArgs} args - Arguments to create a ProductCategory.
     * @example
     * // Create one ProductCategory
     * const ProductCategory = await prisma.productCategory.create({
     *   data: {
     *     // ... data to create a ProductCategory
     *   }
     * })
     * 
     */
    create<T extends ProductCategoryCreateArgs>(args: SelectSubset<T, ProductCategoryCreateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductCategories.
     * @param {ProductCategoryCreateManyArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCategoryCreateManyArgs>(args?: SelectSubset<T, ProductCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductCategories and returns the data saved in the database.
     * @param {ProductCategoryCreateManyAndReturnArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductCategory.
     * @param {ProductCategoryDeleteArgs} args - Arguments to delete one ProductCategory.
     * @example
     * // Delete one ProductCategory
     * const ProductCategory = await prisma.productCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductCategory
     *   }
     * })
     * 
     */
    delete<T extends ProductCategoryDeleteArgs>(args: SelectSubset<T, ProductCategoryDeleteArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductCategory.
     * @param {ProductCategoryUpdateArgs} args - Arguments to update one ProductCategory.
     * @example
     * // Update one ProductCategory
     * const productCategory = await prisma.productCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCategoryUpdateArgs>(args: SelectSubset<T, ProductCategoryUpdateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductCategories.
     * @param {ProductCategoryDeleteManyArgs} args - Arguments to filter ProductCategories to delete.
     * @example
     * // Delete a few ProductCategories
     * const { count } = await prisma.productCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCategoryDeleteManyArgs>(args?: SelectSubset<T, ProductCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCategoryUpdateManyArgs>(args: SelectSubset<T, ProductCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories and returns the data updated in the database.
     * @param {ProductCategoryUpdateManyAndReturnArgs} args - Arguments to update many ProductCategories.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductCategory.
     * @param {ProductCategoryUpsertArgs} args - Arguments to update or create a ProductCategory.
     * @example
     * // Update or create a ProductCategory
     * const productCategory = await prisma.productCategory.upsert({
     *   create: {
     *     // ... data to create a ProductCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCategory we want to update
     *   }
     * })
     */
    upsert<T extends ProductCategoryUpsertArgs>(args: SelectSubset<T, ProductCategoryUpsertArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryCountArgs} args - Arguments to filter ProductCategories to count.
     * @example
     * // Count the number of ProductCategories
     * const count = await prisma.productCategory.count({
     *   where: {
     *     // ... the filter for the ProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductCategoryCountArgs>(
      args?: Subset<T, ProductCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCategoryAggregateArgs>(args: Subset<T, ProductCategoryAggregateArgs>): Prisma.PrismaPromise<GetProductCategoryAggregateType<T>>

    /**
     * Group by ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCategory model
   */
  readonly fields: ProductCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    root<T extends ProductCategory$rootArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$rootArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    rootChildren<T extends ProductCategory$rootChildrenArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$rootChildrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends ProductCategory$productsArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seo<T extends ProductCategory$seoArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$seoArgs<ExtArgs>>): Prisma__SeoClient<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCategory model
   */
  interface ProductCategoryFieldRefs {
    readonly id: FieldRef<"ProductCategory", 'String'>
    readonly title: FieldRef<"ProductCategory", 'String'>
    readonly slug: FieldRef<"ProductCategory", 'String'>
    readonly description: FieldRef<"ProductCategory", 'String'>
    readonly version: FieldRef<"ProductCategory", 'Int'>
    readonly status: FieldRef<"ProductCategory", 'ContentStatus'>
    readonly isLatest: FieldRef<"ProductCategory", 'Boolean'>
    readonly rootId: FieldRef<"ProductCategory", 'String'>
    readonly seoId: FieldRef<"ProductCategory", 'String'>
    readonly firstPublishedAt: FieldRef<"ProductCategory", 'DateTime'>
    readonly publishedAt: FieldRef<"ProductCategory", 'DateTime'>
    readonly createdAt: FieldRef<"ProductCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductCategory findUnique
   */
  export type ProductCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findUniqueOrThrow
   */
  export type ProductCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findFirst
   */
  export type ProductCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findFirstOrThrow
   */
  export type ProductCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findMany
   */
  export type ProductCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategories to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory create
   */
  export type ProductCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCategory.
     */
    data: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
  }

  /**
   * ProductCategory createMany
   */
  export type ProductCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCategory createManyAndReturn
   */
  export type ProductCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCategory update
   */
  export type ProductCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCategory.
     */
    data: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductCategory to update.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory updateMany
   */
  export type ProductCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
  }

  /**
   * ProductCategory updateManyAndReturn
   */
  export type ProductCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCategory upsert
   */
  export type ProductCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCategory to update in case it exists.
     */
    where: ProductCategoryWhereUniqueInput
    /**
     * In case the ProductCategory found by the `where` argument doesn't exist, create a new ProductCategory with this data.
     */
    create: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
    /**
     * In case the ProductCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
  }

  /**
   * ProductCategory delete
   */
  export type ProductCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter which ProductCategory to delete.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory deleteMany
   */
  export type ProductCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategories to delete
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to delete.
     */
    limit?: number
  }

  /**
   * ProductCategory.root
   */
  export type ProductCategory$rootArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
  }

  /**
   * ProductCategory.rootChildren
   */
  export type ProductCategory$rootChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory.products
   */
  export type ProductCategory$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * ProductCategory.seo
   */
  export type ProductCategory$seoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    where?: SeoWhereInput
  }

  /**
   * ProductCategory without action
   */
  export type ProductCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
  }


  /**
   * Model ProductGallery
   */

  export type AggregateProductGallery = {
    _count: ProductGalleryCountAggregateOutputType | null
    _avg: ProductGalleryAvgAggregateOutputType | null
    _sum: ProductGallerySumAggregateOutputType | null
    _min: ProductGalleryMinAggregateOutputType | null
    _max: ProductGalleryMaxAggregateOutputType | null
  }

  export type ProductGalleryAvgAggregateOutputType = {
    sort: number | null
  }

  export type ProductGallerySumAggregateOutputType = {
    sort: number | null
  }

  export type ProductGalleryMinAggregateOutputType = {
    id: string | null
    sort: number | null
    productId: string | null
    mediaId: string | null
  }

  export type ProductGalleryMaxAggregateOutputType = {
    id: string | null
    sort: number | null
    productId: string | null
    mediaId: string | null
  }

  export type ProductGalleryCountAggregateOutputType = {
    id: number
    sort: number
    productId: number
    mediaId: number
    _all: number
  }


  export type ProductGalleryAvgAggregateInputType = {
    sort?: true
  }

  export type ProductGallerySumAggregateInputType = {
    sort?: true
  }

  export type ProductGalleryMinAggregateInputType = {
    id?: true
    sort?: true
    productId?: true
    mediaId?: true
  }

  export type ProductGalleryMaxAggregateInputType = {
    id?: true
    sort?: true
    productId?: true
    mediaId?: true
  }

  export type ProductGalleryCountAggregateInputType = {
    id?: true
    sort?: true
    productId?: true
    mediaId?: true
    _all?: true
  }

  export type ProductGalleryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductGallery to aggregate.
     */
    where?: ProductGalleryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductGalleries to fetch.
     */
    orderBy?: ProductGalleryOrderByWithRelationInput | ProductGalleryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductGalleryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductGalleries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductGalleries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductGalleries
    **/
    _count?: true | ProductGalleryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductGalleryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductGallerySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductGalleryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductGalleryMaxAggregateInputType
  }

  export type GetProductGalleryAggregateType<T extends ProductGalleryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductGallery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductGallery[P]>
      : GetScalarType<T[P], AggregateProductGallery[P]>
  }




  export type ProductGalleryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductGalleryWhereInput
    orderBy?: ProductGalleryOrderByWithAggregationInput | ProductGalleryOrderByWithAggregationInput[]
    by: ProductGalleryScalarFieldEnum[] | ProductGalleryScalarFieldEnum
    having?: ProductGalleryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductGalleryCountAggregateInputType | true
    _avg?: ProductGalleryAvgAggregateInputType
    _sum?: ProductGallerySumAggregateInputType
    _min?: ProductGalleryMinAggregateInputType
    _max?: ProductGalleryMaxAggregateInputType
  }

  export type ProductGalleryGroupByOutputType = {
    id: string
    sort: number
    productId: string
    mediaId: string
    _count: ProductGalleryCountAggregateOutputType | null
    _avg: ProductGalleryAvgAggregateOutputType | null
    _sum: ProductGallerySumAggregateOutputType | null
    _min: ProductGalleryMinAggregateOutputType | null
    _max: ProductGalleryMaxAggregateOutputType | null
  }

  type GetProductGalleryGroupByPayload<T extends ProductGalleryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGalleryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGalleryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGalleryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGalleryGroupByOutputType[P]>
        }
      >
    >


  export type ProductGallerySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sort?: boolean
    productId?: boolean
    mediaId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productGallery"]>

  export type ProductGallerySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sort?: boolean
    productId?: boolean
    mediaId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productGallery"]>

  export type ProductGallerySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sort?: boolean
    productId?: boolean
    mediaId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productGallery"]>

  export type ProductGallerySelectScalar = {
    id?: boolean
    sort?: boolean
    productId?: boolean
    mediaId?: boolean
  }

  export type ProductGalleryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sort" | "productId" | "mediaId", ExtArgs["result"]["productGallery"]>
  export type ProductGalleryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }
  export type ProductGalleryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }
  export type ProductGalleryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }

  export type $ProductGalleryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductGallery"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      media: Prisma.$MediaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sort: number
      productId: string
      mediaId: string
    }, ExtArgs["result"]["productGallery"]>
    composites: {}
  }

  type ProductGalleryGetPayload<S extends boolean | null | undefined | ProductGalleryDefaultArgs> = $Result.GetResult<Prisma.$ProductGalleryPayload, S>

  type ProductGalleryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductGalleryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductGalleryCountAggregateInputType | true
    }

  export interface ProductGalleryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductGallery'], meta: { name: 'ProductGallery' } }
    /**
     * Find zero or one ProductGallery that matches the filter.
     * @param {ProductGalleryFindUniqueArgs} args - Arguments to find a ProductGallery
     * @example
     * // Get one ProductGallery
     * const productGallery = await prisma.productGallery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductGalleryFindUniqueArgs>(args: SelectSubset<T, ProductGalleryFindUniqueArgs<ExtArgs>>): Prisma__ProductGalleryClient<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductGallery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductGalleryFindUniqueOrThrowArgs} args - Arguments to find a ProductGallery
     * @example
     * // Get one ProductGallery
     * const productGallery = await prisma.productGallery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductGalleryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductGalleryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductGalleryClient<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductGallery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGalleryFindFirstArgs} args - Arguments to find a ProductGallery
     * @example
     * // Get one ProductGallery
     * const productGallery = await prisma.productGallery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductGalleryFindFirstArgs>(args?: SelectSubset<T, ProductGalleryFindFirstArgs<ExtArgs>>): Prisma__ProductGalleryClient<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductGallery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGalleryFindFirstOrThrowArgs} args - Arguments to find a ProductGallery
     * @example
     * // Get one ProductGallery
     * const productGallery = await prisma.productGallery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductGalleryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductGalleryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductGalleryClient<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductGalleries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGalleryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductGalleries
     * const productGalleries = await prisma.productGallery.findMany()
     * 
     * // Get first 10 ProductGalleries
     * const productGalleries = await prisma.productGallery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productGalleryWithIdOnly = await prisma.productGallery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductGalleryFindManyArgs>(args?: SelectSubset<T, ProductGalleryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductGallery.
     * @param {ProductGalleryCreateArgs} args - Arguments to create a ProductGallery.
     * @example
     * // Create one ProductGallery
     * const ProductGallery = await prisma.productGallery.create({
     *   data: {
     *     // ... data to create a ProductGallery
     *   }
     * })
     * 
     */
    create<T extends ProductGalleryCreateArgs>(args: SelectSubset<T, ProductGalleryCreateArgs<ExtArgs>>): Prisma__ProductGalleryClient<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductGalleries.
     * @param {ProductGalleryCreateManyArgs} args - Arguments to create many ProductGalleries.
     * @example
     * // Create many ProductGalleries
     * const productGallery = await prisma.productGallery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductGalleryCreateManyArgs>(args?: SelectSubset<T, ProductGalleryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductGalleries and returns the data saved in the database.
     * @param {ProductGalleryCreateManyAndReturnArgs} args - Arguments to create many ProductGalleries.
     * @example
     * // Create many ProductGalleries
     * const productGallery = await prisma.productGallery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductGalleries and only return the `id`
     * const productGalleryWithIdOnly = await prisma.productGallery.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductGalleryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductGalleryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductGallery.
     * @param {ProductGalleryDeleteArgs} args - Arguments to delete one ProductGallery.
     * @example
     * // Delete one ProductGallery
     * const ProductGallery = await prisma.productGallery.delete({
     *   where: {
     *     // ... filter to delete one ProductGallery
     *   }
     * })
     * 
     */
    delete<T extends ProductGalleryDeleteArgs>(args: SelectSubset<T, ProductGalleryDeleteArgs<ExtArgs>>): Prisma__ProductGalleryClient<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductGallery.
     * @param {ProductGalleryUpdateArgs} args - Arguments to update one ProductGallery.
     * @example
     * // Update one ProductGallery
     * const productGallery = await prisma.productGallery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductGalleryUpdateArgs>(args: SelectSubset<T, ProductGalleryUpdateArgs<ExtArgs>>): Prisma__ProductGalleryClient<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductGalleries.
     * @param {ProductGalleryDeleteManyArgs} args - Arguments to filter ProductGalleries to delete.
     * @example
     * // Delete a few ProductGalleries
     * const { count } = await prisma.productGallery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductGalleryDeleteManyArgs>(args?: SelectSubset<T, ProductGalleryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductGalleries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGalleryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductGalleries
     * const productGallery = await prisma.productGallery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductGalleryUpdateManyArgs>(args: SelectSubset<T, ProductGalleryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductGalleries and returns the data updated in the database.
     * @param {ProductGalleryUpdateManyAndReturnArgs} args - Arguments to update many ProductGalleries.
     * @example
     * // Update many ProductGalleries
     * const productGallery = await prisma.productGallery.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductGalleries and only return the `id`
     * const productGalleryWithIdOnly = await prisma.productGallery.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductGalleryUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductGalleryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductGallery.
     * @param {ProductGalleryUpsertArgs} args - Arguments to update or create a ProductGallery.
     * @example
     * // Update or create a ProductGallery
     * const productGallery = await prisma.productGallery.upsert({
     *   create: {
     *     // ... data to create a ProductGallery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductGallery we want to update
     *   }
     * })
     */
    upsert<T extends ProductGalleryUpsertArgs>(args: SelectSubset<T, ProductGalleryUpsertArgs<ExtArgs>>): Prisma__ProductGalleryClient<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductGalleries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGalleryCountArgs} args - Arguments to filter ProductGalleries to count.
     * @example
     * // Count the number of ProductGalleries
     * const count = await prisma.productGallery.count({
     *   where: {
     *     // ... the filter for the ProductGalleries we want to count
     *   }
     * })
    **/
    count<T extends ProductGalleryCountArgs>(
      args?: Subset<T, ProductGalleryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductGalleryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductGallery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGalleryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductGalleryAggregateArgs>(args: Subset<T, ProductGalleryAggregateArgs>): Prisma.PrismaPromise<GetProductGalleryAggregateType<T>>

    /**
     * Group by ProductGallery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGalleryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGalleryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGalleryGroupByArgs['orderBy'] }
        : { orderBy?: ProductGalleryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGalleryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGalleryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductGallery model
   */
  readonly fields: ProductGalleryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductGallery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductGalleryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    media<T extends MediaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MediaDefaultArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductGallery model
   */
  interface ProductGalleryFieldRefs {
    readonly id: FieldRef<"ProductGallery", 'String'>
    readonly sort: FieldRef<"ProductGallery", 'Int'>
    readonly productId: FieldRef<"ProductGallery", 'String'>
    readonly mediaId: FieldRef<"ProductGallery", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductGallery findUnique
   */
  export type ProductGalleryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryInclude<ExtArgs> | null
    /**
     * Filter, which ProductGallery to fetch.
     */
    where: ProductGalleryWhereUniqueInput
  }

  /**
   * ProductGallery findUniqueOrThrow
   */
  export type ProductGalleryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryInclude<ExtArgs> | null
    /**
     * Filter, which ProductGallery to fetch.
     */
    where: ProductGalleryWhereUniqueInput
  }

  /**
   * ProductGallery findFirst
   */
  export type ProductGalleryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryInclude<ExtArgs> | null
    /**
     * Filter, which ProductGallery to fetch.
     */
    where?: ProductGalleryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductGalleries to fetch.
     */
    orderBy?: ProductGalleryOrderByWithRelationInput | ProductGalleryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductGalleries.
     */
    cursor?: ProductGalleryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductGalleries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductGalleries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductGalleries.
     */
    distinct?: ProductGalleryScalarFieldEnum | ProductGalleryScalarFieldEnum[]
  }

  /**
   * ProductGallery findFirstOrThrow
   */
  export type ProductGalleryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryInclude<ExtArgs> | null
    /**
     * Filter, which ProductGallery to fetch.
     */
    where?: ProductGalleryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductGalleries to fetch.
     */
    orderBy?: ProductGalleryOrderByWithRelationInput | ProductGalleryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductGalleries.
     */
    cursor?: ProductGalleryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductGalleries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductGalleries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductGalleries.
     */
    distinct?: ProductGalleryScalarFieldEnum | ProductGalleryScalarFieldEnum[]
  }

  /**
   * ProductGallery findMany
   */
  export type ProductGalleryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryInclude<ExtArgs> | null
    /**
     * Filter, which ProductGalleries to fetch.
     */
    where?: ProductGalleryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductGalleries to fetch.
     */
    orderBy?: ProductGalleryOrderByWithRelationInput | ProductGalleryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductGalleries.
     */
    cursor?: ProductGalleryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductGalleries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductGalleries.
     */
    skip?: number
    distinct?: ProductGalleryScalarFieldEnum | ProductGalleryScalarFieldEnum[]
  }

  /**
   * ProductGallery create
   */
  export type ProductGalleryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductGallery.
     */
    data: XOR<ProductGalleryCreateInput, ProductGalleryUncheckedCreateInput>
  }

  /**
   * ProductGallery createMany
   */
  export type ProductGalleryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductGalleries.
     */
    data: ProductGalleryCreateManyInput | ProductGalleryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductGallery createManyAndReturn
   */
  export type ProductGalleryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * The data used to create many ProductGalleries.
     */
    data: ProductGalleryCreateManyInput | ProductGalleryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductGallery update
   */
  export type ProductGalleryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductGallery.
     */
    data: XOR<ProductGalleryUpdateInput, ProductGalleryUncheckedUpdateInput>
    /**
     * Choose, which ProductGallery to update.
     */
    where: ProductGalleryWhereUniqueInput
  }

  /**
   * ProductGallery updateMany
   */
  export type ProductGalleryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductGalleries.
     */
    data: XOR<ProductGalleryUpdateManyMutationInput, ProductGalleryUncheckedUpdateManyInput>
    /**
     * Filter which ProductGalleries to update
     */
    where?: ProductGalleryWhereInput
    /**
     * Limit how many ProductGalleries to update.
     */
    limit?: number
  }

  /**
   * ProductGallery updateManyAndReturn
   */
  export type ProductGalleryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * The data used to update ProductGalleries.
     */
    data: XOR<ProductGalleryUpdateManyMutationInput, ProductGalleryUncheckedUpdateManyInput>
    /**
     * Filter which ProductGalleries to update
     */
    where?: ProductGalleryWhereInput
    /**
     * Limit how many ProductGalleries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductGallery upsert
   */
  export type ProductGalleryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductGallery to update in case it exists.
     */
    where: ProductGalleryWhereUniqueInput
    /**
     * In case the ProductGallery found by the `where` argument doesn't exist, create a new ProductGallery with this data.
     */
    create: XOR<ProductGalleryCreateInput, ProductGalleryUncheckedCreateInput>
    /**
     * In case the ProductGallery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductGalleryUpdateInput, ProductGalleryUncheckedUpdateInput>
  }

  /**
   * ProductGallery delete
   */
  export type ProductGalleryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryInclude<ExtArgs> | null
    /**
     * Filter which ProductGallery to delete.
     */
    where: ProductGalleryWhereUniqueInput
  }

  /**
   * ProductGallery deleteMany
   */
  export type ProductGalleryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductGalleries to delete
     */
    where?: ProductGalleryWhereInput
    /**
     * Limit how many ProductGalleries to delete.
     */
    limit?: number
  }

  /**
   * ProductGallery without action
   */
  export type ProductGalleryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryInclude<ExtArgs> | null
  }


  /**
   * Model ProductExtra
   */

  export type AggregateProductExtra = {
    _count: ProductExtraCountAggregateOutputType | null
    _avg: ProductExtraAvgAggregateOutputType | null
    _sum: ProductExtraSumAggregateOutputType | null
    _min: ProductExtraMinAggregateOutputType | null
    _max: ProductExtraMaxAggregateOutputType | null
  }

  export type ProductExtraAvgAggregateOutputType = {
    price: number | null
  }

  export type ProductExtraSumAggregateOutputType = {
    price: number | null
  }

  export type ProductExtraMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    productId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductExtraMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    productId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductExtraCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    productId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductExtraAvgAggregateInputType = {
    price?: true
  }

  export type ProductExtraSumAggregateInputType = {
    price?: true
  }

  export type ProductExtraMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductExtraMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductExtraCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductExtraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductExtra to aggregate.
     */
    where?: ProductExtraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductExtras to fetch.
     */
    orderBy?: ProductExtraOrderByWithRelationInput | ProductExtraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductExtraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductExtras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductExtras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductExtras
    **/
    _count?: true | ProductExtraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductExtraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductExtraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductExtraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductExtraMaxAggregateInputType
  }

  export type GetProductExtraAggregateType<T extends ProductExtraAggregateArgs> = {
        [P in keyof T & keyof AggregateProductExtra]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductExtra[P]>
      : GetScalarType<T[P], AggregateProductExtra[P]>
  }




  export type ProductExtraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductExtraWhereInput
    orderBy?: ProductExtraOrderByWithAggregationInput | ProductExtraOrderByWithAggregationInput[]
    by: ProductExtraScalarFieldEnum[] | ProductExtraScalarFieldEnum
    having?: ProductExtraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductExtraCountAggregateInputType | true
    _avg?: ProductExtraAvgAggregateInputType
    _sum?: ProductExtraSumAggregateInputType
    _min?: ProductExtraMinAggregateInputType
    _max?: ProductExtraMaxAggregateInputType
  }

  export type ProductExtraGroupByOutputType = {
    id: string
    name: string
    description: string | null
    price: number
    productId: string
    createdAt: Date
    updatedAt: Date
    _count: ProductExtraCountAggregateOutputType | null
    _avg: ProductExtraAvgAggregateOutputType | null
    _sum: ProductExtraSumAggregateOutputType | null
    _min: ProductExtraMinAggregateOutputType | null
    _max: ProductExtraMaxAggregateOutputType | null
  }

  type GetProductExtraGroupByPayload<T extends ProductExtraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductExtraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductExtraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductExtraGroupByOutputType[P]>
            : GetScalarType<T[P], ProductExtraGroupByOutputType[P]>
        }
      >
    >


  export type ProductExtraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productExtra"]>

  export type ProductExtraSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productExtra"]>

  export type ProductExtraSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productExtra"]>

  export type ProductExtraSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductExtraOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "price" | "productId" | "createdAt" | "updatedAt", ExtArgs["result"]["productExtra"]>
  export type ProductExtraInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductExtraIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductExtraIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductExtraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductExtra"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      price: number
      productId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productExtra"]>
    composites: {}
  }

  type ProductExtraGetPayload<S extends boolean | null | undefined | ProductExtraDefaultArgs> = $Result.GetResult<Prisma.$ProductExtraPayload, S>

  type ProductExtraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductExtraFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductExtraCountAggregateInputType | true
    }

  export interface ProductExtraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductExtra'], meta: { name: 'ProductExtra' } }
    /**
     * Find zero or one ProductExtra that matches the filter.
     * @param {ProductExtraFindUniqueArgs} args - Arguments to find a ProductExtra
     * @example
     * // Get one ProductExtra
     * const productExtra = await prisma.productExtra.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductExtraFindUniqueArgs>(args: SelectSubset<T, ProductExtraFindUniqueArgs<ExtArgs>>): Prisma__ProductExtraClient<$Result.GetResult<Prisma.$ProductExtraPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductExtra that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductExtraFindUniqueOrThrowArgs} args - Arguments to find a ProductExtra
     * @example
     * // Get one ProductExtra
     * const productExtra = await prisma.productExtra.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductExtraFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductExtraFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductExtraClient<$Result.GetResult<Prisma.$ProductExtraPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductExtra that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductExtraFindFirstArgs} args - Arguments to find a ProductExtra
     * @example
     * // Get one ProductExtra
     * const productExtra = await prisma.productExtra.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductExtraFindFirstArgs>(args?: SelectSubset<T, ProductExtraFindFirstArgs<ExtArgs>>): Prisma__ProductExtraClient<$Result.GetResult<Prisma.$ProductExtraPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductExtra that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductExtraFindFirstOrThrowArgs} args - Arguments to find a ProductExtra
     * @example
     * // Get one ProductExtra
     * const productExtra = await prisma.productExtra.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductExtraFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductExtraFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductExtraClient<$Result.GetResult<Prisma.$ProductExtraPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductExtras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductExtraFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductExtras
     * const productExtras = await prisma.productExtra.findMany()
     * 
     * // Get first 10 ProductExtras
     * const productExtras = await prisma.productExtra.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productExtraWithIdOnly = await prisma.productExtra.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductExtraFindManyArgs>(args?: SelectSubset<T, ProductExtraFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductExtraPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductExtra.
     * @param {ProductExtraCreateArgs} args - Arguments to create a ProductExtra.
     * @example
     * // Create one ProductExtra
     * const ProductExtra = await prisma.productExtra.create({
     *   data: {
     *     // ... data to create a ProductExtra
     *   }
     * })
     * 
     */
    create<T extends ProductExtraCreateArgs>(args: SelectSubset<T, ProductExtraCreateArgs<ExtArgs>>): Prisma__ProductExtraClient<$Result.GetResult<Prisma.$ProductExtraPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductExtras.
     * @param {ProductExtraCreateManyArgs} args - Arguments to create many ProductExtras.
     * @example
     * // Create many ProductExtras
     * const productExtra = await prisma.productExtra.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductExtraCreateManyArgs>(args?: SelectSubset<T, ProductExtraCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductExtras and returns the data saved in the database.
     * @param {ProductExtraCreateManyAndReturnArgs} args - Arguments to create many ProductExtras.
     * @example
     * // Create many ProductExtras
     * const productExtra = await prisma.productExtra.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductExtras and only return the `id`
     * const productExtraWithIdOnly = await prisma.productExtra.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductExtraCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductExtraCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductExtraPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductExtra.
     * @param {ProductExtraDeleteArgs} args - Arguments to delete one ProductExtra.
     * @example
     * // Delete one ProductExtra
     * const ProductExtra = await prisma.productExtra.delete({
     *   where: {
     *     // ... filter to delete one ProductExtra
     *   }
     * })
     * 
     */
    delete<T extends ProductExtraDeleteArgs>(args: SelectSubset<T, ProductExtraDeleteArgs<ExtArgs>>): Prisma__ProductExtraClient<$Result.GetResult<Prisma.$ProductExtraPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductExtra.
     * @param {ProductExtraUpdateArgs} args - Arguments to update one ProductExtra.
     * @example
     * // Update one ProductExtra
     * const productExtra = await prisma.productExtra.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductExtraUpdateArgs>(args: SelectSubset<T, ProductExtraUpdateArgs<ExtArgs>>): Prisma__ProductExtraClient<$Result.GetResult<Prisma.$ProductExtraPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductExtras.
     * @param {ProductExtraDeleteManyArgs} args - Arguments to filter ProductExtras to delete.
     * @example
     * // Delete a few ProductExtras
     * const { count } = await prisma.productExtra.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductExtraDeleteManyArgs>(args?: SelectSubset<T, ProductExtraDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductExtras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductExtraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductExtras
     * const productExtra = await prisma.productExtra.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductExtraUpdateManyArgs>(args: SelectSubset<T, ProductExtraUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductExtras and returns the data updated in the database.
     * @param {ProductExtraUpdateManyAndReturnArgs} args - Arguments to update many ProductExtras.
     * @example
     * // Update many ProductExtras
     * const productExtra = await prisma.productExtra.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductExtras and only return the `id`
     * const productExtraWithIdOnly = await prisma.productExtra.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductExtraUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductExtraUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductExtraPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductExtra.
     * @param {ProductExtraUpsertArgs} args - Arguments to update or create a ProductExtra.
     * @example
     * // Update or create a ProductExtra
     * const productExtra = await prisma.productExtra.upsert({
     *   create: {
     *     // ... data to create a ProductExtra
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductExtra we want to update
     *   }
     * })
     */
    upsert<T extends ProductExtraUpsertArgs>(args: SelectSubset<T, ProductExtraUpsertArgs<ExtArgs>>): Prisma__ProductExtraClient<$Result.GetResult<Prisma.$ProductExtraPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductExtras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductExtraCountArgs} args - Arguments to filter ProductExtras to count.
     * @example
     * // Count the number of ProductExtras
     * const count = await prisma.productExtra.count({
     *   where: {
     *     // ... the filter for the ProductExtras we want to count
     *   }
     * })
    **/
    count<T extends ProductExtraCountArgs>(
      args?: Subset<T, ProductExtraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductExtraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductExtra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductExtraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductExtraAggregateArgs>(args: Subset<T, ProductExtraAggregateArgs>): Prisma.PrismaPromise<GetProductExtraAggregateType<T>>

    /**
     * Group by ProductExtra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductExtraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductExtraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductExtraGroupByArgs['orderBy'] }
        : { orderBy?: ProductExtraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductExtraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductExtraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductExtra model
   */
  readonly fields: ProductExtraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductExtra.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductExtraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductExtra model
   */
  interface ProductExtraFieldRefs {
    readonly id: FieldRef<"ProductExtra", 'String'>
    readonly name: FieldRef<"ProductExtra", 'String'>
    readonly description: FieldRef<"ProductExtra", 'String'>
    readonly price: FieldRef<"ProductExtra", 'Float'>
    readonly productId: FieldRef<"ProductExtra", 'String'>
    readonly createdAt: FieldRef<"ProductExtra", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductExtra", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductExtra findUnique
   */
  export type ProductExtraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductExtra
     */
    select?: ProductExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductExtra
     */
    omit?: ProductExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductExtraInclude<ExtArgs> | null
    /**
     * Filter, which ProductExtra to fetch.
     */
    where: ProductExtraWhereUniqueInput
  }

  /**
   * ProductExtra findUniqueOrThrow
   */
  export type ProductExtraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductExtra
     */
    select?: ProductExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductExtra
     */
    omit?: ProductExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductExtraInclude<ExtArgs> | null
    /**
     * Filter, which ProductExtra to fetch.
     */
    where: ProductExtraWhereUniqueInput
  }

  /**
   * ProductExtra findFirst
   */
  export type ProductExtraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductExtra
     */
    select?: ProductExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductExtra
     */
    omit?: ProductExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductExtraInclude<ExtArgs> | null
    /**
     * Filter, which ProductExtra to fetch.
     */
    where?: ProductExtraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductExtras to fetch.
     */
    orderBy?: ProductExtraOrderByWithRelationInput | ProductExtraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductExtras.
     */
    cursor?: ProductExtraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductExtras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductExtras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductExtras.
     */
    distinct?: ProductExtraScalarFieldEnum | ProductExtraScalarFieldEnum[]
  }

  /**
   * ProductExtra findFirstOrThrow
   */
  export type ProductExtraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductExtra
     */
    select?: ProductExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductExtra
     */
    omit?: ProductExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductExtraInclude<ExtArgs> | null
    /**
     * Filter, which ProductExtra to fetch.
     */
    where?: ProductExtraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductExtras to fetch.
     */
    orderBy?: ProductExtraOrderByWithRelationInput | ProductExtraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductExtras.
     */
    cursor?: ProductExtraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductExtras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductExtras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductExtras.
     */
    distinct?: ProductExtraScalarFieldEnum | ProductExtraScalarFieldEnum[]
  }

  /**
   * ProductExtra findMany
   */
  export type ProductExtraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductExtra
     */
    select?: ProductExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductExtra
     */
    omit?: ProductExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductExtraInclude<ExtArgs> | null
    /**
     * Filter, which ProductExtras to fetch.
     */
    where?: ProductExtraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductExtras to fetch.
     */
    orderBy?: ProductExtraOrderByWithRelationInput | ProductExtraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductExtras.
     */
    cursor?: ProductExtraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductExtras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductExtras.
     */
    skip?: number
    distinct?: ProductExtraScalarFieldEnum | ProductExtraScalarFieldEnum[]
  }

  /**
   * ProductExtra create
   */
  export type ProductExtraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductExtra
     */
    select?: ProductExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductExtra
     */
    omit?: ProductExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductExtraInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductExtra.
     */
    data: XOR<ProductExtraCreateInput, ProductExtraUncheckedCreateInput>
  }

  /**
   * ProductExtra createMany
   */
  export type ProductExtraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductExtras.
     */
    data: ProductExtraCreateManyInput | ProductExtraCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductExtra createManyAndReturn
   */
  export type ProductExtraCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductExtra
     */
    select?: ProductExtraSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductExtra
     */
    omit?: ProductExtraOmit<ExtArgs> | null
    /**
     * The data used to create many ProductExtras.
     */
    data: ProductExtraCreateManyInput | ProductExtraCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductExtraIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductExtra update
   */
  export type ProductExtraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductExtra
     */
    select?: ProductExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductExtra
     */
    omit?: ProductExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductExtraInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductExtra.
     */
    data: XOR<ProductExtraUpdateInput, ProductExtraUncheckedUpdateInput>
    /**
     * Choose, which ProductExtra to update.
     */
    where: ProductExtraWhereUniqueInput
  }

  /**
   * ProductExtra updateMany
   */
  export type ProductExtraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductExtras.
     */
    data: XOR<ProductExtraUpdateManyMutationInput, ProductExtraUncheckedUpdateManyInput>
    /**
     * Filter which ProductExtras to update
     */
    where?: ProductExtraWhereInput
    /**
     * Limit how many ProductExtras to update.
     */
    limit?: number
  }

  /**
   * ProductExtra updateManyAndReturn
   */
  export type ProductExtraUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductExtra
     */
    select?: ProductExtraSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductExtra
     */
    omit?: ProductExtraOmit<ExtArgs> | null
    /**
     * The data used to update ProductExtras.
     */
    data: XOR<ProductExtraUpdateManyMutationInput, ProductExtraUncheckedUpdateManyInput>
    /**
     * Filter which ProductExtras to update
     */
    where?: ProductExtraWhereInput
    /**
     * Limit how many ProductExtras to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductExtraIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductExtra upsert
   */
  export type ProductExtraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductExtra
     */
    select?: ProductExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductExtra
     */
    omit?: ProductExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductExtraInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductExtra to update in case it exists.
     */
    where: ProductExtraWhereUniqueInput
    /**
     * In case the ProductExtra found by the `where` argument doesn't exist, create a new ProductExtra with this data.
     */
    create: XOR<ProductExtraCreateInput, ProductExtraUncheckedCreateInput>
    /**
     * In case the ProductExtra was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductExtraUpdateInput, ProductExtraUncheckedUpdateInput>
  }

  /**
   * ProductExtra delete
   */
  export type ProductExtraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductExtra
     */
    select?: ProductExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductExtra
     */
    omit?: ProductExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductExtraInclude<ExtArgs> | null
    /**
     * Filter which ProductExtra to delete.
     */
    where: ProductExtraWhereUniqueInput
  }

  /**
   * ProductExtra deleteMany
   */
  export type ProductExtraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductExtras to delete
     */
    where?: ProductExtraWhereInput
    /**
     * Limit how many ProductExtras to delete.
     */
    limit?: number
  }

  /**
   * ProductExtra without action
   */
  export type ProductExtraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductExtra
     */
    select?: ProductExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductExtra
     */
    omit?: ProductExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductExtraInclude<ExtArgs> | null
  }


  /**
   * Model ProductFAQ
   */

  export type AggregateProductFAQ = {
    _count: ProductFAQCountAggregateOutputType | null
    _avg: ProductFAQAvgAggregateOutputType | null
    _sum: ProductFAQSumAggregateOutputType | null
    _min: ProductFAQMinAggregateOutputType | null
    _max: ProductFAQMaxAggregateOutputType | null
  }

  export type ProductFAQAvgAggregateOutputType = {
    sort: number | null
  }

  export type ProductFAQSumAggregateOutputType = {
    sort: number | null
  }

  export type ProductFAQMinAggregateOutputType = {
    id: string | null
    question: string | null
    answer: string | null
    sort: number | null
    productId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductFAQMaxAggregateOutputType = {
    id: string | null
    question: string | null
    answer: string | null
    sort: number | null
    productId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductFAQCountAggregateOutputType = {
    id: number
    question: number
    answer: number
    sort: number
    productId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductFAQAvgAggregateInputType = {
    sort?: true
  }

  export type ProductFAQSumAggregateInputType = {
    sort?: true
  }

  export type ProductFAQMinAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    sort?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductFAQMaxAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    sort?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductFAQCountAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    sort?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductFAQAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductFAQ to aggregate.
     */
    where?: ProductFAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductFAQS to fetch.
     */
    orderBy?: ProductFAQOrderByWithRelationInput | ProductFAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductFAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductFAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductFAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductFAQS
    **/
    _count?: true | ProductFAQCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductFAQAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductFAQSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductFAQMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductFAQMaxAggregateInputType
  }

  export type GetProductFAQAggregateType<T extends ProductFAQAggregateArgs> = {
        [P in keyof T & keyof AggregateProductFAQ]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductFAQ[P]>
      : GetScalarType<T[P], AggregateProductFAQ[P]>
  }




  export type ProductFAQGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductFAQWhereInput
    orderBy?: ProductFAQOrderByWithAggregationInput | ProductFAQOrderByWithAggregationInput[]
    by: ProductFAQScalarFieldEnum[] | ProductFAQScalarFieldEnum
    having?: ProductFAQScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductFAQCountAggregateInputType | true
    _avg?: ProductFAQAvgAggregateInputType
    _sum?: ProductFAQSumAggregateInputType
    _min?: ProductFAQMinAggregateInputType
    _max?: ProductFAQMaxAggregateInputType
  }

  export type ProductFAQGroupByOutputType = {
    id: string
    question: string
    answer: string
    sort: number
    productId: string
    createdAt: Date
    updatedAt: Date
    _count: ProductFAQCountAggregateOutputType | null
    _avg: ProductFAQAvgAggregateOutputType | null
    _sum: ProductFAQSumAggregateOutputType | null
    _min: ProductFAQMinAggregateOutputType | null
    _max: ProductFAQMaxAggregateOutputType | null
  }

  type GetProductFAQGroupByPayload<T extends ProductFAQGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductFAQGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductFAQGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductFAQGroupByOutputType[P]>
            : GetScalarType<T[P], ProductFAQGroupByOutputType[P]>
        }
      >
    >


  export type ProductFAQSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    sort?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productFAQ"]>

  export type ProductFAQSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    sort?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productFAQ"]>

  export type ProductFAQSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    sort?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productFAQ"]>

  export type ProductFAQSelectScalar = {
    id?: boolean
    question?: boolean
    answer?: boolean
    sort?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductFAQOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "question" | "answer" | "sort" | "productId" | "createdAt" | "updatedAt", ExtArgs["result"]["productFAQ"]>
  export type ProductFAQInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductFAQIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductFAQIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductFAQPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductFAQ"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      question: string
      answer: string
      sort: number
      productId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productFAQ"]>
    composites: {}
  }

  type ProductFAQGetPayload<S extends boolean | null | undefined | ProductFAQDefaultArgs> = $Result.GetResult<Prisma.$ProductFAQPayload, S>

  type ProductFAQCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFAQFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductFAQCountAggregateInputType | true
    }

  export interface ProductFAQDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductFAQ'], meta: { name: 'ProductFAQ' } }
    /**
     * Find zero or one ProductFAQ that matches the filter.
     * @param {ProductFAQFindUniqueArgs} args - Arguments to find a ProductFAQ
     * @example
     * // Get one ProductFAQ
     * const productFAQ = await prisma.productFAQ.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFAQFindUniqueArgs>(args: SelectSubset<T, ProductFAQFindUniqueArgs<ExtArgs>>): Prisma__ProductFAQClient<$Result.GetResult<Prisma.$ProductFAQPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductFAQ that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFAQFindUniqueOrThrowArgs} args - Arguments to find a ProductFAQ
     * @example
     * // Get one ProductFAQ
     * const productFAQ = await prisma.productFAQ.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFAQFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFAQFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductFAQClient<$Result.GetResult<Prisma.$ProductFAQPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductFAQ that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFAQFindFirstArgs} args - Arguments to find a ProductFAQ
     * @example
     * // Get one ProductFAQ
     * const productFAQ = await prisma.productFAQ.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFAQFindFirstArgs>(args?: SelectSubset<T, ProductFAQFindFirstArgs<ExtArgs>>): Prisma__ProductFAQClient<$Result.GetResult<Prisma.$ProductFAQPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductFAQ that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFAQFindFirstOrThrowArgs} args - Arguments to find a ProductFAQ
     * @example
     * // Get one ProductFAQ
     * const productFAQ = await prisma.productFAQ.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFAQFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFAQFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductFAQClient<$Result.GetResult<Prisma.$ProductFAQPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductFAQS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFAQFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductFAQS
     * const productFAQS = await prisma.productFAQ.findMany()
     * 
     * // Get first 10 ProductFAQS
     * const productFAQS = await prisma.productFAQ.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productFAQWithIdOnly = await prisma.productFAQ.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFAQFindManyArgs>(args?: SelectSubset<T, ProductFAQFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductFAQPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductFAQ.
     * @param {ProductFAQCreateArgs} args - Arguments to create a ProductFAQ.
     * @example
     * // Create one ProductFAQ
     * const ProductFAQ = await prisma.productFAQ.create({
     *   data: {
     *     // ... data to create a ProductFAQ
     *   }
     * })
     * 
     */
    create<T extends ProductFAQCreateArgs>(args: SelectSubset<T, ProductFAQCreateArgs<ExtArgs>>): Prisma__ProductFAQClient<$Result.GetResult<Prisma.$ProductFAQPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductFAQS.
     * @param {ProductFAQCreateManyArgs} args - Arguments to create many ProductFAQS.
     * @example
     * // Create many ProductFAQS
     * const productFAQ = await prisma.productFAQ.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductFAQCreateManyArgs>(args?: SelectSubset<T, ProductFAQCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductFAQS and returns the data saved in the database.
     * @param {ProductFAQCreateManyAndReturnArgs} args - Arguments to create many ProductFAQS.
     * @example
     * // Create many ProductFAQS
     * const productFAQ = await prisma.productFAQ.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductFAQS and only return the `id`
     * const productFAQWithIdOnly = await prisma.productFAQ.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductFAQCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductFAQCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductFAQPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductFAQ.
     * @param {ProductFAQDeleteArgs} args - Arguments to delete one ProductFAQ.
     * @example
     * // Delete one ProductFAQ
     * const ProductFAQ = await prisma.productFAQ.delete({
     *   where: {
     *     // ... filter to delete one ProductFAQ
     *   }
     * })
     * 
     */
    delete<T extends ProductFAQDeleteArgs>(args: SelectSubset<T, ProductFAQDeleteArgs<ExtArgs>>): Prisma__ProductFAQClient<$Result.GetResult<Prisma.$ProductFAQPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductFAQ.
     * @param {ProductFAQUpdateArgs} args - Arguments to update one ProductFAQ.
     * @example
     * // Update one ProductFAQ
     * const productFAQ = await prisma.productFAQ.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductFAQUpdateArgs>(args: SelectSubset<T, ProductFAQUpdateArgs<ExtArgs>>): Prisma__ProductFAQClient<$Result.GetResult<Prisma.$ProductFAQPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductFAQS.
     * @param {ProductFAQDeleteManyArgs} args - Arguments to filter ProductFAQS to delete.
     * @example
     * // Delete a few ProductFAQS
     * const { count } = await prisma.productFAQ.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductFAQDeleteManyArgs>(args?: SelectSubset<T, ProductFAQDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductFAQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFAQUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductFAQS
     * const productFAQ = await prisma.productFAQ.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductFAQUpdateManyArgs>(args: SelectSubset<T, ProductFAQUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductFAQS and returns the data updated in the database.
     * @param {ProductFAQUpdateManyAndReturnArgs} args - Arguments to update many ProductFAQS.
     * @example
     * // Update many ProductFAQS
     * const productFAQ = await prisma.productFAQ.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductFAQS and only return the `id`
     * const productFAQWithIdOnly = await prisma.productFAQ.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductFAQUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductFAQUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductFAQPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductFAQ.
     * @param {ProductFAQUpsertArgs} args - Arguments to update or create a ProductFAQ.
     * @example
     * // Update or create a ProductFAQ
     * const productFAQ = await prisma.productFAQ.upsert({
     *   create: {
     *     // ... data to create a ProductFAQ
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductFAQ we want to update
     *   }
     * })
     */
    upsert<T extends ProductFAQUpsertArgs>(args: SelectSubset<T, ProductFAQUpsertArgs<ExtArgs>>): Prisma__ProductFAQClient<$Result.GetResult<Prisma.$ProductFAQPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductFAQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFAQCountArgs} args - Arguments to filter ProductFAQS to count.
     * @example
     * // Count the number of ProductFAQS
     * const count = await prisma.productFAQ.count({
     *   where: {
     *     // ... the filter for the ProductFAQS we want to count
     *   }
     * })
    **/
    count<T extends ProductFAQCountArgs>(
      args?: Subset<T, ProductFAQCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductFAQCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductFAQ.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFAQAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductFAQAggregateArgs>(args: Subset<T, ProductFAQAggregateArgs>): Prisma.PrismaPromise<GetProductFAQAggregateType<T>>

    /**
     * Group by ProductFAQ.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFAQGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductFAQGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductFAQGroupByArgs['orderBy'] }
        : { orderBy?: ProductFAQGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductFAQGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductFAQGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductFAQ model
   */
  readonly fields: ProductFAQFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductFAQ.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductFAQClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductFAQ model
   */
  interface ProductFAQFieldRefs {
    readonly id: FieldRef<"ProductFAQ", 'String'>
    readonly question: FieldRef<"ProductFAQ", 'String'>
    readonly answer: FieldRef<"ProductFAQ", 'String'>
    readonly sort: FieldRef<"ProductFAQ", 'Int'>
    readonly productId: FieldRef<"ProductFAQ", 'String'>
    readonly createdAt: FieldRef<"ProductFAQ", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductFAQ", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductFAQ findUnique
   */
  export type ProductFAQFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFAQ
     */
    select?: ProductFAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFAQ
     */
    omit?: ProductFAQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFAQInclude<ExtArgs> | null
    /**
     * Filter, which ProductFAQ to fetch.
     */
    where: ProductFAQWhereUniqueInput
  }

  /**
   * ProductFAQ findUniqueOrThrow
   */
  export type ProductFAQFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFAQ
     */
    select?: ProductFAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFAQ
     */
    omit?: ProductFAQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFAQInclude<ExtArgs> | null
    /**
     * Filter, which ProductFAQ to fetch.
     */
    where: ProductFAQWhereUniqueInput
  }

  /**
   * ProductFAQ findFirst
   */
  export type ProductFAQFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFAQ
     */
    select?: ProductFAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFAQ
     */
    omit?: ProductFAQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFAQInclude<ExtArgs> | null
    /**
     * Filter, which ProductFAQ to fetch.
     */
    where?: ProductFAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductFAQS to fetch.
     */
    orderBy?: ProductFAQOrderByWithRelationInput | ProductFAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductFAQS.
     */
    cursor?: ProductFAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductFAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductFAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductFAQS.
     */
    distinct?: ProductFAQScalarFieldEnum | ProductFAQScalarFieldEnum[]
  }

  /**
   * ProductFAQ findFirstOrThrow
   */
  export type ProductFAQFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFAQ
     */
    select?: ProductFAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFAQ
     */
    omit?: ProductFAQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFAQInclude<ExtArgs> | null
    /**
     * Filter, which ProductFAQ to fetch.
     */
    where?: ProductFAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductFAQS to fetch.
     */
    orderBy?: ProductFAQOrderByWithRelationInput | ProductFAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductFAQS.
     */
    cursor?: ProductFAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductFAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductFAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductFAQS.
     */
    distinct?: ProductFAQScalarFieldEnum | ProductFAQScalarFieldEnum[]
  }

  /**
   * ProductFAQ findMany
   */
  export type ProductFAQFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFAQ
     */
    select?: ProductFAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFAQ
     */
    omit?: ProductFAQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFAQInclude<ExtArgs> | null
    /**
     * Filter, which ProductFAQS to fetch.
     */
    where?: ProductFAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductFAQS to fetch.
     */
    orderBy?: ProductFAQOrderByWithRelationInput | ProductFAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductFAQS.
     */
    cursor?: ProductFAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductFAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductFAQS.
     */
    skip?: number
    distinct?: ProductFAQScalarFieldEnum | ProductFAQScalarFieldEnum[]
  }

  /**
   * ProductFAQ create
   */
  export type ProductFAQCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFAQ
     */
    select?: ProductFAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFAQ
     */
    omit?: ProductFAQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFAQInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductFAQ.
     */
    data: XOR<ProductFAQCreateInput, ProductFAQUncheckedCreateInput>
  }

  /**
   * ProductFAQ createMany
   */
  export type ProductFAQCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductFAQS.
     */
    data: ProductFAQCreateManyInput | ProductFAQCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductFAQ createManyAndReturn
   */
  export type ProductFAQCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFAQ
     */
    select?: ProductFAQSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFAQ
     */
    omit?: ProductFAQOmit<ExtArgs> | null
    /**
     * The data used to create many ProductFAQS.
     */
    data: ProductFAQCreateManyInput | ProductFAQCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFAQIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductFAQ update
   */
  export type ProductFAQUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFAQ
     */
    select?: ProductFAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFAQ
     */
    omit?: ProductFAQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFAQInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductFAQ.
     */
    data: XOR<ProductFAQUpdateInput, ProductFAQUncheckedUpdateInput>
    /**
     * Choose, which ProductFAQ to update.
     */
    where: ProductFAQWhereUniqueInput
  }

  /**
   * ProductFAQ updateMany
   */
  export type ProductFAQUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductFAQS.
     */
    data: XOR<ProductFAQUpdateManyMutationInput, ProductFAQUncheckedUpdateManyInput>
    /**
     * Filter which ProductFAQS to update
     */
    where?: ProductFAQWhereInput
    /**
     * Limit how many ProductFAQS to update.
     */
    limit?: number
  }

  /**
   * ProductFAQ updateManyAndReturn
   */
  export type ProductFAQUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFAQ
     */
    select?: ProductFAQSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFAQ
     */
    omit?: ProductFAQOmit<ExtArgs> | null
    /**
     * The data used to update ProductFAQS.
     */
    data: XOR<ProductFAQUpdateManyMutationInput, ProductFAQUncheckedUpdateManyInput>
    /**
     * Filter which ProductFAQS to update
     */
    where?: ProductFAQWhereInput
    /**
     * Limit how many ProductFAQS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFAQIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductFAQ upsert
   */
  export type ProductFAQUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFAQ
     */
    select?: ProductFAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFAQ
     */
    omit?: ProductFAQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFAQInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductFAQ to update in case it exists.
     */
    where: ProductFAQWhereUniqueInput
    /**
     * In case the ProductFAQ found by the `where` argument doesn't exist, create a new ProductFAQ with this data.
     */
    create: XOR<ProductFAQCreateInput, ProductFAQUncheckedCreateInput>
    /**
     * In case the ProductFAQ was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductFAQUpdateInput, ProductFAQUncheckedUpdateInput>
  }

  /**
   * ProductFAQ delete
   */
  export type ProductFAQDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFAQ
     */
    select?: ProductFAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFAQ
     */
    omit?: ProductFAQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFAQInclude<ExtArgs> | null
    /**
     * Filter which ProductFAQ to delete.
     */
    where: ProductFAQWhereUniqueInput
  }

  /**
   * ProductFAQ deleteMany
   */
  export type ProductFAQDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductFAQS to delete
     */
    where?: ProductFAQWhereInput
    /**
     * Limit how many ProductFAQS to delete.
     */
    limit?: number
  }

  /**
   * ProductFAQ without action
   */
  export type ProductFAQDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFAQ
     */
    select?: ProductFAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFAQ
     */
    omit?: ProductFAQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFAQInclude<ExtArgs> | null
  }


  /**
   * Model AdCampaign
   */

  export type AggregateAdCampaign = {
    _count: AdCampaignCountAggregateOutputType | null
    _min: AdCampaignMinAggregateOutputType | null
    _max: AdCampaignMaxAggregateOutputType | null
  }

  export type AdCampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdCampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdCampaignCountAggregateOutputType = {
    id: number
    name: number
    description: number
    startDate: number
    endDate: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdCampaignMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdCampaignMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdCampaignCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdCampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdCampaign to aggregate.
     */
    where?: AdCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdCampaigns to fetch.
     */
    orderBy?: AdCampaignOrderByWithRelationInput | AdCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdCampaigns
    **/
    _count?: true | AdCampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdCampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdCampaignMaxAggregateInputType
  }

  export type GetAdCampaignAggregateType<T extends AdCampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateAdCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdCampaign[P]>
      : GetScalarType<T[P], AggregateAdCampaign[P]>
  }




  export type AdCampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdCampaignWhereInput
    orderBy?: AdCampaignOrderByWithAggregationInput | AdCampaignOrderByWithAggregationInput[]
    by: AdCampaignScalarFieldEnum[] | AdCampaignScalarFieldEnum
    having?: AdCampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdCampaignCountAggregateInputType | true
    _min?: AdCampaignMinAggregateInputType
    _max?: AdCampaignMaxAggregateInputType
  }

  export type AdCampaignGroupByOutputType = {
    id: string
    name: string
    description: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AdCampaignCountAggregateOutputType | null
    _min: AdCampaignMinAggregateOutputType | null
    _max: AdCampaignMaxAggregateOutputType | null
  }

  type GetAdCampaignGroupByPayload<T extends AdCampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdCampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdCampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdCampaignGroupByOutputType[P]>
            : GetScalarType<T[P], AdCampaignGroupByOutputType[P]>
        }
      >
    >


  export type AdCampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    blocks?: boolean | AdCampaign$blocksArgs<ExtArgs>
    _count?: boolean | AdCampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adCampaign"]>

  export type AdCampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adCampaign"]>

  export type AdCampaignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adCampaign"]>

  export type AdCampaignSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdCampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "startDate" | "endDate" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["adCampaign"]>
  export type AdCampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocks?: boolean | AdCampaign$blocksArgs<ExtArgs>
    _count?: boolean | AdCampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdCampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AdCampaignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdCampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdCampaign"
    objects: {
      blocks: Prisma.$AdBlockPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      startDate: Date | null
      endDate: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adCampaign"]>
    composites: {}
  }

  type AdCampaignGetPayload<S extends boolean | null | undefined | AdCampaignDefaultArgs> = $Result.GetResult<Prisma.$AdCampaignPayload, S>

  type AdCampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdCampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdCampaignCountAggregateInputType | true
    }

  export interface AdCampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdCampaign'], meta: { name: 'AdCampaign' } }
    /**
     * Find zero or one AdCampaign that matches the filter.
     * @param {AdCampaignFindUniqueArgs} args - Arguments to find a AdCampaign
     * @example
     * // Get one AdCampaign
     * const adCampaign = await prisma.adCampaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdCampaignFindUniqueArgs>(args: SelectSubset<T, AdCampaignFindUniqueArgs<ExtArgs>>): Prisma__AdCampaignClient<$Result.GetResult<Prisma.$AdCampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdCampaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdCampaignFindUniqueOrThrowArgs} args - Arguments to find a AdCampaign
     * @example
     * // Get one AdCampaign
     * const adCampaign = await prisma.adCampaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdCampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, AdCampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdCampaignClient<$Result.GetResult<Prisma.$AdCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdCampaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdCampaignFindFirstArgs} args - Arguments to find a AdCampaign
     * @example
     * // Get one AdCampaign
     * const adCampaign = await prisma.adCampaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdCampaignFindFirstArgs>(args?: SelectSubset<T, AdCampaignFindFirstArgs<ExtArgs>>): Prisma__AdCampaignClient<$Result.GetResult<Prisma.$AdCampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdCampaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdCampaignFindFirstOrThrowArgs} args - Arguments to find a AdCampaign
     * @example
     * // Get one AdCampaign
     * const adCampaign = await prisma.adCampaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdCampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, AdCampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdCampaignClient<$Result.GetResult<Prisma.$AdCampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdCampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdCampaigns
     * const adCampaigns = await prisma.adCampaign.findMany()
     * 
     * // Get first 10 AdCampaigns
     * const adCampaigns = await prisma.adCampaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adCampaignWithIdOnly = await prisma.adCampaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdCampaignFindManyArgs>(args?: SelectSubset<T, AdCampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdCampaign.
     * @param {AdCampaignCreateArgs} args - Arguments to create a AdCampaign.
     * @example
     * // Create one AdCampaign
     * const AdCampaign = await prisma.adCampaign.create({
     *   data: {
     *     // ... data to create a AdCampaign
     *   }
     * })
     * 
     */
    create<T extends AdCampaignCreateArgs>(args: SelectSubset<T, AdCampaignCreateArgs<ExtArgs>>): Prisma__AdCampaignClient<$Result.GetResult<Prisma.$AdCampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdCampaigns.
     * @param {AdCampaignCreateManyArgs} args - Arguments to create many AdCampaigns.
     * @example
     * // Create many AdCampaigns
     * const adCampaign = await prisma.adCampaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdCampaignCreateManyArgs>(args?: SelectSubset<T, AdCampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdCampaigns and returns the data saved in the database.
     * @param {AdCampaignCreateManyAndReturnArgs} args - Arguments to create many AdCampaigns.
     * @example
     * // Create many AdCampaigns
     * const adCampaign = await prisma.adCampaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdCampaigns and only return the `id`
     * const adCampaignWithIdOnly = await prisma.adCampaign.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdCampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, AdCampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdCampaignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdCampaign.
     * @param {AdCampaignDeleteArgs} args - Arguments to delete one AdCampaign.
     * @example
     * // Delete one AdCampaign
     * const AdCampaign = await prisma.adCampaign.delete({
     *   where: {
     *     // ... filter to delete one AdCampaign
     *   }
     * })
     * 
     */
    delete<T extends AdCampaignDeleteArgs>(args: SelectSubset<T, AdCampaignDeleteArgs<ExtArgs>>): Prisma__AdCampaignClient<$Result.GetResult<Prisma.$AdCampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdCampaign.
     * @param {AdCampaignUpdateArgs} args - Arguments to update one AdCampaign.
     * @example
     * // Update one AdCampaign
     * const adCampaign = await prisma.adCampaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdCampaignUpdateArgs>(args: SelectSubset<T, AdCampaignUpdateArgs<ExtArgs>>): Prisma__AdCampaignClient<$Result.GetResult<Prisma.$AdCampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdCampaigns.
     * @param {AdCampaignDeleteManyArgs} args - Arguments to filter AdCampaigns to delete.
     * @example
     * // Delete a few AdCampaigns
     * const { count } = await prisma.adCampaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdCampaignDeleteManyArgs>(args?: SelectSubset<T, AdCampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdCampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdCampaigns
     * const adCampaign = await prisma.adCampaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdCampaignUpdateManyArgs>(args: SelectSubset<T, AdCampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdCampaigns and returns the data updated in the database.
     * @param {AdCampaignUpdateManyAndReturnArgs} args - Arguments to update many AdCampaigns.
     * @example
     * // Update many AdCampaigns
     * const adCampaign = await prisma.adCampaign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdCampaigns and only return the `id`
     * const adCampaignWithIdOnly = await prisma.adCampaign.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdCampaignUpdateManyAndReturnArgs>(args: SelectSubset<T, AdCampaignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdCampaignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdCampaign.
     * @param {AdCampaignUpsertArgs} args - Arguments to update or create a AdCampaign.
     * @example
     * // Update or create a AdCampaign
     * const adCampaign = await prisma.adCampaign.upsert({
     *   create: {
     *     // ... data to create a AdCampaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdCampaign we want to update
     *   }
     * })
     */
    upsert<T extends AdCampaignUpsertArgs>(args: SelectSubset<T, AdCampaignUpsertArgs<ExtArgs>>): Prisma__AdCampaignClient<$Result.GetResult<Prisma.$AdCampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdCampaignCountArgs} args - Arguments to filter AdCampaigns to count.
     * @example
     * // Count the number of AdCampaigns
     * const count = await prisma.adCampaign.count({
     *   where: {
     *     // ... the filter for the AdCampaigns we want to count
     *   }
     * })
    **/
    count<T extends AdCampaignCountArgs>(
      args?: Subset<T, AdCampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdCampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdCampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdCampaignAggregateArgs>(args: Subset<T, AdCampaignAggregateArgs>): Prisma.PrismaPromise<GetAdCampaignAggregateType<T>>

    /**
     * Group by AdCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdCampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdCampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdCampaignGroupByArgs['orderBy'] }
        : { orderBy?: AdCampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdCampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdCampaign model
   */
  readonly fields: AdCampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdCampaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdCampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blocks<T extends AdCampaign$blocksArgs<ExtArgs> = {}>(args?: Subset<T, AdCampaign$blocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdCampaign model
   */
  interface AdCampaignFieldRefs {
    readonly id: FieldRef<"AdCampaign", 'String'>
    readonly name: FieldRef<"AdCampaign", 'String'>
    readonly description: FieldRef<"AdCampaign", 'String'>
    readonly startDate: FieldRef<"AdCampaign", 'DateTime'>
    readonly endDate: FieldRef<"AdCampaign", 'DateTime'>
    readonly isActive: FieldRef<"AdCampaign", 'Boolean'>
    readonly createdAt: FieldRef<"AdCampaign", 'DateTime'>
    readonly updatedAt: FieldRef<"AdCampaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdCampaign findUnique
   */
  export type AdCampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdCampaign
     */
    select?: AdCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdCampaign
     */
    omit?: AdCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdCampaignInclude<ExtArgs> | null
    /**
     * Filter, which AdCampaign to fetch.
     */
    where: AdCampaignWhereUniqueInput
  }

  /**
   * AdCampaign findUniqueOrThrow
   */
  export type AdCampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdCampaign
     */
    select?: AdCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdCampaign
     */
    omit?: AdCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdCampaignInclude<ExtArgs> | null
    /**
     * Filter, which AdCampaign to fetch.
     */
    where: AdCampaignWhereUniqueInput
  }

  /**
   * AdCampaign findFirst
   */
  export type AdCampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdCampaign
     */
    select?: AdCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdCampaign
     */
    omit?: AdCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdCampaignInclude<ExtArgs> | null
    /**
     * Filter, which AdCampaign to fetch.
     */
    where?: AdCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdCampaigns to fetch.
     */
    orderBy?: AdCampaignOrderByWithRelationInput | AdCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdCampaigns.
     */
    cursor?: AdCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdCampaigns.
     */
    distinct?: AdCampaignScalarFieldEnum | AdCampaignScalarFieldEnum[]
  }

  /**
   * AdCampaign findFirstOrThrow
   */
  export type AdCampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdCampaign
     */
    select?: AdCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdCampaign
     */
    omit?: AdCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdCampaignInclude<ExtArgs> | null
    /**
     * Filter, which AdCampaign to fetch.
     */
    where?: AdCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdCampaigns to fetch.
     */
    orderBy?: AdCampaignOrderByWithRelationInput | AdCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdCampaigns.
     */
    cursor?: AdCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdCampaigns.
     */
    distinct?: AdCampaignScalarFieldEnum | AdCampaignScalarFieldEnum[]
  }

  /**
   * AdCampaign findMany
   */
  export type AdCampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdCampaign
     */
    select?: AdCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdCampaign
     */
    omit?: AdCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdCampaignInclude<ExtArgs> | null
    /**
     * Filter, which AdCampaigns to fetch.
     */
    where?: AdCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdCampaigns to fetch.
     */
    orderBy?: AdCampaignOrderByWithRelationInput | AdCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdCampaigns.
     */
    cursor?: AdCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdCampaigns.
     */
    skip?: number
    distinct?: AdCampaignScalarFieldEnum | AdCampaignScalarFieldEnum[]
  }

  /**
   * AdCampaign create
   */
  export type AdCampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdCampaign
     */
    select?: AdCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdCampaign
     */
    omit?: AdCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdCampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a AdCampaign.
     */
    data: XOR<AdCampaignCreateInput, AdCampaignUncheckedCreateInput>
  }

  /**
   * AdCampaign createMany
   */
  export type AdCampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdCampaigns.
     */
    data: AdCampaignCreateManyInput | AdCampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdCampaign createManyAndReturn
   */
  export type AdCampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdCampaign
     */
    select?: AdCampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdCampaign
     */
    omit?: AdCampaignOmit<ExtArgs> | null
    /**
     * The data used to create many AdCampaigns.
     */
    data: AdCampaignCreateManyInput | AdCampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdCampaign update
   */
  export type AdCampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdCampaign
     */
    select?: AdCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdCampaign
     */
    omit?: AdCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdCampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a AdCampaign.
     */
    data: XOR<AdCampaignUpdateInput, AdCampaignUncheckedUpdateInput>
    /**
     * Choose, which AdCampaign to update.
     */
    where: AdCampaignWhereUniqueInput
  }

  /**
   * AdCampaign updateMany
   */
  export type AdCampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdCampaigns.
     */
    data: XOR<AdCampaignUpdateManyMutationInput, AdCampaignUncheckedUpdateManyInput>
    /**
     * Filter which AdCampaigns to update
     */
    where?: AdCampaignWhereInput
    /**
     * Limit how many AdCampaigns to update.
     */
    limit?: number
  }

  /**
   * AdCampaign updateManyAndReturn
   */
  export type AdCampaignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdCampaign
     */
    select?: AdCampaignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdCampaign
     */
    omit?: AdCampaignOmit<ExtArgs> | null
    /**
     * The data used to update AdCampaigns.
     */
    data: XOR<AdCampaignUpdateManyMutationInput, AdCampaignUncheckedUpdateManyInput>
    /**
     * Filter which AdCampaigns to update
     */
    where?: AdCampaignWhereInput
    /**
     * Limit how many AdCampaigns to update.
     */
    limit?: number
  }

  /**
   * AdCampaign upsert
   */
  export type AdCampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdCampaign
     */
    select?: AdCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdCampaign
     */
    omit?: AdCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdCampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the AdCampaign to update in case it exists.
     */
    where: AdCampaignWhereUniqueInput
    /**
     * In case the AdCampaign found by the `where` argument doesn't exist, create a new AdCampaign with this data.
     */
    create: XOR<AdCampaignCreateInput, AdCampaignUncheckedCreateInput>
    /**
     * In case the AdCampaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdCampaignUpdateInput, AdCampaignUncheckedUpdateInput>
  }

  /**
   * AdCampaign delete
   */
  export type AdCampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdCampaign
     */
    select?: AdCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdCampaign
     */
    omit?: AdCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdCampaignInclude<ExtArgs> | null
    /**
     * Filter which AdCampaign to delete.
     */
    where: AdCampaignWhereUniqueInput
  }

  /**
   * AdCampaign deleteMany
   */
  export type AdCampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdCampaigns to delete
     */
    where?: AdCampaignWhereInput
    /**
     * Limit how many AdCampaigns to delete.
     */
    limit?: number
  }

  /**
   * AdCampaign.blocks
   */
  export type AdCampaign$blocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdBlock
     */
    select?: AdBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdBlock
     */
    omit?: AdBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdBlockInclude<ExtArgs> | null
    where?: AdBlockWhereInput
    orderBy?: AdBlockOrderByWithRelationInput | AdBlockOrderByWithRelationInput[]
    cursor?: AdBlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdBlockScalarFieldEnum | AdBlockScalarFieldEnum[]
  }

  /**
   * AdCampaign without action
   */
  export type AdCampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdCampaign
     */
    select?: AdCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdCampaign
     */
    omit?: AdCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdCampaignInclude<ExtArgs> | null
  }


  /**
   * Model AdBlock
   */

  export type AggregateAdBlock = {
    _count: AdBlockCountAggregateOutputType | null
    _avg: AdBlockAvgAggregateOutputType | null
    _sum: AdBlockSumAggregateOutputType | null
    _min: AdBlockMinAggregateOutputType | null
    _max: AdBlockMaxAggregateOutputType | null
  }

  export type AdBlockAvgAggregateOutputType = {
    referenceCount: number | null
    minWords: number | null
  }

  export type AdBlockSumAggregateOutputType = {
    referenceCount: number | null
    minWords: number | null
  }

  export type AdBlockMinAggregateOutputType = {
    id: string | null
    label: string | null
    layoutType: $Enums.AdLayoutType | null
    isActive: boolean | null
    campaignId: string | null
    placement: $Enums.AdPositionPlacement | null
    reference: $Enums.AdPositionReference | null
    referenceCount: number | null
    minWords: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdBlockMaxAggregateOutputType = {
    id: string | null
    label: string | null
    layoutType: $Enums.AdLayoutType | null
    isActive: boolean | null
    campaignId: string | null
    placement: $Enums.AdPositionPlacement | null
    reference: $Enums.AdPositionReference | null
    referenceCount: number | null
    minWords: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdBlockCountAggregateOutputType = {
    id: number
    label: number
    layoutType: number
    isActive: number
    campaignId: number
    placement: number
    reference: number
    referenceCount: number
    minWords: number
    excludedPostIds: number
    excludedCategoryIds: number
    excludedTagIds: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdBlockAvgAggregateInputType = {
    referenceCount?: true
    minWords?: true
  }

  export type AdBlockSumAggregateInputType = {
    referenceCount?: true
    minWords?: true
  }

  export type AdBlockMinAggregateInputType = {
    id?: true
    label?: true
    layoutType?: true
    isActive?: true
    campaignId?: true
    placement?: true
    reference?: true
    referenceCount?: true
    minWords?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdBlockMaxAggregateInputType = {
    id?: true
    label?: true
    layoutType?: true
    isActive?: true
    campaignId?: true
    placement?: true
    reference?: true
    referenceCount?: true
    minWords?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdBlockCountAggregateInputType = {
    id?: true
    label?: true
    layoutType?: true
    isActive?: true
    campaignId?: true
    placement?: true
    reference?: true
    referenceCount?: true
    minWords?: true
    excludedPostIds?: true
    excludedCategoryIds?: true
    excludedTagIds?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdBlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdBlock to aggregate.
     */
    where?: AdBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdBlocks to fetch.
     */
    orderBy?: AdBlockOrderByWithRelationInput | AdBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdBlocks
    **/
    _count?: true | AdBlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdBlockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdBlockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdBlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdBlockMaxAggregateInputType
  }

  export type GetAdBlockAggregateType<T extends AdBlockAggregateArgs> = {
        [P in keyof T & keyof AggregateAdBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdBlock[P]>
      : GetScalarType<T[P], AggregateAdBlock[P]>
  }




  export type AdBlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdBlockWhereInput
    orderBy?: AdBlockOrderByWithAggregationInput | AdBlockOrderByWithAggregationInput[]
    by: AdBlockScalarFieldEnum[] | AdBlockScalarFieldEnum
    having?: AdBlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdBlockCountAggregateInputType | true
    _avg?: AdBlockAvgAggregateInputType
    _sum?: AdBlockSumAggregateInputType
    _min?: AdBlockMinAggregateInputType
    _max?: AdBlockMaxAggregateInputType
  }

  export type AdBlockGroupByOutputType = {
    id: string
    label: string
    layoutType: $Enums.AdLayoutType
    isActive: boolean
    campaignId: string
    placement: $Enums.AdPositionPlacement
    reference: $Enums.AdPositionReference
    referenceCount: number
    minWords: number
    excludedPostIds: string[]
    excludedCategoryIds: string[]
    excludedTagIds: string[]
    createdAt: Date
    updatedAt: Date
    _count: AdBlockCountAggregateOutputType | null
    _avg: AdBlockAvgAggregateOutputType | null
    _sum: AdBlockSumAggregateOutputType | null
    _min: AdBlockMinAggregateOutputType | null
    _max: AdBlockMaxAggregateOutputType | null
  }

  type GetAdBlockGroupByPayload<T extends AdBlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdBlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdBlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdBlockGroupByOutputType[P]>
            : GetScalarType<T[P], AdBlockGroupByOutputType[P]>
        }
      >
    >


  export type AdBlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    layoutType?: boolean
    isActive?: boolean
    campaignId?: boolean
    placement?: boolean
    reference?: boolean
    referenceCount?: boolean
    minWords?: boolean
    excludedPostIds?: boolean
    excludedCategoryIds?: boolean
    excludedTagIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | AdCampaignDefaultArgs<ExtArgs>
    items?: boolean | AdBlock$itemsArgs<ExtArgs>
    _count?: boolean | AdBlockCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adBlock"]>

  export type AdBlockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    layoutType?: boolean
    isActive?: boolean
    campaignId?: boolean
    placement?: boolean
    reference?: boolean
    referenceCount?: boolean
    minWords?: boolean
    excludedPostIds?: boolean
    excludedCategoryIds?: boolean
    excludedTagIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | AdCampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adBlock"]>

  export type AdBlockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    layoutType?: boolean
    isActive?: boolean
    campaignId?: boolean
    placement?: boolean
    reference?: boolean
    referenceCount?: boolean
    minWords?: boolean
    excludedPostIds?: boolean
    excludedCategoryIds?: boolean
    excludedTagIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | AdCampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adBlock"]>

  export type AdBlockSelectScalar = {
    id?: boolean
    label?: boolean
    layoutType?: boolean
    isActive?: boolean
    campaignId?: boolean
    placement?: boolean
    reference?: boolean
    referenceCount?: boolean
    minWords?: boolean
    excludedPostIds?: boolean
    excludedCategoryIds?: boolean
    excludedTagIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdBlockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "layoutType" | "isActive" | "campaignId" | "placement" | "reference" | "referenceCount" | "minWords" | "excludedPostIds" | "excludedCategoryIds" | "excludedTagIds" | "createdAt" | "updatedAt", ExtArgs["result"]["adBlock"]>
  export type AdBlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | AdCampaignDefaultArgs<ExtArgs>
    items?: boolean | AdBlock$itemsArgs<ExtArgs>
    _count?: boolean | AdBlockCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdBlockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | AdCampaignDefaultArgs<ExtArgs>
  }
  export type AdBlockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | AdCampaignDefaultArgs<ExtArgs>
  }

  export type $AdBlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdBlock"
    objects: {
      campaign: Prisma.$AdCampaignPayload<ExtArgs>
      items: Prisma.$AdItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      label: string
      layoutType: $Enums.AdLayoutType
      isActive: boolean
      campaignId: string
      placement: $Enums.AdPositionPlacement
      reference: $Enums.AdPositionReference
      referenceCount: number
      minWords: number
      excludedPostIds: string[]
      excludedCategoryIds: string[]
      excludedTagIds: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adBlock"]>
    composites: {}
  }

  type AdBlockGetPayload<S extends boolean | null | undefined | AdBlockDefaultArgs> = $Result.GetResult<Prisma.$AdBlockPayload, S>

  type AdBlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdBlockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdBlockCountAggregateInputType | true
    }

  export interface AdBlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdBlock'], meta: { name: 'AdBlock' } }
    /**
     * Find zero or one AdBlock that matches the filter.
     * @param {AdBlockFindUniqueArgs} args - Arguments to find a AdBlock
     * @example
     * // Get one AdBlock
     * const adBlock = await prisma.adBlock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdBlockFindUniqueArgs>(args: SelectSubset<T, AdBlockFindUniqueArgs<ExtArgs>>): Prisma__AdBlockClient<$Result.GetResult<Prisma.$AdBlockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdBlock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdBlockFindUniqueOrThrowArgs} args - Arguments to find a AdBlock
     * @example
     * // Get one AdBlock
     * const adBlock = await prisma.adBlock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdBlockFindUniqueOrThrowArgs>(args: SelectSubset<T, AdBlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdBlockClient<$Result.GetResult<Prisma.$AdBlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdBlock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdBlockFindFirstArgs} args - Arguments to find a AdBlock
     * @example
     * // Get one AdBlock
     * const adBlock = await prisma.adBlock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdBlockFindFirstArgs>(args?: SelectSubset<T, AdBlockFindFirstArgs<ExtArgs>>): Prisma__AdBlockClient<$Result.GetResult<Prisma.$AdBlockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdBlock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdBlockFindFirstOrThrowArgs} args - Arguments to find a AdBlock
     * @example
     * // Get one AdBlock
     * const adBlock = await prisma.adBlock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdBlockFindFirstOrThrowArgs>(args?: SelectSubset<T, AdBlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdBlockClient<$Result.GetResult<Prisma.$AdBlockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdBlocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdBlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdBlocks
     * const adBlocks = await prisma.adBlock.findMany()
     * 
     * // Get first 10 AdBlocks
     * const adBlocks = await prisma.adBlock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adBlockWithIdOnly = await prisma.adBlock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdBlockFindManyArgs>(args?: SelectSubset<T, AdBlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdBlock.
     * @param {AdBlockCreateArgs} args - Arguments to create a AdBlock.
     * @example
     * // Create one AdBlock
     * const AdBlock = await prisma.adBlock.create({
     *   data: {
     *     // ... data to create a AdBlock
     *   }
     * })
     * 
     */
    create<T extends AdBlockCreateArgs>(args: SelectSubset<T, AdBlockCreateArgs<ExtArgs>>): Prisma__AdBlockClient<$Result.GetResult<Prisma.$AdBlockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdBlocks.
     * @param {AdBlockCreateManyArgs} args - Arguments to create many AdBlocks.
     * @example
     * // Create many AdBlocks
     * const adBlock = await prisma.adBlock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdBlockCreateManyArgs>(args?: SelectSubset<T, AdBlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdBlocks and returns the data saved in the database.
     * @param {AdBlockCreateManyAndReturnArgs} args - Arguments to create many AdBlocks.
     * @example
     * // Create many AdBlocks
     * const adBlock = await prisma.adBlock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdBlocks and only return the `id`
     * const adBlockWithIdOnly = await prisma.adBlock.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdBlockCreateManyAndReturnArgs>(args?: SelectSubset<T, AdBlockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdBlockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdBlock.
     * @param {AdBlockDeleteArgs} args - Arguments to delete one AdBlock.
     * @example
     * // Delete one AdBlock
     * const AdBlock = await prisma.adBlock.delete({
     *   where: {
     *     // ... filter to delete one AdBlock
     *   }
     * })
     * 
     */
    delete<T extends AdBlockDeleteArgs>(args: SelectSubset<T, AdBlockDeleteArgs<ExtArgs>>): Prisma__AdBlockClient<$Result.GetResult<Prisma.$AdBlockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdBlock.
     * @param {AdBlockUpdateArgs} args - Arguments to update one AdBlock.
     * @example
     * // Update one AdBlock
     * const adBlock = await prisma.adBlock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdBlockUpdateArgs>(args: SelectSubset<T, AdBlockUpdateArgs<ExtArgs>>): Prisma__AdBlockClient<$Result.GetResult<Prisma.$AdBlockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdBlocks.
     * @param {AdBlockDeleteManyArgs} args - Arguments to filter AdBlocks to delete.
     * @example
     * // Delete a few AdBlocks
     * const { count } = await prisma.adBlock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdBlockDeleteManyArgs>(args?: SelectSubset<T, AdBlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdBlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdBlocks
     * const adBlock = await prisma.adBlock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdBlockUpdateManyArgs>(args: SelectSubset<T, AdBlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdBlocks and returns the data updated in the database.
     * @param {AdBlockUpdateManyAndReturnArgs} args - Arguments to update many AdBlocks.
     * @example
     * // Update many AdBlocks
     * const adBlock = await prisma.adBlock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdBlocks and only return the `id`
     * const adBlockWithIdOnly = await prisma.adBlock.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdBlockUpdateManyAndReturnArgs>(args: SelectSubset<T, AdBlockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdBlockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdBlock.
     * @param {AdBlockUpsertArgs} args - Arguments to update or create a AdBlock.
     * @example
     * // Update or create a AdBlock
     * const adBlock = await prisma.adBlock.upsert({
     *   create: {
     *     // ... data to create a AdBlock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdBlock we want to update
     *   }
     * })
     */
    upsert<T extends AdBlockUpsertArgs>(args: SelectSubset<T, AdBlockUpsertArgs<ExtArgs>>): Prisma__AdBlockClient<$Result.GetResult<Prisma.$AdBlockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdBlockCountArgs} args - Arguments to filter AdBlocks to count.
     * @example
     * // Count the number of AdBlocks
     * const count = await prisma.adBlock.count({
     *   where: {
     *     // ... the filter for the AdBlocks we want to count
     *   }
     * })
    **/
    count<T extends AdBlockCountArgs>(
      args?: Subset<T, AdBlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdBlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdBlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdBlockAggregateArgs>(args: Subset<T, AdBlockAggregateArgs>): Prisma.PrismaPromise<GetAdBlockAggregateType<T>>

    /**
     * Group by AdBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdBlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdBlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdBlockGroupByArgs['orderBy'] }
        : { orderBy?: AdBlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdBlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdBlock model
   */
  readonly fields: AdBlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdBlock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdBlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends AdCampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdCampaignDefaultArgs<ExtArgs>>): Prisma__AdCampaignClient<$Result.GetResult<Prisma.$AdCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends AdBlock$itemsArgs<ExtArgs> = {}>(args?: Subset<T, AdBlock$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdBlock model
   */
  interface AdBlockFieldRefs {
    readonly id: FieldRef<"AdBlock", 'String'>
    readonly label: FieldRef<"AdBlock", 'String'>
    readonly layoutType: FieldRef<"AdBlock", 'AdLayoutType'>
    readonly isActive: FieldRef<"AdBlock", 'Boolean'>
    readonly campaignId: FieldRef<"AdBlock", 'String'>
    readonly placement: FieldRef<"AdBlock", 'AdPositionPlacement'>
    readonly reference: FieldRef<"AdBlock", 'AdPositionReference'>
    readonly referenceCount: FieldRef<"AdBlock", 'Int'>
    readonly minWords: FieldRef<"AdBlock", 'Int'>
    readonly excludedPostIds: FieldRef<"AdBlock", 'String[]'>
    readonly excludedCategoryIds: FieldRef<"AdBlock", 'String[]'>
    readonly excludedTagIds: FieldRef<"AdBlock", 'String[]'>
    readonly createdAt: FieldRef<"AdBlock", 'DateTime'>
    readonly updatedAt: FieldRef<"AdBlock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdBlock findUnique
   */
  export type AdBlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdBlock
     */
    select?: AdBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdBlock
     */
    omit?: AdBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdBlockInclude<ExtArgs> | null
    /**
     * Filter, which AdBlock to fetch.
     */
    where: AdBlockWhereUniqueInput
  }

  /**
   * AdBlock findUniqueOrThrow
   */
  export type AdBlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdBlock
     */
    select?: AdBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdBlock
     */
    omit?: AdBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdBlockInclude<ExtArgs> | null
    /**
     * Filter, which AdBlock to fetch.
     */
    where: AdBlockWhereUniqueInput
  }

  /**
   * AdBlock findFirst
   */
  export type AdBlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdBlock
     */
    select?: AdBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdBlock
     */
    omit?: AdBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdBlockInclude<ExtArgs> | null
    /**
     * Filter, which AdBlock to fetch.
     */
    where?: AdBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdBlocks to fetch.
     */
    orderBy?: AdBlockOrderByWithRelationInput | AdBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdBlocks.
     */
    cursor?: AdBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdBlocks.
     */
    distinct?: AdBlockScalarFieldEnum | AdBlockScalarFieldEnum[]
  }

  /**
   * AdBlock findFirstOrThrow
   */
  export type AdBlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdBlock
     */
    select?: AdBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdBlock
     */
    omit?: AdBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdBlockInclude<ExtArgs> | null
    /**
     * Filter, which AdBlock to fetch.
     */
    where?: AdBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdBlocks to fetch.
     */
    orderBy?: AdBlockOrderByWithRelationInput | AdBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdBlocks.
     */
    cursor?: AdBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdBlocks.
     */
    distinct?: AdBlockScalarFieldEnum | AdBlockScalarFieldEnum[]
  }

  /**
   * AdBlock findMany
   */
  export type AdBlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdBlock
     */
    select?: AdBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdBlock
     */
    omit?: AdBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdBlockInclude<ExtArgs> | null
    /**
     * Filter, which AdBlocks to fetch.
     */
    where?: AdBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdBlocks to fetch.
     */
    orderBy?: AdBlockOrderByWithRelationInput | AdBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdBlocks.
     */
    cursor?: AdBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdBlocks.
     */
    skip?: number
    distinct?: AdBlockScalarFieldEnum | AdBlockScalarFieldEnum[]
  }

  /**
   * AdBlock create
   */
  export type AdBlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdBlock
     */
    select?: AdBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdBlock
     */
    omit?: AdBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdBlockInclude<ExtArgs> | null
    /**
     * The data needed to create a AdBlock.
     */
    data: XOR<AdBlockCreateInput, AdBlockUncheckedCreateInput>
  }

  /**
   * AdBlock createMany
   */
  export type AdBlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdBlocks.
     */
    data: AdBlockCreateManyInput | AdBlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdBlock createManyAndReturn
   */
  export type AdBlockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdBlock
     */
    select?: AdBlockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdBlock
     */
    omit?: AdBlockOmit<ExtArgs> | null
    /**
     * The data used to create many AdBlocks.
     */
    data: AdBlockCreateManyInput | AdBlockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdBlockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdBlock update
   */
  export type AdBlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdBlock
     */
    select?: AdBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdBlock
     */
    omit?: AdBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdBlockInclude<ExtArgs> | null
    /**
     * The data needed to update a AdBlock.
     */
    data: XOR<AdBlockUpdateInput, AdBlockUncheckedUpdateInput>
    /**
     * Choose, which AdBlock to update.
     */
    where: AdBlockWhereUniqueInput
  }

  /**
   * AdBlock updateMany
   */
  export type AdBlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdBlocks.
     */
    data: XOR<AdBlockUpdateManyMutationInput, AdBlockUncheckedUpdateManyInput>
    /**
     * Filter which AdBlocks to update
     */
    where?: AdBlockWhereInput
    /**
     * Limit how many AdBlocks to update.
     */
    limit?: number
  }

  /**
   * AdBlock updateManyAndReturn
   */
  export type AdBlockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdBlock
     */
    select?: AdBlockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdBlock
     */
    omit?: AdBlockOmit<ExtArgs> | null
    /**
     * The data used to update AdBlocks.
     */
    data: XOR<AdBlockUpdateManyMutationInput, AdBlockUncheckedUpdateManyInput>
    /**
     * Filter which AdBlocks to update
     */
    where?: AdBlockWhereInput
    /**
     * Limit how many AdBlocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdBlockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdBlock upsert
   */
  export type AdBlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdBlock
     */
    select?: AdBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdBlock
     */
    omit?: AdBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdBlockInclude<ExtArgs> | null
    /**
     * The filter to search for the AdBlock to update in case it exists.
     */
    where: AdBlockWhereUniqueInput
    /**
     * In case the AdBlock found by the `where` argument doesn't exist, create a new AdBlock with this data.
     */
    create: XOR<AdBlockCreateInput, AdBlockUncheckedCreateInput>
    /**
     * In case the AdBlock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdBlockUpdateInput, AdBlockUncheckedUpdateInput>
  }

  /**
   * AdBlock delete
   */
  export type AdBlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdBlock
     */
    select?: AdBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdBlock
     */
    omit?: AdBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdBlockInclude<ExtArgs> | null
    /**
     * Filter which AdBlock to delete.
     */
    where: AdBlockWhereUniqueInput
  }

  /**
   * AdBlock deleteMany
   */
  export type AdBlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdBlocks to delete
     */
    where?: AdBlockWhereInput
    /**
     * Limit how many AdBlocks to delete.
     */
    limit?: number
  }

  /**
   * AdBlock.items
   */
  export type AdBlock$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdItem
     */
    select?: AdItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdItem
     */
    omit?: AdItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdItemInclude<ExtArgs> | null
    where?: AdItemWhereInput
    orderBy?: AdItemOrderByWithRelationInput | AdItemOrderByWithRelationInput[]
    cursor?: AdItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdItemScalarFieldEnum | AdItemScalarFieldEnum[]
  }

  /**
   * AdBlock without action
   */
  export type AdBlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdBlock
     */
    select?: AdBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdBlock
     */
    omit?: AdBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdBlockInclude<ExtArgs> | null
  }


  /**
   * Model AdItem
   */

  export type AggregateAdItem = {
    _count: AdItemCountAggregateOutputType | null
    _avg: AdItemAvgAggregateOutputType | null
    _sum: AdItemSumAggregateOutputType | null
    _min: AdItemMinAggregateOutputType | null
    _max: AdItemMaxAggregateOutputType | null
  }

  export type AdItemAvgAggregateOutputType = {
    sort: number | null
  }

  export type AdItemSumAggregateOutputType = {
    sort: number | null
  }

  export type AdItemMinAggregateOutputType = {
    id: string | null
    sourceType: $Enums.AdItemSourceType | null
    adBlockId: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    url: string | null
    postRootId: string | null
    productRootId: string | null
    sort: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdItemMaxAggregateOutputType = {
    id: string | null
    sourceType: $Enums.AdItemSourceType | null
    adBlockId: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    url: string | null
    postRootId: string | null
    productRootId: string | null
    sort: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdItemCountAggregateOutputType = {
    id: number
    sourceType: number
    adBlockId: number
    title: number
    description: number
    imageUrl: number
    url: number
    postRootId: number
    productRootId: number
    sort: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdItemAvgAggregateInputType = {
    sort?: true
  }

  export type AdItemSumAggregateInputType = {
    sort?: true
  }

  export type AdItemMinAggregateInputType = {
    id?: true
    sourceType?: true
    adBlockId?: true
    title?: true
    description?: true
    imageUrl?: true
    url?: true
    postRootId?: true
    productRootId?: true
    sort?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdItemMaxAggregateInputType = {
    id?: true
    sourceType?: true
    adBlockId?: true
    title?: true
    description?: true
    imageUrl?: true
    url?: true
    postRootId?: true
    productRootId?: true
    sort?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdItemCountAggregateInputType = {
    id?: true
    sourceType?: true
    adBlockId?: true
    title?: true
    description?: true
    imageUrl?: true
    url?: true
    postRootId?: true
    productRootId?: true
    sort?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdItem to aggregate.
     */
    where?: AdItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdItems to fetch.
     */
    orderBy?: AdItemOrderByWithRelationInput | AdItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdItems
    **/
    _count?: true | AdItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdItemMaxAggregateInputType
  }

  export type GetAdItemAggregateType<T extends AdItemAggregateArgs> = {
        [P in keyof T & keyof AggregateAdItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdItem[P]>
      : GetScalarType<T[P], AggregateAdItem[P]>
  }




  export type AdItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdItemWhereInput
    orderBy?: AdItemOrderByWithAggregationInput | AdItemOrderByWithAggregationInput[]
    by: AdItemScalarFieldEnum[] | AdItemScalarFieldEnum
    having?: AdItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdItemCountAggregateInputType | true
    _avg?: AdItemAvgAggregateInputType
    _sum?: AdItemSumAggregateInputType
    _min?: AdItemMinAggregateInputType
    _max?: AdItemMaxAggregateInputType
  }

  export type AdItemGroupByOutputType = {
    id: string
    sourceType: $Enums.AdItemSourceType
    adBlockId: string
    title: string | null
    description: string | null
    imageUrl: string | null
    url: string | null
    postRootId: string | null
    productRootId: string | null
    sort: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AdItemCountAggregateOutputType | null
    _avg: AdItemAvgAggregateOutputType | null
    _sum: AdItemSumAggregateOutputType | null
    _min: AdItemMinAggregateOutputType | null
    _max: AdItemMaxAggregateOutputType | null
  }

  type GetAdItemGroupByPayload<T extends AdItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdItemGroupByOutputType[P]>
            : GetScalarType<T[P], AdItemGroupByOutputType[P]>
        }
      >
    >


  export type AdItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceType?: boolean
    adBlockId?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    url?: boolean
    postRootId?: boolean
    productRootId?: boolean
    sort?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adBlock?: boolean | AdBlockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adItem"]>

  export type AdItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceType?: boolean
    adBlockId?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    url?: boolean
    postRootId?: boolean
    productRootId?: boolean
    sort?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adBlock?: boolean | AdBlockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adItem"]>

  export type AdItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceType?: boolean
    adBlockId?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    url?: boolean
    postRootId?: boolean
    productRootId?: boolean
    sort?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adBlock?: boolean | AdBlockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adItem"]>

  export type AdItemSelectScalar = {
    id?: boolean
    sourceType?: boolean
    adBlockId?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    url?: boolean
    postRootId?: boolean
    productRootId?: boolean
    sort?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sourceType" | "adBlockId" | "title" | "description" | "imageUrl" | "url" | "postRootId" | "productRootId" | "sort" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["adItem"]>
  export type AdItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adBlock?: boolean | AdBlockDefaultArgs<ExtArgs>
  }
  export type AdItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adBlock?: boolean | AdBlockDefaultArgs<ExtArgs>
  }
  export type AdItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adBlock?: boolean | AdBlockDefaultArgs<ExtArgs>
  }

  export type $AdItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdItem"
    objects: {
      adBlock: Prisma.$AdBlockPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sourceType: $Enums.AdItemSourceType
      adBlockId: string
      title: string | null
      description: string | null
      imageUrl: string | null
      url: string | null
      postRootId: string | null
      productRootId: string | null
      sort: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adItem"]>
    composites: {}
  }

  type AdItemGetPayload<S extends boolean | null | undefined | AdItemDefaultArgs> = $Result.GetResult<Prisma.$AdItemPayload, S>

  type AdItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdItemCountAggregateInputType | true
    }

  export interface AdItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdItem'], meta: { name: 'AdItem' } }
    /**
     * Find zero or one AdItem that matches the filter.
     * @param {AdItemFindUniqueArgs} args - Arguments to find a AdItem
     * @example
     * // Get one AdItem
     * const adItem = await prisma.adItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdItemFindUniqueArgs>(args: SelectSubset<T, AdItemFindUniqueArgs<ExtArgs>>): Prisma__AdItemClient<$Result.GetResult<Prisma.$AdItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdItemFindUniqueOrThrowArgs} args - Arguments to find a AdItem
     * @example
     * // Get one AdItem
     * const adItem = await prisma.adItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdItemFindUniqueOrThrowArgs>(args: SelectSubset<T, AdItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdItemClient<$Result.GetResult<Prisma.$AdItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdItemFindFirstArgs} args - Arguments to find a AdItem
     * @example
     * // Get one AdItem
     * const adItem = await prisma.adItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdItemFindFirstArgs>(args?: SelectSubset<T, AdItemFindFirstArgs<ExtArgs>>): Prisma__AdItemClient<$Result.GetResult<Prisma.$AdItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdItemFindFirstOrThrowArgs} args - Arguments to find a AdItem
     * @example
     * // Get one AdItem
     * const adItem = await prisma.adItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdItemFindFirstOrThrowArgs>(args?: SelectSubset<T, AdItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdItemClient<$Result.GetResult<Prisma.$AdItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdItems
     * const adItems = await prisma.adItem.findMany()
     * 
     * // Get first 10 AdItems
     * const adItems = await prisma.adItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adItemWithIdOnly = await prisma.adItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdItemFindManyArgs>(args?: SelectSubset<T, AdItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdItem.
     * @param {AdItemCreateArgs} args - Arguments to create a AdItem.
     * @example
     * // Create one AdItem
     * const AdItem = await prisma.adItem.create({
     *   data: {
     *     // ... data to create a AdItem
     *   }
     * })
     * 
     */
    create<T extends AdItemCreateArgs>(args: SelectSubset<T, AdItemCreateArgs<ExtArgs>>): Prisma__AdItemClient<$Result.GetResult<Prisma.$AdItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdItems.
     * @param {AdItemCreateManyArgs} args - Arguments to create many AdItems.
     * @example
     * // Create many AdItems
     * const adItem = await prisma.adItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdItemCreateManyArgs>(args?: SelectSubset<T, AdItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdItems and returns the data saved in the database.
     * @param {AdItemCreateManyAndReturnArgs} args - Arguments to create many AdItems.
     * @example
     * // Create many AdItems
     * const adItem = await prisma.adItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdItems and only return the `id`
     * const adItemWithIdOnly = await prisma.adItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdItemCreateManyAndReturnArgs>(args?: SelectSubset<T, AdItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdItem.
     * @param {AdItemDeleteArgs} args - Arguments to delete one AdItem.
     * @example
     * // Delete one AdItem
     * const AdItem = await prisma.adItem.delete({
     *   where: {
     *     // ... filter to delete one AdItem
     *   }
     * })
     * 
     */
    delete<T extends AdItemDeleteArgs>(args: SelectSubset<T, AdItemDeleteArgs<ExtArgs>>): Prisma__AdItemClient<$Result.GetResult<Prisma.$AdItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdItem.
     * @param {AdItemUpdateArgs} args - Arguments to update one AdItem.
     * @example
     * // Update one AdItem
     * const adItem = await prisma.adItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdItemUpdateArgs>(args: SelectSubset<T, AdItemUpdateArgs<ExtArgs>>): Prisma__AdItemClient<$Result.GetResult<Prisma.$AdItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdItems.
     * @param {AdItemDeleteManyArgs} args - Arguments to filter AdItems to delete.
     * @example
     * // Delete a few AdItems
     * const { count } = await prisma.adItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdItemDeleteManyArgs>(args?: SelectSubset<T, AdItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdItems
     * const adItem = await prisma.adItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdItemUpdateManyArgs>(args: SelectSubset<T, AdItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdItems and returns the data updated in the database.
     * @param {AdItemUpdateManyAndReturnArgs} args - Arguments to update many AdItems.
     * @example
     * // Update many AdItems
     * const adItem = await prisma.adItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdItems and only return the `id`
     * const adItemWithIdOnly = await prisma.adItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdItemUpdateManyAndReturnArgs>(args: SelectSubset<T, AdItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdItem.
     * @param {AdItemUpsertArgs} args - Arguments to update or create a AdItem.
     * @example
     * // Update or create a AdItem
     * const adItem = await prisma.adItem.upsert({
     *   create: {
     *     // ... data to create a AdItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdItem we want to update
     *   }
     * })
     */
    upsert<T extends AdItemUpsertArgs>(args: SelectSubset<T, AdItemUpsertArgs<ExtArgs>>): Prisma__AdItemClient<$Result.GetResult<Prisma.$AdItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdItemCountArgs} args - Arguments to filter AdItems to count.
     * @example
     * // Count the number of AdItems
     * const count = await prisma.adItem.count({
     *   where: {
     *     // ... the filter for the AdItems we want to count
     *   }
     * })
    **/
    count<T extends AdItemCountArgs>(
      args?: Subset<T, AdItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdItemAggregateArgs>(args: Subset<T, AdItemAggregateArgs>): Prisma.PrismaPromise<GetAdItemAggregateType<T>>

    /**
     * Group by AdItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdItemGroupByArgs['orderBy'] }
        : { orderBy?: AdItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdItem model
   */
  readonly fields: AdItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adBlock<T extends AdBlockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdBlockDefaultArgs<ExtArgs>>): Prisma__AdBlockClient<$Result.GetResult<Prisma.$AdBlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdItem model
   */
  interface AdItemFieldRefs {
    readonly id: FieldRef<"AdItem", 'String'>
    readonly sourceType: FieldRef<"AdItem", 'AdItemSourceType'>
    readonly adBlockId: FieldRef<"AdItem", 'String'>
    readonly title: FieldRef<"AdItem", 'String'>
    readonly description: FieldRef<"AdItem", 'String'>
    readonly imageUrl: FieldRef<"AdItem", 'String'>
    readonly url: FieldRef<"AdItem", 'String'>
    readonly postRootId: FieldRef<"AdItem", 'String'>
    readonly productRootId: FieldRef<"AdItem", 'String'>
    readonly sort: FieldRef<"AdItem", 'Int'>
    readonly isActive: FieldRef<"AdItem", 'Boolean'>
    readonly createdAt: FieldRef<"AdItem", 'DateTime'>
    readonly updatedAt: FieldRef<"AdItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdItem findUnique
   */
  export type AdItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdItem
     */
    select?: AdItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdItem
     */
    omit?: AdItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdItemInclude<ExtArgs> | null
    /**
     * Filter, which AdItem to fetch.
     */
    where: AdItemWhereUniqueInput
  }

  /**
   * AdItem findUniqueOrThrow
   */
  export type AdItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdItem
     */
    select?: AdItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdItem
     */
    omit?: AdItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdItemInclude<ExtArgs> | null
    /**
     * Filter, which AdItem to fetch.
     */
    where: AdItemWhereUniqueInput
  }

  /**
   * AdItem findFirst
   */
  export type AdItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdItem
     */
    select?: AdItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdItem
     */
    omit?: AdItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdItemInclude<ExtArgs> | null
    /**
     * Filter, which AdItem to fetch.
     */
    where?: AdItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdItems to fetch.
     */
    orderBy?: AdItemOrderByWithRelationInput | AdItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdItems.
     */
    cursor?: AdItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdItems.
     */
    distinct?: AdItemScalarFieldEnum | AdItemScalarFieldEnum[]
  }

  /**
   * AdItem findFirstOrThrow
   */
  export type AdItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdItem
     */
    select?: AdItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdItem
     */
    omit?: AdItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdItemInclude<ExtArgs> | null
    /**
     * Filter, which AdItem to fetch.
     */
    where?: AdItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdItems to fetch.
     */
    orderBy?: AdItemOrderByWithRelationInput | AdItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdItems.
     */
    cursor?: AdItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdItems.
     */
    distinct?: AdItemScalarFieldEnum | AdItemScalarFieldEnum[]
  }

  /**
   * AdItem findMany
   */
  export type AdItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdItem
     */
    select?: AdItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdItem
     */
    omit?: AdItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdItemInclude<ExtArgs> | null
    /**
     * Filter, which AdItems to fetch.
     */
    where?: AdItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdItems to fetch.
     */
    orderBy?: AdItemOrderByWithRelationInput | AdItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdItems.
     */
    cursor?: AdItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdItems.
     */
    skip?: number
    distinct?: AdItemScalarFieldEnum | AdItemScalarFieldEnum[]
  }

  /**
   * AdItem create
   */
  export type AdItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdItem
     */
    select?: AdItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdItem
     */
    omit?: AdItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdItemInclude<ExtArgs> | null
    /**
     * The data needed to create a AdItem.
     */
    data: XOR<AdItemCreateInput, AdItemUncheckedCreateInput>
  }

  /**
   * AdItem createMany
   */
  export type AdItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdItems.
     */
    data: AdItemCreateManyInput | AdItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdItem createManyAndReturn
   */
  export type AdItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdItem
     */
    select?: AdItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdItem
     */
    omit?: AdItemOmit<ExtArgs> | null
    /**
     * The data used to create many AdItems.
     */
    data: AdItemCreateManyInput | AdItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdItem update
   */
  export type AdItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdItem
     */
    select?: AdItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdItem
     */
    omit?: AdItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdItemInclude<ExtArgs> | null
    /**
     * The data needed to update a AdItem.
     */
    data: XOR<AdItemUpdateInput, AdItemUncheckedUpdateInput>
    /**
     * Choose, which AdItem to update.
     */
    where: AdItemWhereUniqueInput
  }

  /**
   * AdItem updateMany
   */
  export type AdItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdItems.
     */
    data: XOR<AdItemUpdateManyMutationInput, AdItemUncheckedUpdateManyInput>
    /**
     * Filter which AdItems to update
     */
    where?: AdItemWhereInput
    /**
     * Limit how many AdItems to update.
     */
    limit?: number
  }

  /**
   * AdItem updateManyAndReturn
   */
  export type AdItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdItem
     */
    select?: AdItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdItem
     */
    omit?: AdItemOmit<ExtArgs> | null
    /**
     * The data used to update AdItems.
     */
    data: XOR<AdItemUpdateManyMutationInput, AdItemUncheckedUpdateManyInput>
    /**
     * Filter which AdItems to update
     */
    where?: AdItemWhereInput
    /**
     * Limit how many AdItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdItem upsert
   */
  export type AdItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdItem
     */
    select?: AdItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdItem
     */
    omit?: AdItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdItemInclude<ExtArgs> | null
    /**
     * The filter to search for the AdItem to update in case it exists.
     */
    where: AdItemWhereUniqueInput
    /**
     * In case the AdItem found by the `where` argument doesn't exist, create a new AdItem with this data.
     */
    create: XOR<AdItemCreateInput, AdItemUncheckedCreateInput>
    /**
     * In case the AdItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdItemUpdateInput, AdItemUncheckedUpdateInput>
  }

  /**
   * AdItem delete
   */
  export type AdItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdItem
     */
    select?: AdItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdItem
     */
    omit?: AdItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdItemInclude<ExtArgs> | null
    /**
     * Filter which AdItem to delete.
     */
    where: AdItemWhereUniqueInput
  }

  /**
   * AdItem deleteMany
   */
  export type AdItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdItems to delete
     */
    where?: AdItemWhereInput
    /**
     * Limit how many AdItems to delete.
     */
    limit?: number
  }

  /**
   * AdItem without action
   */
  export type AdItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdItem
     */
    select?: AdItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdItem
     */
    omit?: AdItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdItemInclude<ExtArgs> | null
  }


  /**
   * Model Purchase
   */

  export type AggregatePurchase = {
    _count: PurchaseCountAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  export type PurchaseMinAggregateOutputType = {
    id: string | null
    email: string | null
    productId: string | null
    productRootId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseMaxAggregateOutputType = {
    id: string | null
    email: string | null
    productId: string | null
    productRootId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseCountAggregateOutputType = {
    id: number
    email: number
    productId: number
    productRootId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseMinAggregateInputType = {
    id?: true
    email?: true
    productId?: true
    productRootId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseMaxAggregateInputType = {
    id?: true
    email?: true
    productId?: true
    productRootId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseCountAggregateInputType = {
    id?: true
    email?: true
    productId?: true
    productRootId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchase to aggregate.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Purchases
    **/
    _count?: true | PurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseMaxAggregateInputType
  }

  export type GetPurchaseAggregateType<T extends PurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchase[P]>
      : GetScalarType<T[P], AggregatePurchase[P]>
  }




  export type PurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithAggregationInput | PurchaseOrderByWithAggregationInput[]
    by: PurchaseScalarFieldEnum[] | PurchaseScalarFieldEnum
    having?: PurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseCountAggregateInputType | true
    _min?: PurchaseMinAggregateInputType
    _max?: PurchaseMaxAggregateInputType
  }

  export type PurchaseGroupByOutputType = {
    id: string
    email: string
    productId: string
    productRootId: string
    createdAt: Date
    updatedAt: Date
    _count: PurchaseCountAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  type GetPurchaseGroupByPayload<T extends PurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    productId?: boolean
    productRootId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    productId?: boolean
    productRootId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    productId?: boolean
    productRootId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectScalar = {
    id?: boolean
    email?: boolean
    productId?: boolean
    productRootId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "productId" | "productRootId" | "createdAt" | "updatedAt", ExtArgs["result"]["purchase"]>
  export type PurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type PurchaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type PurchaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $PurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Purchase"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      productId: string
      productRootId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchase"]>
    composites: {}
  }

  type PurchaseGetPayload<S extends boolean | null | undefined | PurchaseDefaultArgs> = $Result.GetResult<Prisma.$PurchasePayload, S>

  type PurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseCountAggregateInputType | true
    }

  export interface PurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Purchase'], meta: { name: 'Purchase' } }
    /**
     * Find zero or one Purchase that matches the filter.
     * @param {PurchaseFindUniqueArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseFindUniqueArgs>(args: SelectSubset<T, PurchaseFindUniqueArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Purchase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseFindUniqueOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Purchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseFindFirstArgs>(args?: SelectSubset<T, PurchaseFindFirstArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Purchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchases
     * const purchases = await prisma.purchase.findMany()
     * 
     * // Get first 10 Purchases
     * const purchases = await prisma.purchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseWithIdOnly = await prisma.purchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseFindManyArgs>(args?: SelectSubset<T, PurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Purchase.
     * @param {PurchaseCreateArgs} args - Arguments to create a Purchase.
     * @example
     * // Create one Purchase
     * const Purchase = await prisma.purchase.create({
     *   data: {
     *     // ... data to create a Purchase
     *   }
     * })
     * 
     */
    create<T extends PurchaseCreateArgs>(args: SelectSubset<T, PurchaseCreateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Purchases.
     * @param {PurchaseCreateManyArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseCreateManyArgs>(args?: SelectSubset<T, PurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Purchases and returns the data saved in the database.
     * @param {PurchaseCreateManyAndReturnArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Purchases and only return the `id`
     * const purchaseWithIdOnly = await prisma.purchase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Purchase.
     * @param {PurchaseDeleteArgs} args - Arguments to delete one Purchase.
     * @example
     * // Delete one Purchase
     * const Purchase = await prisma.purchase.delete({
     *   where: {
     *     // ... filter to delete one Purchase
     *   }
     * })
     * 
     */
    delete<T extends PurchaseDeleteArgs>(args: SelectSubset<T, PurchaseDeleteArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Purchase.
     * @param {PurchaseUpdateArgs} args - Arguments to update one Purchase.
     * @example
     * // Update one Purchase
     * const purchase = await prisma.purchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseUpdateArgs>(args: SelectSubset<T, PurchaseUpdateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Purchases.
     * @param {PurchaseDeleteManyArgs} args - Arguments to filter Purchases to delete.
     * @example
     * // Delete a few Purchases
     * const { count } = await prisma.purchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseDeleteManyArgs>(args?: SelectSubset<T, PurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseUpdateManyArgs>(args: SelectSubset<T, PurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases and returns the data updated in the database.
     * @param {PurchaseUpdateManyAndReturnArgs} args - Arguments to update many Purchases.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Purchases and only return the `id`
     * const purchaseWithIdOnly = await prisma.purchase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Purchase.
     * @param {PurchaseUpsertArgs} args - Arguments to update or create a Purchase.
     * @example
     * // Update or create a Purchase
     * const purchase = await prisma.purchase.upsert({
     *   create: {
     *     // ... data to create a Purchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchase we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseUpsertArgs>(args: SelectSubset<T, PurchaseUpsertArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseCountArgs} args - Arguments to filter Purchases to count.
     * @example
     * // Count the number of Purchases
     * const count = await prisma.purchase.count({
     *   where: {
     *     // ... the filter for the Purchases we want to count
     *   }
     * })
    **/
    count<T extends PurchaseCountArgs>(
      args?: Subset<T, PurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseAggregateArgs>(args: Subset<T, PurchaseAggregateArgs>): Prisma.PrismaPromise<GetPurchaseAggregateType<T>>

    /**
     * Group by Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Purchase model
   */
  readonly fields: PurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Purchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Purchase model
   */
  interface PurchaseFieldRefs {
    readonly id: FieldRef<"Purchase", 'String'>
    readonly email: FieldRef<"Purchase", 'String'>
    readonly productId: FieldRef<"Purchase", 'String'>
    readonly productRootId: FieldRef<"Purchase", 'String'>
    readonly createdAt: FieldRef<"Purchase", 'DateTime'>
    readonly updatedAt: FieldRef<"Purchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Purchase findUnique
   */
  export type PurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findUniqueOrThrow
   */
  export type PurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findFirst
   */
  export type PurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findFirstOrThrow
   */
  export type PurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findMany
   */
  export type PurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchases to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase create
   */
  export type PurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Purchase.
     */
    data: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
  }

  /**
   * Purchase createMany
   */
  export type PurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Purchase createManyAndReturn
   */
  export type PurchaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Purchase update
   */
  export type PurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Purchase.
     */
    data: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
    /**
     * Choose, which Purchase to update.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase updateMany
   */
  export type PurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to update.
     */
    limit?: number
  }

  /**
   * Purchase updateManyAndReturn
   */
  export type PurchaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Purchase upsert
   */
  export type PurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Purchase to update in case it exists.
     */
    where: PurchaseWhereUniqueInput
    /**
     * In case the Purchase found by the `where` argument doesn't exist, create a new Purchase with this data.
     */
    create: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
    /**
     * In case the Purchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
  }

  /**
   * Purchase delete
   */
  export type PurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter which Purchase to delete.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase deleteMany
   */
  export type PurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchases to delete
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to delete.
     */
    limit?: number
  }

  /**
   * Purchase without action
   */
  export type PurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
  }


  /**
   * Model ContactForm
   */

  export type AggregateContactForm = {
    _count: ContactFormCountAggregateOutputType | null
    _min: ContactFormMinAggregateOutputType | null
    _max: ContactFormMaxAggregateOutputType | null
  }

  export type ContactFormMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    subject: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactFormMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    subject: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactFormCountAggregateOutputType = {
    id: number
    name: number
    email: number
    subject: number
    message: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactFormMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactFormMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactFormCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactFormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactForm to aggregate.
     */
    where?: ContactFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactForms to fetch.
     */
    orderBy?: ContactFormOrderByWithRelationInput | ContactFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactForms
    **/
    _count?: true | ContactFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactFormMaxAggregateInputType
  }

  export type GetContactFormAggregateType<T extends ContactFormAggregateArgs> = {
        [P in keyof T & keyof AggregateContactForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactForm[P]>
      : GetScalarType<T[P], AggregateContactForm[P]>
  }




  export type ContactFormGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactFormWhereInput
    orderBy?: ContactFormOrderByWithAggregationInput | ContactFormOrderByWithAggregationInput[]
    by: ContactFormScalarFieldEnum[] | ContactFormScalarFieldEnum
    having?: ContactFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactFormCountAggregateInputType | true
    _min?: ContactFormMinAggregateInputType
    _max?: ContactFormMaxAggregateInputType
  }

  export type ContactFormGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    subject: string | null
    message: string | null
    createdAt: Date
    updatedAt: Date
    _count: ContactFormCountAggregateOutputType | null
    _min: ContactFormMinAggregateOutputType | null
    _max: ContactFormMaxAggregateOutputType | null
  }

  type GetContactFormGroupByPayload<T extends ContactFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactFormGroupByOutputType[P]>
            : GetScalarType<T[P], ContactFormGroupByOutputType[P]>
        }
      >
    >


  export type ContactFormSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactForm"]>

  export type ContactFormSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactForm"]>

  export type ContactFormSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactForm"]>

  export type ContactFormSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactFormOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "subject" | "message" | "createdAt" | "updatedAt", ExtArgs["result"]["contactForm"]>

  export type $ContactFormPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactForm"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string | null
      subject: string | null
      message: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contactForm"]>
    composites: {}
  }

  type ContactFormGetPayload<S extends boolean | null | undefined | ContactFormDefaultArgs> = $Result.GetResult<Prisma.$ContactFormPayload, S>

  type ContactFormCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFormFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactFormCountAggregateInputType | true
    }

  export interface ContactFormDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactForm'], meta: { name: 'ContactForm' } }
    /**
     * Find zero or one ContactForm that matches the filter.
     * @param {ContactFormFindUniqueArgs} args - Arguments to find a ContactForm
     * @example
     * // Get one ContactForm
     * const contactForm = await prisma.contactForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFormFindUniqueArgs>(args: SelectSubset<T, ContactFormFindUniqueArgs<ExtArgs>>): Prisma__ContactFormClient<$Result.GetResult<Prisma.$ContactFormPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactForm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFormFindUniqueOrThrowArgs} args - Arguments to find a ContactForm
     * @example
     * // Get one ContactForm
     * const contactForm = await prisma.contactForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFormFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFormFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactFormClient<$Result.GetResult<Prisma.$ContactFormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFormFindFirstArgs} args - Arguments to find a ContactForm
     * @example
     * // Get one ContactForm
     * const contactForm = await prisma.contactForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFormFindFirstArgs>(args?: SelectSubset<T, ContactFormFindFirstArgs<ExtArgs>>): Prisma__ContactFormClient<$Result.GetResult<Prisma.$ContactFormPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactForm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFormFindFirstOrThrowArgs} args - Arguments to find a ContactForm
     * @example
     * // Get one ContactForm
     * const contactForm = await prisma.contactForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFormFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFormFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactFormClient<$Result.GetResult<Prisma.$ContactFormPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFormFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactForms
     * const contactForms = await prisma.contactForm.findMany()
     * 
     * // Get first 10 ContactForms
     * const contactForms = await prisma.contactForm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactFormWithIdOnly = await prisma.contactForm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFormFindManyArgs>(args?: SelectSubset<T, ContactFormFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactForm.
     * @param {ContactFormCreateArgs} args - Arguments to create a ContactForm.
     * @example
     * // Create one ContactForm
     * const ContactForm = await prisma.contactForm.create({
     *   data: {
     *     // ... data to create a ContactForm
     *   }
     * })
     * 
     */
    create<T extends ContactFormCreateArgs>(args: SelectSubset<T, ContactFormCreateArgs<ExtArgs>>): Prisma__ContactFormClient<$Result.GetResult<Prisma.$ContactFormPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactForms.
     * @param {ContactFormCreateManyArgs} args - Arguments to create many ContactForms.
     * @example
     * // Create many ContactForms
     * const contactForm = await prisma.contactForm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactFormCreateManyArgs>(args?: SelectSubset<T, ContactFormCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactForms and returns the data saved in the database.
     * @param {ContactFormCreateManyAndReturnArgs} args - Arguments to create many ContactForms.
     * @example
     * // Create many ContactForms
     * const contactForm = await prisma.contactForm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactForms and only return the `id`
     * const contactFormWithIdOnly = await prisma.contactForm.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactFormCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactFormCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactFormPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactForm.
     * @param {ContactFormDeleteArgs} args - Arguments to delete one ContactForm.
     * @example
     * // Delete one ContactForm
     * const ContactForm = await prisma.contactForm.delete({
     *   where: {
     *     // ... filter to delete one ContactForm
     *   }
     * })
     * 
     */
    delete<T extends ContactFormDeleteArgs>(args: SelectSubset<T, ContactFormDeleteArgs<ExtArgs>>): Prisma__ContactFormClient<$Result.GetResult<Prisma.$ContactFormPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactForm.
     * @param {ContactFormUpdateArgs} args - Arguments to update one ContactForm.
     * @example
     * // Update one ContactForm
     * const contactForm = await prisma.contactForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactFormUpdateArgs>(args: SelectSubset<T, ContactFormUpdateArgs<ExtArgs>>): Prisma__ContactFormClient<$Result.GetResult<Prisma.$ContactFormPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactForms.
     * @param {ContactFormDeleteManyArgs} args - Arguments to filter ContactForms to delete.
     * @example
     * // Delete a few ContactForms
     * const { count } = await prisma.contactForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactFormDeleteManyArgs>(args?: SelectSubset<T, ContactFormDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactForms
     * const contactForm = await prisma.contactForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactFormUpdateManyArgs>(args: SelectSubset<T, ContactFormUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactForms and returns the data updated in the database.
     * @param {ContactFormUpdateManyAndReturnArgs} args - Arguments to update many ContactForms.
     * @example
     * // Update many ContactForms
     * const contactForm = await prisma.contactForm.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactForms and only return the `id`
     * const contactFormWithIdOnly = await prisma.contactForm.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactFormUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactFormUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactFormPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactForm.
     * @param {ContactFormUpsertArgs} args - Arguments to update or create a ContactForm.
     * @example
     * // Update or create a ContactForm
     * const contactForm = await prisma.contactForm.upsert({
     *   create: {
     *     // ... data to create a ContactForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactForm we want to update
     *   }
     * })
     */
    upsert<T extends ContactFormUpsertArgs>(args: SelectSubset<T, ContactFormUpsertArgs<ExtArgs>>): Prisma__ContactFormClient<$Result.GetResult<Prisma.$ContactFormPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFormCountArgs} args - Arguments to filter ContactForms to count.
     * @example
     * // Count the number of ContactForms
     * const count = await prisma.contactForm.count({
     *   where: {
     *     // ... the filter for the ContactForms we want to count
     *   }
     * })
    **/
    count<T extends ContactFormCountArgs>(
      args?: Subset<T, ContactFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactFormAggregateArgs>(args: Subset<T, ContactFormAggregateArgs>): Prisma.PrismaPromise<GetContactFormAggregateType<T>>

    /**
     * Group by ContactForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactFormGroupByArgs['orderBy'] }
        : { orderBy?: ContactFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactForm model
   */
  readonly fields: ContactFormFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactFormClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactForm model
   */
  interface ContactFormFieldRefs {
    readonly id: FieldRef<"ContactForm", 'String'>
    readonly name: FieldRef<"ContactForm", 'String'>
    readonly email: FieldRef<"ContactForm", 'String'>
    readonly subject: FieldRef<"ContactForm", 'String'>
    readonly message: FieldRef<"ContactForm", 'String'>
    readonly createdAt: FieldRef<"ContactForm", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactForm", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactForm findUnique
   */
  export type ContactFormFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactForm
     */
    select?: ContactFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactForm
     */
    omit?: ContactFormOmit<ExtArgs> | null
    /**
     * Filter, which ContactForm to fetch.
     */
    where: ContactFormWhereUniqueInput
  }

  /**
   * ContactForm findUniqueOrThrow
   */
  export type ContactFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactForm
     */
    select?: ContactFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactForm
     */
    omit?: ContactFormOmit<ExtArgs> | null
    /**
     * Filter, which ContactForm to fetch.
     */
    where: ContactFormWhereUniqueInput
  }

  /**
   * ContactForm findFirst
   */
  export type ContactFormFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactForm
     */
    select?: ContactFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactForm
     */
    omit?: ContactFormOmit<ExtArgs> | null
    /**
     * Filter, which ContactForm to fetch.
     */
    where?: ContactFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactForms to fetch.
     */
    orderBy?: ContactFormOrderByWithRelationInput | ContactFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactForms.
     */
    cursor?: ContactFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactForms.
     */
    distinct?: ContactFormScalarFieldEnum | ContactFormScalarFieldEnum[]
  }

  /**
   * ContactForm findFirstOrThrow
   */
  export type ContactFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactForm
     */
    select?: ContactFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactForm
     */
    omit?: ContactFormOmit<ExtArgs> | null
    /**
     * Filter, which ContactForm to fetch.
     */
    where?: ContactFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactForms to fetch.
     */
    orderBy?: ContactFormOrderByWithRelationInput | ContactFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactForms.
     */
    cursor?: ContactFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactForms.
     */
    distinct?: ContactFormScalarFieldEnum | ContactFormScalarFieldEnum[]
  }

  /**
   * ContactForm findMany
   */
  export type ContactFormFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactForm
     */
    select?: ContactFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactForm
     */
    omit?: ContactFormOmit<ExtArgs> | null
    /**
     * Filter, which ContactForms to fetch.
     */
    where?: ContactFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactForms to fetch.
     */
    orderBy?: ContactFormOrderByWithRelationInput | ContactFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactForms.
     */
    cursor?: ContactFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactForms.
     */
    skip?: number
    distinct?: ContactFormScalarFieldEnum | ContactFormScalarFieldEnum[]
  }

  /**
   * ContactForm create
   */
  export type ContactFormCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactForm
     */
    select?: ContactFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactForm
     */
    omit?: ContactFormOmit<ExtArgs> | null
    /**
     * The data needed to create a ContactForm.
     */
    data: XOR<ContactFormCreateInput, ContactFormUncheckedCreateInput>
  }

  /**
   * ContactForm createMany
   */
  export type ContactFormCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactForms.
     */
    data: ContactFormCreateManyInput | ContactFormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactForm createManyAndReturn
   */
  export type ContactFormCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactForm
     */
    select?: ContactFormSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactForm
     */
    omit?: ContactFormOmit<ExtArgs> | null
    /**
     * The data used to create many ContactForms.
     */
    data: ContactFormCreateManyInput | ContactFormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactForm update
   */
  export type ContactFormUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactForm
     */
    select?: ContactFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactForm
     */
    omit?: ContactFormOmit<ExtArgs> | null
    /**
     * The data needed to update a ContactForm.
     */
    data: XOR<ContactFormUpdateInput, ContactFormUncheckedUpdateInput>
    /**
     * Choose, which ContactForm to update.
     */
    where: ContactFormWhereUniqueInput
  }

  /**
   * ContactForm updateMany
   */
  export type ContactFormUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactForms.
     */
    data: XOR<ContactFormUpdateManyMutationInput, ContactFormUncheckedUpdateManyInput>
    /**
     * Filter which ContactForms to update
     */
    where?: ContactFormWhereInput
    /**
     * Limit how many ContactForms to update.
     */
    limit?: number
  }

  /**
   * ContactForm updateManyAndReturn
   */
  export type ContactFormUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactForm
     */
    select?: ContactFormSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactForm
     */
    omit?: ContactFormOmit<ExtArgs> | null
    /**
     * The data used to update ContactForms.
     */
    data: XOR<ContactFormUpdateManyMutationInput, ContactFormUncheckedUpdateManyInput>
    /**
     * Filter which ContactForms to update
     */
    where?: ContactFormWhereInput
    /**
     * Limit how many ContactForms to update.
     */
    limit?: number
  }

  /**
   * ContactForm upsert
   */
  export type ContactFormUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactForm
     */
    select?: ContactFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactForm
     */
    omit?: ContactFormOmit<ExtArgs> | null
    /**
     * The filter to search for the ContactForm to update in case it exists.
     */
    where: ContactFormWhereUniqueInput
    /**
     * In case the ContactForm found by the `where` argument doesn't exist, create a new ContactForm with this data.
     */
    create: XOR<ContactFormCreateInput, ContactFormUncheckedCreateInput>
    /**
     * In case the ContactForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactFormUpdateInput, ContactFormUncheckedUpdateInput>
  }

  /**
   * ContactForm delete
   */
  export type ContactFormDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactForm
     */
    select?: ContactFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactForm
     */
    omit?: ContactFormOmit<ExtArgs> | null
    /**
     * Filter which ContactForm to delete.
     */
    where: ContactFormWhereUniqueInput
  }

  /**
   * ContactForm deleteMany
   */
  export type ContactFormDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactForms to delete
     */
    where?: ContactFormWhereInput
    /**
     * Limit how many ContactForms to delete.
     */
    limit?: number
  }

  /**
   * ContactForm without action
   */
  export type ContactFormDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactForm
     */
    select?: ContactFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactForm
     */
    omit?: ContactFormOmit<ExtArgs> | null
  }


  /**
   * Model Form
   */

  export type AggregateForm = {
    _count: FormCountAggregateOutputType | null
    _min: FormMinAggregateOutputType | null
    _max: FormMaxAggregateOutputType | null
  }

  export type FormMinAggregateOutputType = {
    id: string | null
    name: string | null
    submitLabel: string | null
    gtmEventName: string | null
    gtmCategory: string | null
    gtmLabel: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormMaxAggregateOutputType = {
    id: string | null
    name: string | null
    submitLabel: string | null
    gtmEventName: string | null
    gtmCategory: string | null
    gtmLabel: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormCountAggregateOutputType = {
    id: number
    name: number
    fields:PrismaJson.FormFields
    submitLabel: number
    gtmEventName: number
    gtmCategory: number
    gtmLabel: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FormMinAggregateInputType = {
    id?: true
    name?: true
    submitLabel?: true
    gtmEventName?: true
    gtmCategory?: true
    gtmLabel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormMaxAggregateInputType = {
    id?: true
    name?: true
    submitLabel?: true
    gtmEventName?: true
    gtmCategory?: true
    gtmLabel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormCountAggregateInputType = {
    id?: true
    name?: true
    fields?: true
    submitLabel?: true
    gtmEventName?: true
    gtmCategory?: true
    gtmLabel?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Form to aggregate.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Forms
    **/
    _count?: true | FormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormMaxAggregateInputType
  }

  export type GetFormAggregateType<T extends FormAggregateArgs> = {
        [P in keyof T & keyof AggregateForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForm[P]>
      : GetScalarType<T[P], AggregateForm[P]>
  }




  export type FormGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormWhereInput
    orderBy?: FormOrderByWithAggregationInput | FormOrderByWithAggregationInput[]
    by: FormScalarFieldEnum[] | FormScalarFieldEnum
    having?: FormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormCountAggregateInputType | true
    _min?: FormMinAggregateInputType
    _max?: FormMaxAggregateInputType
  }

  export type FormGroupByOutputType = {
    id: string
    name: string
    fields:PrismaJson.FormFields | null
    submitLabel: string | null
    gtmEventName: string | null
    gtmCategory: string | null
    gtmLabel: string | null
    createdAt: Date
    updatedAt: Date
    _count: FormCountAggregateOutputType | null
    _min: FormMinAggregateOutputType | null
    _max: FormMaxAggregateOutputType | null
  }

  type GetFormGroupByPayload<T extends FormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormGroupByOutputType[P]>
            : GetScalarType<T[P], FormGroupByOutputType[P]>
        }
      >
    >


  export type FormSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    fields?: boolean
    submitLabel?: boolean
    gtmEventName?: boolean
    gtmCategory?: boolean
    gtmLabel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | Form$productsArgs<ExtArgs>
    submissions?: boolean | Form$submissionsArgs<ExtArgs>
    _count?: boolean | FormCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["form"]>

  export type FormSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    fields?: boolean
    submitLabel?: boolean
    gtmEventName?: boolean
    gtmCategory?: boolean
    gtmLabel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["form"]>

  export type FormSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    fields?: boolean
    submitLabel?: boolean
    gtmEventName?: boolean
    gtmCategory?: boolean
    gtmLabel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["form"]>

  export type FormSelectScalar = {
    id?: boolean
    name?: boolean
    fields?: boolean
    submitLabel?: boolean
    gtmEventName?: boolean
    gtmCategory?: boolean
    gtmLabel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FormOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "fields" | "submitLabel" | "gtmEventName" | "gtmCategory" | "gtmLabel" | "createdAt" | "updatedAt", ExtArgs["result"]["form"]>
  export type FormInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Form$productsArgs<ExtArgs>
    submissions?: boolean | Form$submissionsArgs<ExtArgs>
    _count?: boolean | FormCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FormIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FormIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FormPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Form"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
      submissions: Prisma.$FormSubmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      /**
       * [FormFields]
       */
      fields:PrismaJson.FormFields | null
      submitLabel: string | null
      gtmEventName: string | null
      gtmCategory: string | null
      gtmLabel: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["form"]>
    composites: {}
  }

  type FormGetPayload<S extends boolean | null | undefined | FormDefaultArgs> = $Result.GetResult<Prisma.$FormPayload, S>

  type FormCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FormFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormCountAggregateInputType | true
    }

  export interface FormDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Form'], meta: { name: 'Form' } }
    /**
     * Find zero or one Form that matches the filter.
     * @param {FormFindUniqueArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormFindUniqueArgs>(args: SelectSubset<T, FormFindUniqueArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Form that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FormFindUniqueOrThrowArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormFindUniqueOrThrowArgs>(args: SelectSubset<T, FormFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Form that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFindFirstArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormFindFirstArgs>(args?: SelectSubset<T, FormFindFirstArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Form that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFindFirstOrThrowArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormFindFirstOrThrowArgs>(args?: SelectSubset<T, FormFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Forms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Forms
     * const forms = await prisma.form.findMany()
     * 
     * // Get first 10 Forms
     * const forms = await prisma.form.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formWithIdOnly = await prisma.form.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormFindManyArgs>(args?: SelectSubset<T, FormFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Form.
     * @param {FormCreateArgs} args - Arguments to create a Form.
     * @example
     * // Create one Form
     * const Form = await prisma.form.create({
     *   data: {
     *     // ... data to create a Form
     *   }
     * })
     * 
     */
    create<T extends FormCreateArgs>(args: SelectSubset<T, FormCreateArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Forms.
     * @param {FormCreateManyArgs} args - Arguments to create many Forms.
     * @example
     * // Create many Forms
     * const form = await prisma.form.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormCreateManyArgs>(args?: SelectSubset<T, FormCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Forms and returns the data saved in the database.
     * @param {FormCreateManyAndReturnArgs} args - Arguments to create many Forms.
     * @example
     * // Create many Forms
     * const form = await prisma.form.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Forms and only return the `id`
     * const formWithIdOnly = await prisma.form.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormCreateManyAndReturnArgs>(args?: SelectSubset<T, FormCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Form.
     * @param {FormDeleteArgs} args - Arguments to delete one Form.
     * @example
     * // Delete one Form
     * const Form = await prisma.form.delete({
     *   where: {
     *     // ... filter to delete one Form
     *   }
     * })
     * 
     */
    delete<T extends FormDeleteArgs>(args: SelectSubset<T, FormDeleteArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Form.
     * @param {FormUpdateArgs} args - Arguments to update one Form.
     * @example
     * // Update one Form
     * const form = await prisma.form.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormUpdateArgs>(args: SelectSubset<T, FormUpdateArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Forms.
     * @param {FormDeleteManyArgs} args - Arguments to filter Forms to delete.
     * @example
     * // Delete a few Forms
     * const { count } = await prisma.form.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormDeleteManyArgs>(args?: SelectSubset<T, FormDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Forms
     * const form = await prisma.form.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormUpdateManyArgs>(args: SelectSubset<T, FormUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Forms and returns the data updated in the database.
     * @param {FormUpdateManyAndReturnArgs} args - Arguments to update many Forms.
     * @example
     * // Update many Forms
     * const form = await prisma.form.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Forms and only return the `id`
     * const formWithIdOnly = await prisma.form.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FormUpdateManyAndReturnArgs>(args: SelectSubset<T, FormUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Form.
     * @param {FormUpsertArgs} args - Arguments to update or create a Form.
     * @example
     * // Update or create a Form
     * const form = await prisma.form.upsert({
     *   create: {
     *     // ... data to create a Form
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Form we want to update
     *   }
     * })
     */
    upsert<T extends FormUpsertArgs>(args: SelectSubset<T, FormUpsertArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormCountArgs} args - Arguments to filter Forms to count.
     * @example
     * // Count the number of Forms
     * const count = await prisma.form.count({
     *   where: {
     *     // ... the filter for the Forms we want to count
     *   }
     * })
    **/
    count<T extends FormCountArgs>(
      args?: Subset<T, FormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Form.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormAggregateArgs>(args: Subset<T, FormAggregateArgs>): Prisma.PrismaPromise<GetFormAggregateType<T>>

    /**
     * Group by Form.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormGroupByArgs['orderBy'] }
        : { orderBy?: FormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Form model
   */
  readonly fields: FormFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Form.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Form$productsArgs<ExtArgs> = {}>(args?: Subset<T, Form$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    submissions<T extends Form$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, Form$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Form model
   */
  interface FormFieldRefs {
    readonly id: FieldRef<"Form", 'String'>
    readonly name: FieldRef<"Form", 'String'>
    readonly fields: FieldRef<"Form", 'Json'>
    readonly submitLabel: FieldRef<"Form", 'String'>
    readonly gtmEventName: FieldRef<"Form", 'String'>
    readonly gtmCategory: FieldRef<"Form", 'String'>
    readonly gtmLabel: FieldRef<"Form", 'String'>
    readonly createdAt: FieldRef<"Form", 'DateTime'>
    readonly updatedAt: FieldRef<"Form", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Form findUnique
   */
  export type FormFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where: FormWhereUniqueInput
  }

  /**
   * Form findUniqueOrThrow
   */
  export type FormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where: FormWhereUniqueInput
  }

  /**
   * Form findFirst
   */
  export type FormFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Forms.
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Forms.
     */
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }

  /**
   * Form findFirstOrThrow
   */
  export type FormFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Forms.
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Forms.
     */
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }

  /**
   * Form findMany
   */
  export type FormFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Forms to fetch.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Forms.
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }

  /**
   * Form create
   */
  export type FormCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * The data needed to create a Form.
     */
    data: XOR<FormCreateInput, FormUncheckedCreateInput>
  }

  /**
   * Form createMany
   */
  export type FormCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Forms.
     */
    data: FormCreateManyInput | FormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Form createManyAndReturn
   */
  export type FormCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * The data used to create many Forms.
     */
    data: FormCreateManyInput | FormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Form update
   */
  export type FormUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * The data needed to update a Form.
     */
    data: XOR<FormUpdateInput, FormUncheckedUpdateInput>
    /**
     * Choose, which Form to update.
     */
    where: FormWhereUniqueInput
  }

  /**
   * Form updateMany
   */
  export type FormUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Forms.
     */
    data: XOR<FormUpdateManyMutationInput, FormUncheckedUpdateManyInput>
    /**
     * Filter which Forms to update
     */
    where?: FormWhereInput
    /**
     * Limit how many Forms to update.
     */
    limit?: number
  }

  /**
   * Form updateManyAndReturn
   */
  export type FormUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * The data used to update Forms.
     */
    data: XOR<FormUpdateManyMutationInput, FormUncheckedUpdateManyInput>
    /**
     * Filter which Forms to update
     */
    where?: FormWhereInput
    /**
     * Limit how many Forms to update.
     */
    limit?: number
  }

  /**
   * Form upsert
   */
  export type FormUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * The filter to search for the Form to update in case it exists.
     */
    where: FormWhereUniqueInput
    /**
     * In case the Form found by the `where` argument doesn't exist, create a new Form with this data.
     */
    create: XOR<FormCreateInput, FormUncheckedCreateInput>
    /**
     * In case the Form was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormUpdateInput, FormUncheckedUpdateInput>
  }

  /**
   * Form delete
   */
  export type FormDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter which Form to delete.
     */
    where: FormWhereUniqueInput
  }

  /**
   * Form deleteMany
   */
  export type FormDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Forms to delete
     */
    where?: FormWhereInput
    /**
     * Limit how many Forms to delete.
     */
    limit?: number
  }

  /**
   * Form.products
   */
  export type Form$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Form.submissions
   */
  export type Form$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    where?: FormSubmissionWhereInput
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    cursor?: FormSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * Form without action
   */
  export type FormDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
  }


  /**
   * Model FormSubmission
   */

  export type AggregateFormSubmission = {
    _count: FormSubmissionCountAggregateOutputType | null
    _min: FormSubmissionMinAggregateOutputType | null
    _max: FormSubmissionMaxAggregateOutputType | null
  }

  export type FormSubmissionMinAggregateOutputType = {
    id: string | null
    formId: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormSubmissionMaxAggregateOutputType = {
    id: string | null
    formId: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormSubmissionCountAggregateOutputType = {
    id: number
    formId: number
    email: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FormSubmissionMinAggregateInputType = {
    id?: true
    formId?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormSubmissionMaxAggregateInputType = {
    id?: true
    formId?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormSubmissionCountAggregateInputType = {
    id?: true
    formId?: true
    email?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FormSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormSubmission to aggregate.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormSubmissions
    **/
    _count?: true | FormSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormSubmissionMaxAggregateInputType
  }

  export type GetFormSubmissionAggregateType<T extends FormSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateFormSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormSubmission[P]>
      : GetScalarType<T[P], AggregateFormSubmission[P]>
  }




  export type FormSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormSubmissionWhereInput
    orderBy?: FormSubmissionOrderByWithAggregationInput | FormSubmissionOrderByWithAggregationInput[]
    by: FormSubmissionScalarFieldEnum[] | FormSubmissionScalarFieldEnum
    having?: FormSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormSubmissionCountAggregateInputType | true
    _min?: FormSubmissionMinAggregateInputType
    _max?: FormSubmissionMaxAggregateInputType
  }

  export type FormSubmissionGroupByOutputType = {
    id: string
    formId: string
    email: string | null
    data:unknown
    createdAt: Date
    updatedAt: Date
    _count: FormSubmissionCountAggregateOutputType | null
    _min: FormSubmissionMinAggregateOutputType | null
    _max: FormSubmissionMaxAggregateOutputType | null
  }

  type GetFormSubmissionGroupByPayload<T extends FormSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], FormSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type FormSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formId?: boolean
    email?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    form?: boolean | FormDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formSubmission"]>

  export type FormSubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formId?: boolean
    email?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    form?: boolean | FormDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formSubmission"]>

  export type FormSubmissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formId?: boolean
    email?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    form?: boolean | FormDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formSubmission"]>

  export type FormSubmissionSelectScalar = {
    id?: boolean
    formId?: boolean
    email?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FormSubmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "formId" | "email" | "data" | "createdAt" | "updatedAt", ExtArgs["result"]["formSubmission"]>
  export type FormSubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    form?: boolean | FormDefaultArgs<ExtArgs>
  }
  export type FormSubmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    form?: boolean | FormDefaultArgs<ExtArgs>
  }
  export type FormSubmissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    form?: boolean | FormDefaultArgs<ExtArgs>
  }

  export type $FormSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormSubmission"
    objects: {
      form: Prisma.$FormPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      formId: string
      email: string | null
      data:unknown
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["formSubmission"]>
    composites: {}
  }

  type FormSubmissionGetPayload<S extends boolean | null | undefined | FormSubmissionDefaultArgs> = $Result.GetResult<Prisma.$FormSubmissionPayload, S>

  type FormSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FormSubmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormSubmissionCountAggregateInputType | true
    }

  export interface FormSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormSubmission'], meta: { name: 'FormSubmission' } }
    /**
     * Find zero or one FormSubmission that matches the filter.
     * @param {FormSubmissionFindUniqueArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormSubmissionFindUniqueArgs>(args: SelectSubset<T, FormSubmissionFindUniqueArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FormSubmission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FormSubmissionFindUniqueOrThrowArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, FormSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionFindFirstArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormSubmissionFindFirstArgs>(args?: SelectSubset<T, FormSubmissionFindFirstArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionFindFirstOrThrowArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, FormSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FormSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormSubmissions
     * const formSubmissions = await prisma.formSubmission.findMany()
     * 
     * // Get first 10 FormSubmissions
     * const formSubmissions = await prisma.formSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formSubmissionWithIdOnly = await prisma.formSubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormSubmissionFindManyArgs>(args?: SelectSubset<T, FormSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FormSubmission.
     * @param {FormSubmissionCreateArgs} args - Arguments to create a FormSubmission.
     * @example
     * // Create one FormSubmission
     * const FormSubmission = await prisma.formSubmission.create({
     *   data: {
     *     // ... data to create a FormSubmission
     *   }
     * })
     * 
     */
    create<T extends FormSubmissionCreateArgs>(args: SelectSubset<T, FormSubmissionCreateArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FormSubmissions.
     * @param {FormSubmissionCreateManyArgs} args - Arguments to create many FormSubmissions.
     * @example
     * // Create many FormSubmissions
     * const formSubmission = await prisma.formSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormSubmissionCreateManyArgs>(args?: SelectSubset<T, FormSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormSubmissions and returns the data saved in the database.
     * @param {FormSubmissionCreateManyAndReturnArgs} args - Arguments to create many FormSubmissions.
     * @example
     * // Create many FormSubmissions
     * const formSubmission = await prisma.formSubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormSubmissions and only return the `id`
     * const formSubmissionWithIdOnly = await prisma.formSubmission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormSubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, FormSubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FormSubmission.
     * @param {FormSubmissionDeleteArgs} args - Arguments to delete one FormSubmission.
     * @example
     * // Delete one FormSubmission
     * const FormSubmission = await prisma.formSubmission.delete({
     *   where: {
     *     // ... filter to delete one FormSubmission
     *   }
     * })
     * 
     */
    delete<T extends FormSubmissionDeleteArgs>(args: SelectSubset<T, FormSubmissionDeleteArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FormSubmission.
     * @param {FormSubmissionUpdateArgs} args - Arguments to update one FormSubmission.
     * @example
     * // Update one FormSubmission
     * const formSubmission = await prisma.formSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormSubmissionUpdateArgs>(args: SelectSubset<T, FormSubmissionUpdateArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FormSubmissions.
     * @param {FormSubmissionDeleteManyArgs} args - Arguments to filter FormSubmissions to delete.
     * @example
     * // Delete a few FormSubmissions
     * const { count } = await prisma.formSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormSubmissionDeleteManyArgs>(args?: SelectSubset<T, FormSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormSubmissions
     * const formSubmission = await prisma.formSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormSubmissionUpdateManyArgs>(args: SelectSubset<T, FormSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormSubmissions and returns the data updated in the database.
     * @param {FormSubmissionUpdateManyAndReturnArgs} args - Arguments to update many FormSubmissions.
     * @example
     * // Update many FormSubmissions
     * const formSubmission = await prisma.formSubmission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FormSubmissions and only return the `id`
     * const formSubmissionWithIdOnly = await prisma.formSubmission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FormSubmissionUpdateManyAndReturnArgs>(args: SelectSubset<T, FormSubmissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FormSubmission.
     * @param {FormSubmissionUpsertArgs} args - Arguments to update or create a FormSubmission.
     * @example
     * // Update or create a FormSubmission
     * const formSubmission = await prisma.formSubmission.upsert({
     *   create: {
     *     // ... data to create a FormSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormSubmission we want to update
     *   }
     * })
     */
    upsert<T extends FormSubmissionUpsertArgs>(args: SelectSubset<T, FormSubmissionUpsertArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FormSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionCountArgs} args - Arguments to filter FormSubmissions to count.
     * @example
     * // Count the number of FormSubmissions
     * const count = await prisma.formSubmission.count({
     *   where: {
     *     // ... the filter for the FormSubmissions we want to count
     *   }
     * })
    **/
    count<T extends FormSubmissionCountArgs>(
      args?: Subset<T, FormSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormSubmissionAggregateArgs>(args: Subset<T, FormSubmissionAggregateArgs>): Prisma.PrismaPromise<GetFormSubmissionAggregateType<T>>

    /**
     * Group by FormSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: FormSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormSubmission model
   */
  readonly fields: FormSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    form<T extends FormDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FormDefaultArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FormSubmission model
   */
  interface FormSubmissionFieldRefs {
    readonly id: FieldRef<"FormSubmission", 'String'>
    readonly formId: FieldRef<"FormSubmission", 'String'>
    readonly email: FieldRef<"FormSubmission", 'String'>
    readonly data: FieldRef<"FormSubmission", 'Json'>
    readonly createdAt: FieldRef<"FormSubmission", 'DateTime'>
    readonly updatedAt: FieldRef<"FormSubmission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FormSubmission findUnique
   */
  export type FormSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission findUniqueOrThrow
   */
  export type FormSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission findFirst
   */
  export type FormSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormSubmissions.
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormSubmissions.
     */
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormSubmission findFirstOrThrow
   */
  export type FormSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormSubmissions.
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormSubmissions.
     */
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormSubmission findMany
   */
  export type FormSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmissions to fetch.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormSubmissions.
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormSubmission create
   */
  export type FormSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a FormSubmission.
     */
    data: XOR<FormSubmissionCreateInput, FormSubmissionUncheckedCreateInput>
  }

  /**
   * FormSubmission createMany
   */
  export type FormSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormSubmissions.
     */
    data: FormSubmissionCreateManyInput | FormSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormSubmission createManyAndReturn
   */
  export type FormSubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * The data used to create many FormSubmissions.
     */
    data: FormSubmissionCreateManyInput | FormSubmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormSubmission update
   */
  export type FormSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a FormSubmission.
     */
    data: XOR<FormSubmissionUpdateInput, FormSubmissionUncheckedUpdateInput>
    /**
     * Choose, which FormSubmission to update.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission updateMany
   */
  export type FormSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormSubmissions.
     */
    data: XOR<FormSubmissionUpdateManyMutationInput, FormSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which FormSubmissions to update
     */
    where?: FormSubmissionWhereInput
    /**
     * Limit how many FormSubmissions to update.
     */
    limit?: number
  }

  /**
   * FormSubmission updateManyAndReturn
   */
  export type FormSubmissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * The data used to update FormSubmissions.
     */
    data: XOR<FormSubmissionUpdateManyMutationInput, FormSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which FormSubmissions to update
     */
    where?: FormSubmissionWhereInput
    /**
     * Limit how many FormSubmissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormSubmission upsert
   */
  export type FormSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the FormSubmission to update in case it exists.
     */
    where: FormSubmissionWhereUniqueInput
    /**
     * In case the FormSubmission found by the `where` argument doesn't exist, create a new FormSubmission with this data.
     */
    create: XOR<FormSubmissionCreateInput, FormSubmissionUncheckedCreateInput>
    /**
     * In case the FormSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormSubmissionUpdateInput, FormSubmissionUncheckedUpdateInput>
  }

  /**
   * FormSubmission delete
   */
  export type FormSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter which FormSubmission to delete.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission deleteMany
   */
  export type FormSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormSubmissions to delete
     */
    where?: FormSubmissionWhereInput
    /**
     * Limit how many FormSubmissions to delete.
     */
    limit?: number
  }

  /**
   * FormSubmission without action
   */
  export type FormSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
  }


  /**
   * Model Format
   */

  export type AggregateFormat = {
    _count: FormatCountAggregateOutputType | null
    _min: FormatMinAggregateOutputType | null
    _max: FormatMaxAggregateOutputType | null
  }

  export type FormatMinAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormatMaxAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormatCountAggregateOutputType = {
    id: number
    title: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FormatMinAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormatMaxAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormatCountAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FormatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Format to aggregate.
     */
    where?: FormatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Formats to fetch.
     */
    orderBy?: FormatOrderByWithRelationInput | FormatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Formats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Formats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Formats
    **/
    _count?: true | FormatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormatMaxAggregateInputType
  }

  export type GetFormatAggregateType<T extends FormatAggregateArgs> = {
        [P in keyof T & keyof AggregateFormat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormat[P]>
      : GetScalarType<T[P], AggregateFormat[P]>
  }




  export type FormatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormatWhereInput
    orderBy?: FormatOrderByWithAggregationInput | FormatOrderByWithAggregationInput[]
    by: FormatScalarFieldEnum[] | FormatScalarFieldEnum
    having?: FormatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormatCountAggregateInputType | true
    _min?: FormatMinAggregateInputType
    _max?: FormatMaxAggregateInputType
  }

  export type FormatGroupByOutputType = {
    id: string
    title: string
    createdAt: Date
    updatedAt: Date
    _count: FormatCountAggregateOutputType | null
    _min: FormatMinAggregateOutputType | null
    _max: FormatMaxAggregateOutputType | null
  }

  type GetFormatGroupByPayload<T extends FormatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormatGroupByOutputType[P]>
            : GetScalarType<T[P], FormatGroupByOutputType[P]>
        }
      >
    >


  export type FormatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Impression?: boolean | Format$ImpressionArgs<ExtArgs>
    _count?: boolean | FormatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["format"]>

  export type FormatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["format"]>

  export type FormatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["format"]>

  export type FormatSelectScalar = {
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FormatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "createdAt" | "updatedAt", ExtArgs["result"]["format"]>
  export type FormatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Impression?: boolean | Format$ImpressionArgs<ExtArgs>
    _count?: boolean | FormatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FormatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FormatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FormatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Format"
    objects: {
      Impression: Prisma.$ImpressionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["format"]>
    composites: {}
  }

  type FormatGetPayload<S extends boolean | null | undefined | FormatDefaultArgs> = $Result.GetResult<Prisma.$FormatPayload, S>

  type FormatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FormatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormatCountAggregateInputType | true
    }

  export interface FormatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Format'], meta: { name: 'Format' } }
    /**
     * Find zero or one Format that matches the filter.
     * @param {FormatFindUniqueArgs} args - Arguments to find a Format
     * @example
     * // Get one Format
     * const format = await prisma.format.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormatFindUniqueArgs>(args: SelectSubset<T, FormatFindUniqueArgs<ExtArgs>>): Prisma__FormatClient<$Result.GetResult<Prisma.$FormatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Format that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FormatFindUniqueOrThrowArgs} args - Arguments to find a Format
     * @example
     * // Get one Format
     * const format = await prisma.format.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormatFindUniqueOrThrowArgs>(args: SelectSubset<T, FormatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormatClient<$Result.GetResult<Prisma.$FormatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Format that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormatFindFirstArgs} args - Arguments to find a Format
     * @example
     * // Get one Format
     * const format = await prisma.format.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormatFindFirstArgs>(args?: SelectSubset<T, FormatFindFirstArgs<ExtArgs>>): Prisma__FormatClient<$Result.GetResult<Prisma.$FormatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Format that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormatFindFirstOrThrowArgs} args - Arguments to find a Format
     * @example
     * // Get one Format
     * const format = await prisma.format.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormatFindFirstOrThrowArgs>(args?: SelectSubset<T, FormatFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormatClient<$Result.GetResult<Prisma.$FormatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Formats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Formats
     * const formats = await prisma.format.findMany()
     * 
     * // Get first 10 Formats
     * const formats = await prisma.format.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formatWithIdOnly = await prisma.format.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormatFindManyArgs>(args?: SelectSubset<T, FormatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Format.
     * @param {FormatCreateArgs} args - Arguments to create a Format.
     * @example
     * // Create one Format
     * const Format = await prisma.format.create({
     *   data: {
     *     // ... data to create a Format
     *   }
     * })
     * 
     */
    create<T extends FormatCreateArgs>(args: SelectSubset<T, FormatCreateArgs<ExtArgs>>): Prisma__FormatClient<$Result.GetResult<Prisma.$FormatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Formats.
     * @param {FormatCreateManyArgs} args - Arguments to create many Formats.
     * @example
     * // Create many Formats
     * const format = await prisma.format.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormatCreateManyArgs>(args?: SelectSubset<T, FormatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Formats and returns the data saved in the database.
     * @param {FormatCreateManyAndReturnArgs} args - Arguments to create many Formats.
     * @example
     * // Create many Formats
     * const format = await prisma.format.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Formats and only return the `id`
     * const formatWithIdOnly = await prisma.format.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormatCreateManyAndReturnArgs>(args?: SelectSubset<T, FormatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Format.
     * @param {FormatDeleteArgs} args - Arguments to delete one Format.
     * @example
     * // Delete one Format
     * const Format = await prisma.format.delete({
     *   where: {
     *     // ... filter to delete one Format
     *   }
     * })
     * 
     */
    delete<T extends FormatDeleteArgs>(args: SelectSubset<T, FormatDeleteArgs<ExtArgs>>): Prisma__FormatClient<$Result.GetResult<Prisma.$FormatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Format.
     * @param {FormatUpdateArgs} args - Arguments to update one Format.
     * @example
     * // Update one Format
     * const format = await prisma.format.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormatUpdateArgs>(args: SelectSubset<T, FormatUpdateArgs<ExtArgs>>): Prisma__FormatClient<$Result.GetResult<Prisma.$FormatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Formats.
     * @param {FormatDeleteManyArgs} args - Arguments to filter Formats to delete.
     * @example
     * // Delete a few Formats
     * const { count } = await prisma.format.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormatDeleteManyArgs>(args?: SelectSubset<T, FormatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Formats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Formats
     * const format = await prisma.format.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormatUpdateManyArgs>(args: SelectSubset<T, FormatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Formats and returns the data updated in the database.
     * @param {FormatUpdateManyAndReturnArgs} args - Arguments to update many Formats.
     * @example
     * // Update many Formats
     * const format = await prisma.format.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Formats and only return the `id`
     * const formatWithIdOnly = await prisma.format.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FormatUpdateManyAndReturnArgs>(args: SelectSubset<T, FormatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Format.
     * @param {FormatUpsertArgs} args - Arguments to update or create a Format.
     * @example
     * // Update or create a Format
     * const format = await prisma.format.upsert({
     *   create: {
     *     // ... data to create a Format
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Format we want to update
     *   }
     * })
     */
    upsert<T extends FormatUpsertArgs>(args: SelectSubset<T, FormatUpsertArgs<ExtArgs>>): Prisma__FormatClient<$Result.GetResult<Prisma.$FormatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Formats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormatCountArgs} args - Arguments to filter Formats to count.
     * @example
     * // Count the number of Formats
     * const count = await prisma.format.count({
     *   where: {
     *     // ... the filter for the Formats we want to count
     *   }
     * })
    **/
    count<T extends FormatCountArgs>(
      args?: Subset<T, FormatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Format.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormatAggregateArgs>(args: Subset<T, FormatAggregateArgs>): Prisma.PrismaPromise<GetFormatAggregateType<T>>

    /**
     * Group by Format.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormatGroupByArgs['orderBy'] }
        : { orderBy?: FormatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Format model
   */
  readonly fields: FormatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Format.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Impression<T extends Format$ImpressionArgs<ExtArgs> = {}>(args?: Subset<T, Format$ImpressionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImpressionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Format model
   */
  interface FormatFieldRefs {
    readonly id: FieldRef<"Format", 'String'>
    readonly title: FieldRef<"Format", 'String'>
    readonly createdAt: FieldRef<"Format", 'DateTime'>
    readonly updatedAt: FieldRef<"Format", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Format findUnique
   */
  export type FormatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Format
     */
    select?: FormatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Format
     */
    omit?: FormatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormatInclude<ExtArgs> | null
    /**
     * Filter, which Format to fetch.
     */
    where: FormatWhereUniqueInput
  }

  /**
   * Format findUniqueOrThrow
   */
  export type FormatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Format
     */
    select?: FormatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Format
     */
    omit?: FormatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormatInclude<ExtArgs> | null
    /**
     * Filter, which Format to fetch.
     */
    where: FormatWhereUniqueInput
  }

  /**
   * Format findFirst
   */
  export type FormatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Format
     */
    select?: FormatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Format
     */
    omit?: FormatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormatInclude<ExtArgs> | null
    /**
     * Filter, which Format to fetch.
     */
    where?: FormatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Formats to fetch.
     */
    orderBy?: FormatOrderByWithRelationInput | FormatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Formats.
     */
    cursor?: FormatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Formats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Formats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Formats.
     */
    distinct?: FormatScalarFieldEnum | FormatScalarFieldEnum[]
  }

  /**
   * Format findFirstOrThrow
   */
  export type FormatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Format
     */
    select?: FormatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Format
     */
    omit?: FormatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormatInclude<ExtArgs> | null
    /**
     * Filter, which Format to fetch.
     */
    where?: FormatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Formats to fetch.
     */
    orderBy?: FormatOrderByWithRelationInput | FormatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Formats.
     */
    cursor?: FormatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Formats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Formats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Formats.
     */
    distinct?: FormatScalarFieldEnum | FormatScalarFieldEnum[]
  }

  /**
   * Format findMany
   */
  export type FormatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Format
     */
    select?: FormatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Format
     */
    omit?: FormatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormatInclude<ExtArgs> | null
    /**
     * Filter, which Formats to fetch.
     */
    where?: FormatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Formats to fetch.
     */
    orderBy?: FormatOrderByWithRelationInput | FormatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Formats.
     */
    cursor?: FormatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Formats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Formats.
     */
    skip?: number
    distinct?: FormatScalarFieldEnum | FormatScalarFieldEnum[]
  }

  /**
   * Format create
   */
  export type FormatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Format
     */
    select?: FormatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Format
     */
    omit?: FormatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormatInclude<ExtArgs> | null
    /**
     * The data needed to create a Format.
     */
    data: XOR<FormatCreateInput, FormatUncheckedCreateInput>
  }

  /**
   * Format createMany
   */
  export type FormatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Formats.
     */
    data: FormatCreateManyInput | FormatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Format createManyAndReturn
   */
  export type FormatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Format
     */
    select?: FormatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Format
     */
    omit?: FormatOmit<ExtArgs> | null
    /**
     * The data used to create many Formats.
     */
    data: FormatCreateManyInput | FormatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Format update
   */
  export type FormatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Format
     */
    select?: FormatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Format
     */
    omit?: FormatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormatInclude<ExtArgs> | null
    /**
     * The data needed to update a Format.
     */
    data: XOR<FormatUpdateInput, FormatUncheckedUpdateInput>
    /**
     * Choose, which Format to update.
     */
    where: FormatWhereUniqueInput
  }

  /**
   * Format updateMany
   */
  export type FormatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Formats.
     */
    data: XOR<FormatUpdateManyMutationInput, FormatUncheckedUpdateManyInput>
    /**
     * Filter which Formats to update
     */
    where?: FormatWhereInput
    /**
     * Limit how many Formats to update.
     */
    limit?: number
  }

  /**
   * Format updateManyAndReturn
   */
  export type FormatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Format
     */
    select?: FormatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Format
     */
    omit?: FormatOmit<ExtArgs> | null
    /**
     * The data used to update Formats.
     */
    data: XOR<FormatUpdateManyMutationInput, FormatUncheckedUpdateManyInput>
    /**
     * Filter which Formats to update
     */
    where?: FormatWhereInput
    /**
     * Limit how many Formats to update.
     */
    limit?: number
  }

  /**
   * Format upsert
   */
  export type FormatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Format
     */
    select?: FormatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Format
     */
    omit?: FormatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormatInclude<ExtArgs> | null
    /**
     * The filter to search for the Format to update in case it exists.
     */
    where: FormatWhereUniqueInput
    /**
     * In case the Format found by the `where` argument doesn't exist, create a new Format with this data.
     */
    create: XOR<FormatCreateInput, FormatUncheckedCreateInput>
    /**
     * In case the Format was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormatUpdateInput, FormatUncheckedUpdateInput>
  }

  /**
   * Format delete
   */
  export type FormatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Format
     */
    select?: FormatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Format
     */
    omit?: FormatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormatInclude<ExtArgs> | null
    /**
     * Filter which Format to delete.
     */
    where: FormatWhereUniqueInput
  }

  /**
   * Format deleteMany
   */
  export type FormatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Formats to delete
     */
    where?: FormatWhereInput
    /**
     * Limit how many Formats to delete.
     */
    limit?: number
  }

  /**
   * Format.Impression
   */
  export type Format$ImpressionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionInclude<ExtArgs> | null
    where?: ImpressionWhereInput
    orderBy?: ImpressionOrderByWithRelationInput | ImpressionOrderByWithRelationInput[]
    cursor?: ImpressionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImpressionScalarFieldEnum | ImpressionScalarFieldEnum[]
  }

  /**
   * Format without action
   */
  export type FormatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Format
     */
    select?: FormatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Format
     */
    omit?: FormatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormatInclude<ExtArgs> | null
  }


  /**
   * Model Genre
   */

  export type AggregateGenre = {
    _count: GenreCountAggregateOutputType | null
    _min: GenreMinAggregateOutputType | null
    _max: GenreMaxAggregateOutputType | null
  }

  export type GenreMinAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GenreMaxAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GenreCountAggregateOutputType = {
    id: number
    title: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GenreMinAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GenreMaxAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GenreCountAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GenreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genre to aggregate.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Genres
    **/
    _count?: true | GenreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenreMaxAggregateInputType
  }

  export type GetGenreAggregateType<T extends GenreAggregateArgs> = {
        [P in keyof T & keyof AggregateGenre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenre[P]>
      : GetScalarType<T[P], AggregateGenre[P]>
  }




  export type GenreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenreWhereInput
    orderBy?: GenreOrderByWithAggregationInput | GenreOrderByWithAggregationInput[]
    by: GenreScalarFieldEnum[] | GenreScalarFieldEnum
    having?: GenreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenreCountAggregateInputType | true
    _min?: GenreMinAggregateInputType
    _max?: GenreMaxAggregateInputType
  }

  export type GenreGroupByOutputType = {
    id: string
    title: string
    createdAt: Date
    updatedAt: Date
    _count: GenreCountAggregateOutputType | null
    _min: GenreMinAggregateOutputType | null
    _max: GenreMaxAggregateOutputType | null
  }

  type GetGenreGroupByPayload<T extends GenreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenreGroupByOutputType[P]>
            : GetScalarType<T[P], GenreGroupByOutputType[P]>
        }
      >
    >


  export type GenreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Impression?: boolean | Genre$ImpressionArgs<ExtArgs>
    _count?: boolean | GenreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectScalar = {
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GenreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "createdAt" | "updatedAt", ExtArgs["result"]["genre"]>
  export type GenreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Impression?: boolean | Genre$ImpressionArgs<ExtArgs>
    _count?: boolean | GenreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GenreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GenreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GenrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Genre"
    objects: {
      Impression: Prisma.$ImpressionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["genre"]>
    composites: {}
  }

  type GenreGetPayload<S extends boolean | null | undefined | GenreDefaultArgs> = $Result.GetResult<Prisma.$GenrePayload, S>

  type GenreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GenreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GenreCountAggregateInputType | true
    }

  export interface GenreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Genre'], meta: { name: 'Genre' } }
    /**
     * Find zero or one Genre that matches the filter.
     * @param {GenreFindUniqueArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GenreFindUniqueArgs>(args: SelectSubset<T, GenreFindUniqueArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Genre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GenreFindUniqueOrThrowArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GenreFindUniqueOrThrowArgs>(args: SelectSubset<T, GenreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Genre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindFirstArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GenreFindFirstArgs>(args?: SelectSubset<T, GenreFindFirstArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Genre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindFirstOrThrowArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GenreFindFirstOrThrowArgs>(args?: SelectSubset<T, GenreFindFirstOrThrowArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Genres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Genres
     * const genres = await prisma.genre.findMany()
     * 
     * // Get first 10 Genres
     * const genres = await prisma.genre.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genreWithIdOnly = await prisma.genre.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GenreFindManyArgs>(args?: SelectSubset<T, GenreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Genre.
     * @param {GenreCreateArgs} args - Arguments to create a Genre.
     * @example
     * // Create one Genre
     * const Genre = await prisma.genre.create({
     *   data: {
     *     // ... data to create a Genre
     *   }
     * })
     * 
     */
    create<T extends GenreCreateArgs>(args: SelectSubset<T, GenreCreateArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Genres.
     * @param {GenreCreateManyArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genre = await prisma.genre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GenreCreateManyArgs>(args?: SelectSubset<T, GenreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Genres and returns the data saved in the database.
     * @param {GenreCreateManyAndReturnArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genre = await prisma.genre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Genres and only return the `id`
     * const genreWithIdOnly = await prisma.genre.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GenreCreateManyAndReturnArgs>(args?: SelectSubset<T, GenreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Genre.
     * @param {GenreDeleteArgs} args - Arguments to delete one Genre.
     * @example
     * // Delete one Genre
     * const Genre = await prisma.genre.delete({
     *   where: {
     *     // ... filter to delete one Genre
     *   }
     * })
     * 
     */
    delete<T extends GenreDeleteArgs>(args: SelectSubset<T, GenreDeleteArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Genre.
     * @param {GenreUpdateArgs} args - Arguments to update one Genre.
     * @example
     * // Update one Genre
     * const genre = await prisma.genre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GenreUpdateArgs>(args: SelectSubset<T, GenreUpdateArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Genres.
     * @param {GenreDeleteManyArgs} args - Arguments to filter Genres to delete.
     * @example
     * // Delete a few Genres
     * const { count } = await prisma.genre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GenreDeleteManyArgs>(args?: SelectSubset<T, GenreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Genres
     * const genre = await prisma.genre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GenreUpdateManyArgs>(args: SelectSubset<T, GenreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genres and returns the data updated in the database.
     * @param {GenreUpdateManyAndReturnArgs} args - Arguments to update many Genres.
     * @example
     * // Update many Genres
     * const genre = await prisma.genre.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Genres and only return the `id`
     * const genreWithIdOnly = await prisma.genre.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GenreUpdateManyAndReturnArgs>(args: SelectSubset<T, GenreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Genre.
     * @param {GenreUpsertArgs} args - Arguments to update or create a Genre.
     * @example
     * // Update or create a Genre
     * const genre = await prisma.genre.upsert({
     *   create: {
     *     // ... data to create a Genre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Genre we want to update
     *   }
     * })
     */
    upsert<T extends GenreUpsertArgs>(args: SelectSubset<T, GenreUpsertArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreCountArgs} args - Arguments to filter Genres to count.
     * @example
     * // Count the number of Genres
     * const count = await prisma.genre.count({
     *   where: {
     *     // ... the filter for the Genres we want to count
     *   }
     * })
    **/
    count<T extends GenreCountArgs>(
      args?: Subset<T, GenreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenreAggregateArgs>(args: Subset<T, GenreAggregateArgs>): Prisma.PrismaPromise<GetGenreAggregateType<T>>

    /**
     * Group by Genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenreGroupByArgs['orderBy'] }
        : { orderBy?: GenreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Genre model
   */
  readonly fields: GenreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Genre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GenreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Impression<T extends Genre$ImpressionArgs<ExtArgs> = {}>(args?: Subset<T, Genre$ImpressionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImpressionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Genre model
   */
  interface GenreFieldRefs {
    readonly id: FieldRef<"Genre", 'String'>
    readonly title: FieldRef<"Genre", 'String'>
    readonly createdAt: FieldRef<"Genre", 'DateTime'>
    readonly updatedAt: FieldRef<"Genre", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Genre findUnique
   */
  export type GenreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre findUniqueOrThrow
   */
  export type GenreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre findFirst
   */
  export type GenreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genres.
     */
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre findFirstOrThrow
   */
  export type GenreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genres.
     */
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre findMany
   */
  export type GenreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genres to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre create
   */
  export type GenreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The data needed to create a Genre.
     */
    data: XOR<GenreCreateInput, GenreUncheckedCreateInput>
  }

  /**
   * Genre createMany
   */
  export type GenreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Genres.
     */
    data: GenreCreateManyInput | GenreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Genre createManyAndReturn
   */
  export type GenreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * The data used to create many Genres.
     */
    data: GenreCreateManyInput | GenreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Genre update
   */
  export type GenreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The data needed to update a Genre.
     */
    data: XOR<GenreUpdateInput, GenreUncheckedUpdateInput>
    /**
     * Choose, which Genre to update.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre updateMany
   */
  export type GenreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Genres.
     */
    data: XOR<GenreUpdateManyMutationInput, GenreUncheckedUpdateManyInput>
    /**
     * Filter which Genres to update
     */
    where?: GenreWhereInput
    /**
     * Limit how many Genres to update.
     */
    limit?: number
  }

  /**
   * Genre updateManyAndReturn
   */
  export type GenreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * The data used to update Genres.
     */
    data: XOR<GenreUpdateManyMutationInput, GenreUncheckedUpdateManyInput>
    /**
     * Filter which Genres to update
     */
    where?: GenreWhereInput
    /**
     * Limit how many Genres to update.
     */
    limit?: number
  }

  /**
   * Genre upsert
   */
  export type GenreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The filter to search for the Genre to update in case it exists.
     */
    where: GenreWhereUniqueInput
    /**
     * In case the Genre found by the `where` argument doesn't exist, create a new Genre with this data.
     */
    create: XOR<GenreCreateInput, GenreUncheckedCreateInput>
    /**
     * In case the Genre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenreUpdateInput, GenreUncheckedUpdateInput>
  }

  /**
   * Genre delete
   */
  export type GenreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter which Genre to delete.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre deleteMany
   */
  export type GenreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genres to delete
     */
    where?: GenreWhereInput
    /**
     * Limit how many Genres to delete.
     */
    limit?: number
  }

  /**
   * Genre.Impression
   */
  export type Genre$ImpressionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionInclude<ExtArgs> | null
    where?: ImpressionWhereInput
    orderBy?: ImpressionOrderByWithRelationInput | ImpressionOrderByWithRelationInput[]
    cursor?: ImpressionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImpressionScalarFieldEnum | ImpressionScalarFieldEnum[]
  }

  /**
   * Genre without action
   */
  export type GenreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
  }


  /**
   * Model Impression
   */

  export type AggregateImpression = {
    _count: ImpressionCountAggregateOutputType | null
    _avg: ImpressionAvgAggregateOutputType | null
    _sum: ImpressionSumAggregateOutputType | null
    _min: ImpressionMinAggregateOutputType | null
    _max: ImpressionMaxAggregateOutputType | null
  }

  export type ImpressionAvgAggregateOutputType = {
    pageCount: number | null
  }

  export type ImpressionSumAggregateOutputType = {
    pageCount: number | null
  }

  export type ImpressionMinAggregateOutputType = {
    id: string | null
    title: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    pageCount: number | null
    formatId: string | null
    genreId: string | null
    fileId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImpressionMaxAggregateOutputType = {
    id: string | null
    title: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    pageCount: number | null
    formatId: string | null
    genreId: string | null
    fileId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImpressionCountAggregateOutputType = {
    id: number
    title: number
    firstName: number
    lastName: number
    email: number
    pageCount: number
    formatId: number
    genreId: number
    fileId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ImpressionAvgAggregateInputType = {
    pageCount?: true
  }

  export type ImpressionSumAggregateInputType = {
    pageCount?: true
  }

  export type ImpressionMinAggregateInputType = {
    id?: true
    title?: true
    firstName?: true
    lastName?: true
    email?: true
    pageCount?: true
    formatId?: true
    genreId?: true
    fileId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImpressionMaxAggregateInputType = {
    id?: true
    title?: true
    firstName?: true
    lastName?: true
    email?: true
    pageCount?: true
    formatId?: true
    genreId?: true
    fileId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImpressionCountAggregateInputType = {
    id?: true
    title?: true
    firstName?: true
    lastName?: true
    email?: true
    pageCount?: true
    formatId?: true
    genreId?: true
    fileId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ImpressionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Impression to aggregate.
     */
    where?: ImpressionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Impressions to fetch.
     */
    orderBy?: ImpressionOrderByWithRelationInput | ImpressionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImpressionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Impressions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Impressions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Impressions
    **/
    _count?: true | ImpressionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImpressionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImpressionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImpressionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImpressionMaxAggregateInputType
  }

  export type GetImpressionAggregateType<T extends ImpressionAggregateArgs> = {
        [P in keyof T & keyof AggregateImpression]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImpression[P]>
      : GetScalarType<T[P], AggregateImpression[P]>
  }




  export type ImpressionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImpressionWhereInput
    orderBy?: ImpressionOrderByWithAggregationInput | ImpressionOrderByWithAggregationInput[]
    by: ImpressionScalarFieldEnum[] | ImpressionScalarFieldEnum
    having?: ImpressionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImpressionCountAggregateInputType | true
    _avg?: ImpressionAvgAggregateInputType
    _sum?: ImpressionSumAggregateInputType
    _min?: ImpressionMinAggregateInputType
    _max?: ImpressionMaxAggregateInputType
  }

  export type ImpressionGroupByOutputType = {
    id: string
    title: string
    firstName: string | null
    lastName: string | null
    email: string
    pageCount: number | null
    formatId: string | null
    genreId: string | null
    fileId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ImpressionCountAggregateOutputType | null
    _avg: ImpressionAvgAggregateOutputType | null
    _sum: ImpressionSumAggregateOutputType | null
    _min: ImpressionMinAggregateOutputType | null
    _max: ImpressionMaxAggregateOutputType | null
  }

  type GetImpressionGroupByPayload<T extends ImpressionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImpressionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImpressionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImpressionGroupByOutputType[P]>
            : GetScalarType<T[P], ImpressionGroupByOutputType[P]>
        }
      >
    >


  export type ImpressionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    pageCount?: boolean
    formatId?: boolean
    genreId?: boolean
    fileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    format?: boolean | Impression$formatArgs<ExtArgs>
    genre?: boolean | Impression$genreArgs<ExtArgs>
    file?: boolean | Impression$fileArgs<ExtArgs>
  }, ExtArgs["result"]["impression"]>

  export type ImpressionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    pageCount?: boolean
    formatId?: boolean
    genreId?: boolean
    fileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    format?: boolean | Impression$formatArgs<ExtArgs>
    genre?: boolean | Impression$genreArgs<ExtArgs>
    file?: boolean | Impression$fileArgs<ExtArgs>
  }, ExtArgs["result"]["impression"]>

  export type ImpressionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    pageCount?: boolean
    formatId?: boolean
    genreId?: boolean
    fileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    format?: boolean | Impression$formatArgs<ExtArgs>
    genre?: boolean | Impression$genreArgs<ExtArgs>
    file?: boolean | Impression$fileArgs<ExtArgs>
  }, ExtArgs["result"]["impression"]>

  export type ImpressionSelectScalar = {
    id?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    pageCount?: boolean
    formatId?: boolean
    genreId?: boolean
    fileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ImpressionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "firstName" | "lastName" | "email" | "pageCount" | "formatId" | "genreId" | "fileId" | "createdAt" | "updatedAt", ExtArgs["result"]["impression"]>
  export type ImpressionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    format?: boolean | Impression$formatArgs<ExtArgs>
    genre?: boolean | Impression$genreArgs<ExtArgs>
    file?: boolean | Impression$fileArgs<ExtArgs>
  }
  export type ImpressionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    format?: boolean | Impression$formatArgs<ExtArgs>
    genre?: boolean | Impression$genreArgs<ExtArgs>
    file?: boolean | Impression$fileArgs<ExtArgs>
  }
  export type ImpressionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    format?: boolean | Impression$formatArgs<ExtArgs>
    genre?: boolean | Impression$genreArgs<ExtArgs>
    file?: boolean | Impression$fileArgs<ExtArgs>
  }

  export type $ImpressionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Impression"
    objects: {
      format: Prisma.$FormatPayload<ExtArgs> | null
      genre: Prisma.$GenrePayload<ExtArgs> | null
      file: Prisma.$MediaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      firstName: string | null
      lastName: string | null
      email: string
      pageCount: number | null
      formatId: string | null
      genreId: string | null
      fileId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["impression"]>
    composites: {}
  }

  type ImpressionGetPayload<S extends boolean | null | undefined | ImpressionDefaultArgs> = $Result.GetResult<Prisma.$ImpressionPayload, S>

  type ImpressionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImpressionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImpressionCountAggregateInputType | true
    }

  export interface ImpressionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Impression'], meta: { name: 'Impression' } }
    /**
     * Find zero or one Impression that matches the filter.
     * @param {ImpressionFindUniqueArgs} args - Arguments to find a Impression
     * @example
     * // Get one Impression
     * const impression = await prisma.impression.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImpressionFindUniqueArgs>(args: SelectSubset<T, ImpressionFindUniqueArgs<ExtArgs>>): Prisma__ImpressionClient<$Result.GetResult<Prisma.$ImpressionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Impression that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImpressionFindUniqueOrThrowArgs} args - Arguments to find a Impression
     * @example
     * // Get one Impression
     * const impression = await prisma.impression.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImpressionFindUniqueOrThrowArgs>(args: SelectSubset<T, ImpressionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImpressionClient<$Result.GetResult<Prisma.$ImpressionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Impression that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpressionFindFirstArgs} args - Arguments to find a Impression
     * @example
     * // Get one Impression
     * const impression = await prisma.impression.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImpressionFindFirstArgs>(args?: SelectSubset<T, ImpressionFindFirstArgs<ExtArgs>>): Prisma__ImpressionClient<$Result.GetResult<Prisma.$ImpressionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Impression that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpressionFindFirstOrThrowArgs} args - Arguments to find a Impression
     * @example
     * // Get one Impression
     * const impression = await prisma.impression.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImpressionFindFirstOrThrowArgs>(args?: SelectSubset<T, ImpressionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImpressionClient<$Result.GetResult<Prisma.$ImpressionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Impressions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpressionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Impressions
     * const impressions = await prisma.impression.findMany()
     * 
     * // Get first 10 Impressions
     * const impressions = await prisma.impression.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const impressionWithIdOnly = await prisma.impression.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImpressionFindManyArgs>(args?: SelectSubset<T, ImpressionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImpressionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Impression.
     * @param {ImpressionCreateArgs} args - Arguments to create a Impression.
     * @example
     * // Create one Impression
     * const Impression = await prisma.impression.create({
     *   data: {
     *     // ... data to create a Impression
     *   }
     * })
     * 
     */
    create<T extends ImpressionCreateArgs>(args: SelectSubset<T, ImpressionCreateArgs<ExtArgs>>): Prisma__ImpressionClient<$Result.GetResult<Prisma.$ImpressionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Impressions.
     * @param {ImpressionCreateManyArgs} args - Arguments to create many Impressions.
     * @example
     * // Create many Impressions
     * const impression = await prisma.impression.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImpressionCreateManyArgs>(args?: SelectSubset<T, ImpressionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Impressions and returns the data saved in the database.
     * @param {ImpressionCreateManyAndReturnArgs} args - Arguments to create many Impressions.
     * @example
     * // Create many Impressions
     * const impression = await prisma.impression.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Impressions and only return the `id`
     * const impressionWithIdOnly = await prisma.impression.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImpressionCreateManyAndReturnArgs>(args?: SelectSubset<T, ImpressionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImpressionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Impression.
     * @param {ImpressionDeleteArgs} args - Arguments to delete one Impression.
     * @example
     * // Delete one Impression
     * const Impression = await prisma.impression.delete({
     *   where: {
     *     // ... filter to delete one Impression
     *   }
     * })
     * 
     */
    delete<T extends ImpressionDeleteArgs>(args: SelectSubset<T, ImpressionDeleteArgs<ExtArgs>>): Prisma__ImpressionClient<$Result.GetResult<Prisma.$ImpressionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Impression.
     * @param {ImpressionUpdateArgs} args - Arguments to update one Impression.
     * @example
     * // Update one Impression
     * const impression = await prisma.impression.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImpressionUpdateArgs>(args: SelectSubset<T, ImpressionUpdateArgs<ExtArgs>>): Prisma__ImpressionClient<$Result.GetResult<Prisma.$ImpressionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Impressions.
     * @param {ImpressionDeleteManyArgs} args - Arguments to filter Impressions to delete.
     * @example
     * // Delete a few Impressions
     * const { count } = await prisma.impression.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImpressionDeleteManyArgs>(args?: SelectSubset<T, ImpressionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Impressions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpressionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Impressions
     * const impression = await prisma.impression.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImpressionUpdateManyArgs>(args: SelectSubset<T, ImpressionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Impressions and returns the data updated in the database.
     * @param {ImpressionUpdateManyAndReturnArgs} args - Arguments to update many Impressions.
     * @example
     * // Update many Impressions
     * const impression = await prisma.impression.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Impressions and only return the `id`
     * const impressionWithIdOnly = await prisma.impression.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImpressionUpdateManyAndReturnArgs>(args: SelectSubset<T, ImpressionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImpressionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Impression.
     * @param {ImpressionUpsertArgs} args - Arguments to update or create a Impression.
     * @example
     * // Update or create a Impression
     * const impression = await prisma.impression.upsert({
     *   create: {
     *     // ... data to create a Impression
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Impression we want to update
     *   }
     * })
     */
    upsert<T extends ImpressionUpsertArgs>(args: SelectSubset<T, ImpressionUpsertArgs<ExtArgs>>): Prisma__ImpressionClient<$Result.GetResult<Prisma.$ImpressionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Impressions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpressionCountArgs} args - Arguments to filter Impressions to count.
     * @example
     * // Count the number of Impressions
     * const count = await prisma.impression.count({
     *   where: {
     *     // ... the filter for the Impressions we want to count
     *   }
     * })
    **/
    count<T extends ImpressionCountArgs>(
      args?: Subset<T, ImpressionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImpressionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Impression.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpressionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImpressionAggregateArgs>(args: Subset<T, ImpressionAggregateArgs>): Prisma.PrismaPromise<GetImpressionAggregateType<T>>

    /**
     * Group by Impression.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpressionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImpressionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImpressionGroupByArgs['orderBy'] }
        : { orderBy?: ImpressionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImpressionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImpressionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Impression model
   */
  readonly fields: ImpressionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Impression.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImpressionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    format<T extends Impression$formatArgs<ExtArgs> = {}>(args?: Subset<T, Impression$formatArgs<ExtArgs>>): Prisma__FormatClient<$Result.GetResult<Prisma.$FormatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    genre<T extends Impression$genreArgs<ExtArgs> = {}>(args?: Subset<T, Impression$genreArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    file<T extends Impression$fileArgs<ExtArgs> = {}>(args?: Subset<T, Impression$fileArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Impression model
   */
  interface ImpressionFieldRefs {
    readonly id: FieldRef<"Impression", 'String'>
    readonly title: FieldRef<"Impression", 'String'>
    readonly firstName: FieldRef<"Impression", 'String'>
    readonly lastName: FieldRef<"Impression", 'String'>
    readonly email: FieldRef<"Impression", 'String'>
    readonly pageCount: FieldRef<"Impression", 'Int'>
    readonly formatId: FieldRef<"Impression", 'String'>
    readonly genreId: FieldRef<"Impression", 'String'>
    readonly fileId: FieldRef<"Impression", 'String'>
    readonly createdAt: FieldRef<"Impression", 'DateTime'>
    readonly updatedAt: FieldRef<"Impression", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Impression findUnique
   */
  export type ImpressionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionInclude<ExtArgs> | null
    /**
     * Filter, which Impression to fetch.
     */
    where: ImpressionWhereUniqueInput
  }

  /**
   * Impression findUniqueOrThrow
   */
  export type ImpressionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionInclude<ExtArgs> | null
    /**
     * Filter, which Impression to fetch.
     */
    where: ImpressionWhereUniqueInput
  }

  /**
   * Impression findFirst
   */
  export type ImpressionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionInclude<ExtArgs> | null
    /**
     * Filter, which Impression to fetch.
     */
    where?: ImpressionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Impressions to fetch.
     */
    orderBy?: ImpressionOrderByWithRelationInput | ImpressionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Impressions.
     */
    cursor?: ImpressionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Impressions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Impressions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Impressions.
     */
    distinct?: ImpressionScalarFieldEnum | ImpressionScalarFieldEnum[]
  }

  /**
   * Impression findFirstOrThrow
   */
  export type ImpressionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionInclude<ExtArgs> | null
    /**
     * Filter, which Impression to fetch.
     */
    where?: ImpressionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Impressions to fetch.
     */
    orderBy?: ImpressionOrderByWithRelationInput | ImpressionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Impressions.
     */
    cursor?: ImpressionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Impressions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Impressions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Impressions.
     */
    distinct?: ImpressionScalarFieldEnum | ImpressionScalarFieldEnum[]
  }

  /**
   * Impression findMany
   */
  export type ImpressionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionInclude<ExtArgs> | null
    /**
     * Filter, which Impressions to fetch.
     */
    where?: ImpressionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Impressions to fetch.
     */
    orderBy?: ImpressionOrderByWithRelationInput | ImpressionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Impressions.
     */
    cursor?: ImpressionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Impressions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Impressions.
     */
    skip?: number
    distinct?: ImpressionScalarFieldEnum | ImpressionScalarFieldEnum[]
  }

  /**
   * Impression create
   */
  export type ImpressionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionInclude<ExtArgs> | null
    /**
     * The data needed to create a Impression.
     */
    data: XOR<ImpressionCreateInput, ImpressionUncheckedCreateInput>
  }

  /**
   * Impression createMany
   */
  export type ImpressionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Impressions.
     */
    data: ImpressionCreateManyInput | ImpressionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Impression createManyAndReturn
   */
  export type ImpressionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * The data used to create many Impressions.
     */
    data: ImpressionCreateManyInput | ImpressionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Impression update
   */
  export type ImpressionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionInclude<ExtArgs> | null
    /**
     * The data needed to update a Impression.
     */
    data: XOR<ImpressionUpdateInput, ImpressionUncheckedUpdateInput>
    /**
     * Choose, which Impression to update.
     */
    where: ImpressionWhereUniqueInput
  }

  /**
   * Impression updateMany
   */
  export type ImpressionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Impressions.
     */
    data: XOR<ImpressionUpdateManyMutationInput, ImpressionUncheckedUpdateManyInput>
    /**
     * Filter which Impressions to update
     */
    where?: ImpressionWhereInput
    /**
     * Limit how many Impressions to update.
     */
    limit?: number
  }

  /**
   * Impression updateManyAndReturn
   */
  export type ImpressionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * The data used to update Impressions.
     */
    data: XOR<ImpressionUpdateManyMutationInput, ImpressionUncheckedUpdateManyInput>
    /**
     * Filter which Impressions to update
     */
    where?: ImpressionWhereInput
    /**
     * Limit how many Impressions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Impression upsert
   */
  export type ImpressionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionInclude<ExtArgs> | null
    /**
     * The filter to search for the Impression to update in case it exists.
     */
    where: ImpressionWhereUniqueInput
    /**
     * In case the Impression found by the `where` argument doesn't exist, create a new Impression with this data.
     */
    create: XOR<ImpressionCreateInput, ImpressionUncheckedCreateInput>
    /**
     * In case the Impression was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImpressionUpdateInput, ImpressionUncheckedUpdateInput>
  }

  /**
   * Impression delete
   */
  export type ImpressionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionInclude<ExtArgs> | null
    /**
     * Filter which Impression to delete.
     */
    where: ImpressionWhereUniqueInput
  }

  /**
   * Impression deleteMany
   */
  export type ImpressionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Impressions to delete
     */
    where?: ImpressionWhereInput
    /**
     * Limit how many Impressions to delete.
     */
    limit?: number
  }

  /**
   * Impression.format
   */
  export type Impression$formatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Format
     */
    select?: FormatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Format
     */
    omit?: FormatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormatInclude<ExtArgs> | null
    where?: FormatWhereInput
  }

  /**
   * Impression.genre
   */
  export type Impression$genreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    where?: GenreWhereInput
  }

  /**
   * Impression.file
   */
  export type Impression$fileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Impression without action
   */
  export type ImpressionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impression
     */
    select?: ImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impression
     */
    omit?: ImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpressionInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    message: number
    isRead: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    message: string
    isRead: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "message" | "isRead" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      message: string
      isRead: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model SocialChannel
   */

  export type AggregateSocialChannel = {
    _count: SocialChannelCountAggregateOutputType | null
    _min: SocialChannelMinAggregateOutputType | null
    _max: SocialChannelMaxAggregateOutputType | null
  }

  export type SocialChannelMinAggregateOutputType = {
    id: string | null
    key: $Enums.SocialKey | null
    url: string | null
    entityId: string | null
    entityType: $Enums.SocialEntityType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialChannelMaxAggregateOutputType = {
    id: string | null
    key: $Enums.SocialKey | null
    url: string | null
    entityId: string | null
    entityType: $Enums.SocialEntityType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialChannelCountAggregateOutputType = {
    id: number
    key: number
    url: number
    entityId: number
    entityType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SocialChannelMinAggregateInputType = {
    id?: true
    key?: true
    url?: true
    entityId?: true
    entityType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialChannelMaxAggregateInputType = {
    id?: true
    key?: true
    url?: true
    entityId?: true
    entityType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialChannelCountAggregateInputType = {
    id?: true
    key?: true
    url?: true
    entityId?: true
    entityType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SocialChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialChannel to aggregate.
     */
    where?: SocialChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialChannels to fetch.
     */
    orderBy?: SocialChannelOrderByWithRelationInput | SocialChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialChannels
    **/
    _count?: true | SocialChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialChannelMaxAggregateInputType
  }

  export type GetSocialChannelAggregateType<T extends SocialChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialChannel[P]>
      : GetScalarType<T[P], AggregateSocialChannel[P]>
  }




  export type SocialChannelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialChannelWhereInput
    orderBy?: SocialChannelOrderByWithAggregationInput | SocialChannelOrderByWithAggregationInput[]
    by: SocialChannelScalarFieldEnum[] | SocialChannelScalarFieldEnum
    having?: SocialChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialChannelCountAggregateInputType | true
    _min?: SocialChannelMinAggregateInputType
    _max?: SocialChannelMaxAggregateInputType
  }

  export type SocialChannelGroupByOutputType = {
    id: string
    key: $Enums.SocialKey
    url: string | null
    entityId: string
    entityType: $Enums.SocialEntityType
    createdAt: Date
    updatedAt: Date
    _count: SocialChannelCountAggregateOutputType | null
    _min: SocialChannelMinAggregateOutputType | null
    _max: SocialChannelMaxAggregateOutputType | null
  }

  type GetSocialChannelGroupByPayload<T extends SocialChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialChannelGroupByOutputType[P]>
            : GetScalarType<T[P], SocialChannelGroupByOutputType[P]>
        }
      >
    >


  export type SocialChannelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    url?: boolean
    entityId?: boolean
    entityType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["socialChannel"]>

  export type SocialChannelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    url?: boolean
    entityId?: boolean
    entityType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["socialChannel"]>

  export type SocialChannelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    url?: boolean
    entityId?: boolean
    entityType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["socialChannel"]>

  export type SocialChannelSelectScalar = {
    id?: boolean
    key?: boolean
    url?: boolean
    entityId?: boolean
    entityType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SocialChannelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "url" | "entityId" | "entityType" | "createdAt" | "updatedAt", ExtArgs["result"]["socialChannel"]>

  export type $SocialChannelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SocialChannel"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: $Enums.SocialKey
      url: string | null
      entityId: string
      entityType: $Enums.SocialEntityType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["socialChannel"]>
    composites: {}
  }

  type SocialChannelGetPayload<S extends boolean | null | undefined | SocialChannelDefaultArgs> = $Result.GetResult<Prisma.$SocialChannelPayload, S>

  type SocialChannelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SocialChannelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SocialChannelCountAggregateInputType | true
    }

  export interface SocialChannelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialChannel'], meta: { name: 'SocialChannel' } }
    /**
     * Find zero or one SocialChannel that matches the filter.
     * @param {SocialChannelFindUniqueArgs} args - Arguments to find a SocialChannel
     * @example
     * // Get one SocialChannel
     * const socialChannel = await prisma.socialChannel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialChannelFindUniqueArgs>(args: SelectSubset<T, SocialChannelFindUniqueArgs<ExtArgs>>): Prisma__SocialChannelClient<$Result.GetResult<Prisma.$SocialChannelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SocialChannel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SocialChannelFindUniqueOrThrowArgs} args - Arguments to find a SocialChannel
     * @example
     * // Get one SocialChannel
     * const socialChannel = await prisma.socialChannel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialChannelFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialChannelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialChannelClient<$Result.GetResult<Prisma.$SocialChannelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialChannel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialChannelFindFirstArgs} args - Arguments to find a SocialChannel
     * @example
     * // Get one SocialChannel
     * const socialChannel = await prisma.socialChannel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialChannelFindFirstArgs>(args?: SelectSubset<T, SocialChannelFindFirstArgs<ExtArgs>>): Prisma__SocialChannelClient<$Result.GetResult<Prisma.$SocialChannelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialChannel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialChannelFindFirstOrThrowArgs} args - Arguments to find a SocialChannel
     * @example
     * // Get one SocialChannel
     * const socialChannel = await prisma.socialChannel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialChannelFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialChannelFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialChannelClient<$Result.GetResult<Prisma.$SocialChannelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SocialChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialChannelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialChannels
     * const socialChannels = await prisma.socialChannel.findMany()
     * 
     * // Get first 10 SocialChannels
     * const socialChannels = await prisma.socialChannel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socialChannelWithIdOnly = await prisma.socialChannel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SocialChannelFindManyArgs>(args?: SelectSubset<T, SocialChannelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialChannelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SocialChannel.
     * @param {SocialChannelCreateArgs} args - Arguments to create a SocialChannel.
     * @example
     * // Create one SocialChannel
     * const SocialChannel = await prisma.socialChannel.create({
     *   data: {
     *     // ... data to create a SocialChannel
     *   }
     * })
     * 
     */
    create<T extends SocialChannelCreateArgs>(args: SelectSubset<T, SocialChannelCreateArgs<ExtArgs>>): Prisma__SocialChannelClient<$Result.GetResult<Prisma.$SocialChannelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SocialChannels.
     * @param {SocialChannelCreateManyArgs} args - Arguments to create many SocialChannels.
     * @example
     * // Create many SocialChannels
     * const socialChannel = await prisma.socialChannel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialChannelCreateManyArgs>(args?: SelectSubset<T, SocialChannelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SocialChannels and returns the data saved in the database.
     * @param {SocialChannelCreateManyAndReturnArgs} args - Arguments to create many SocialChannels.
     * @example
     * // Create many SocialChannels
     * const socialChannel = await prisma.socialChannel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SocialChannels and only return the `id`
     * const socialChannelWithIdOnly = await prisma.socialChannel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SocialChannelCreateManyAndReturnArgs>(args?: SelectSubset<T, SocialChannelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialChannelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SocialChannel.
     * @param {SocialChannelDeleteArgs} args - Arguments to delete one SocialChannel.
     * @example
     * // Delete one SocialChannel
     * const SocialChannel = await prisma.socialChannel.delete({
     *   where: {
     *     // ... filter to delete one SocialChannel
     *   }
     * })
     * 
     */
    delete<T extends SocialChannelDeleteArgs>(args: SelectSubset<T, SocialChannelDeleteArgs<ExtArgs>>): Prisma__SocialChannelClient<$Result.GetResult<Prisma.$SocialChannelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SocialChannel.
     * @param {SocialChannelUpdateArgs} args - Arguments to update one SocialChannel.
     * @example
     * // Update one SocialChannel
     * const socialChannel = await prisma.socialChannel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialChannelUpdateArgs>(args: SelectSubset<T, SocialChannelUpdateArgs<ExtArgs>>): Prisma__SocialChannelClient<$Result.GetResult<Prisma.$SocialChannelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SocialChannels.
     * @param {SocialChannelDeleteManyArgs} args - Arguments to filter SocialChannels to delete.
     * @example
     * // Delete a few SocialChannels
     * const { count } = await prisma.socialChannel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialChannelDeleteManyArgs>(args?: SelectSubset<T, SocialChannelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialChannels
     * const socialChannel = await prisma.socialChannel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialChannelUpdateManyArgs>(args: SelectSubset<T, SocialChannelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialChannels and returns the data updated in the database.
     * @param {SocialChannelUpdateManyAndReturnArgs} args - Arguments to update many SocialChannels.
     * @example
     * // Update many SocialChannels
     * const socialChannel = await prisma.socialChannel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SocialChannels and only return the `id`
     * const socialChannelWithIdOnly = await prisma.socialChannel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SocialChannelUpdateManyAndReturnArgs>(args: SelectSubset<T, SocialChannelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialChannelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SocialChannel.
     * @param {SocialChannelUpsertArgs} args - Arguments to update or create a SocialChannel.
     * @example
     * // Update or create a SocialChannel
     * const socialChannel = await prisma.socialChannel.upsert({
     *   create: {
     *     // ... data to create a SocialChannel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialChannel we want to update
     *   }
     * })
     */
    upsert<T extends SocialChannelUpsertArgs>(args: SelectSubset<T, SocialChannelUpsertArgs<ExtArgs>>): Prisma__SocialChannelClient<$Result.GetResult<Prisma.$SocialChannelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SocialChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialChannelCountArgs} args - Arguments to filter SocialChannels to count.
     * @example
     * // Count the number of SocialChannels
     * const count = await prisma.socialChannel.count({
     *   where: {
     *     // ... the filter for the SocialChannels we want to count
     *   }
     * })
    **/
    count<T extends SocialChannelCountArgs>(
      args?: Subset<T, SocialChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialChannelAggregateArgs>(args: Subset<T, SocialChannelAggregateArgs>): Prisma.PrismaPromise<GetSocialChannelAggregateType<T>>

    /**
     * Group by SocialChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialChannelGroupByArgs['orderBy'] }
        : { orderBy?: SocialChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SocialChannel model
   */
  readonly fields: SocialChannelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialChannel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialChannelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SocialChannel model
   */
  interface SocialChannelFieldRefs {
    readonly id: FieldRef<"SocialChannel", 'String'>
    readonly key: FieldRef<"SocialChannel", 'SocialKey'>
    readonly url: FieldRef<"SocialChannel", 'String'>
    readonly entityId: FieldRef<"SocialChannel", 'String'>
    readonly entityType: FieldRef<"SocialChannel", 'SocialEntityType'>
    readonly createdAt: FieldRef<"SocialChannel", 'DateTime'>
    readonly updatedAt: FieldRef<"SocialChannel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SocialChannel findUnique
   */
  export type SocialChannelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialChannel
     */
    select?: SocialChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialChannel
     */
    omit?: SocialChannelOmit<ExtArgs> | null
    /**
     * Filter, which SocialChannel to fetch.
     */
    where: SocialChannelWhereUniqueInput
  }

  /**
   * SocialChannel findUniqueOrThrow
   */
  export type SocialChannelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialChannel
     */
    select?: SocialChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialChannel
     */
    omit?: SocialChannelOmit<ExtArgs> | null
    /**
     * Filter, which SocialChannel to fetch.
     */
    where: SocialChannelWhereUniqueInput
  }

  /**
   * SocialChannel findFirst
   */
  export type SocialChannelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialChannel
     */
    select?: SocialChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialChannel
     */
    omit?: SocialChannelOmit<ExtArgs> | null
    /**
     * Filter, which SocialChannel to fetch.
     */
    where?: SocialChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialChannels to fetch.
     */
    orderBy?: SocialChannelOrderByWithRelationInput | SocialChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialChannels.
     */
    cursor?: SocialChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialChannels.
     */
    distinct?: SocialChannelScalarFieldEnum | SocialChannelScalarFieldEnum[]
  }

  /**
   * SocialChannel findFirstOrThrow
   */
  export type SocialChannelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialChannel
     */
    select?: SocialChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialChannel
     */
    omit?: SocialChannelOmit<ExtArgs> | null
    /**
     * Filter, which SocialChannel to fetch.
     */
    where?: SocialChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialChannels to fetch.
     */
    orderBy?: SocialChannelOrderByWithRelationInput | SocialChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialChannels.
     */
    cursor?: SocialChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialChannels.
     */
    distinct?: SocialChannelScalarFieldEnum | SocialChannelScalarFieldEnum[]
  }

  /**
   * SocialChannel findMany
   */
  export type SocialChannelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialChannel
     */
    select?: SocialChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialChannel
     */
    omit?: SocialChannelOmit<ExtArgs> | null
    /**
     * Filter, which SocialChannels to fetch.
     */
    where?: SocialChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialChannels to fetch.
     */
    orderBy?: SocialChannelOrderByWithRelationInput | SocialChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialChannels.
     */
    cursor?: SocialChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialChannels.
     */
    skip?: number
    distinct?: SocialChannelScalarFieldEnum | SocialChannelScalarFieldEnum[]
  }

  /**
   * SocialChannel create
   */
  export type SocialChannelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialChannel
     */
    select?: SocialChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialChannel
     */
    omit?: SocialChannelOmit<ExtArgs> | null
    /**
     * The data needed to create a SocialChannel.
     */
    data: XOR<SocialChannelCreateInput, SocialChannelUncheckedCreateInput>
  }

  /**
   * SocialChannel createMany
   */
  export type SocialChannelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialChannels.
     */
    data: SocialChannelCreateManyInput | SocialChannelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SocialChannel createManyAndReturn
   */
  export type SocialChannelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialChannel
     */
    select?: SocialChannelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SocialChannel
     */
    omit?: SocialChannelOmit<ExtArgs> | null
    /**
     * The data used to create many SocialChannels.
     */
    data: SocialChannelCreateManyInput | SocialChannelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SocialChannel update
   */
  export type SocialChannelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialChannel
     */
    select?: SocialChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialChannel
     */
    omit?: SocialChannelOmit<ExtArgs> | null
    /**
     * The data needed to update a SocialChannel.
     */
    data: XOR<SocialChannelUpdateInput, SocialChannelUncheckedUpdateInput>
    /**
     * Choose, which SocialChannel to update.
     */
    where: SocialChannelWhereUniqueInput
  }

  /**
   * SocialChannel updateMany
   */
  export type SocialChannelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialChannels.
     */
    data: XOR<SocialChannelUpdateManyMutationInput, SocialChannelUncheckedUpdateManyInput>
    /**
     * Filter which SocialChannels to update
     */
    where?: SocialChannelWhereInput
    /**
     * Limit how many SocialChannels to update.
     */
    limit?: number
  }

  /**
   * SocialChannel updateManyAndReturn
   */
  export type SocialChannelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialChannel
     */
    select?: SocialChannelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SocialChannel
     */
    omit?: SocialChannelOmit<ExtArgs> | null
    /**
     * The data used to update SocialChannels.
     */
    data: XOR<SocialChannelUpdateManyMutationInput, SocialChannelUncheckedUpdateManyInput>
    /**
     * Filter which SocialChannels to update
     */
    where?: SocialChannelWhereInput
    /**
     * Limit how many SocialChannels to update.
     */
    limit?: number
  }

  /**
   * SocialChannel upsert
   */
  export type SocialChannelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialChannel
     */
    select?: SocialChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialChannel
     */
    omit?: SocialChannelOmit<ExtArgs> | null
    /**
     * The filter to search for the SocialChannel to update in case it exists.
     */
    where: SocialChannelWhereUniqueInput
    /**
     * In case the SocialChannel found by the `where` argument doesn't exist, create a new SocialChannel with this data.
     */
    create: XOR<SocialChannelCreateInput, SocialChannelUncheckedCreateInput>
    /**
     * In case the SocialChannel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialChannelUpdateInput, SocialChannelUncheckedUpdateInput>
  }

  /**
   * SocialChannel delete
   */
  export type SocialChannelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialChannel
     */
    select?: SocialChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialChannel
     */
    omit?: SocialChannelOmit<ExtArgs> | null
    /**
     * Filter which SocialChannel to delete.
     */
    where: SocialChannelWhereUniqueInput
  }

  /**
   * SocialChannel deleteMany
   */
  export type SocialChannelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialChannels to delete
     */
    where?: SocialChannelWhereInput
    /**
     * Limit how many SocialChannels to delete.
     */
    limit?: number
  }

  /**
   * SocialChannel without action
   */
  export type SocialChannelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialChannel
     */
    select?: SocialChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialChannel
     */
    omit?: SocialChannelOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const LanguageScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    slug: 'slug',
    isActive: 'isActive',
    isDefault: 'isDefault',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LanguageScalarFieldEnum = (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum]


  export const SettingsScalarFieldEnum: {
    id: 'id',
    siteName: 'siteName',
    siteUrl: 'siteUrl',
    deployWebhookUrl: 'deployWebhookUrl',
    logoUrl: 'logoUrl',
    scripts: 'scripts',
    seoId: 'seoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const WidgetScalarFieldEnum: {
    id: 'id',
    name: 'name',
    section: 'section',
    type: 'type',
    sort: 'sort',
    isEnabled: 'isEnabled',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WidgetScalarFieldEnum = (typeof WidgetScalarFieldEnum)[keyof typeof WidgetScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    expiresAt: 'expiresAt',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    firstName: 'firstName',
    lastName: 'lastName',
    password: 'password',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    profileImageId: 'profileImageId',
    bio: 'bio',
    imageUrl: 'imageUrl',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accountId: 'accountId',
    providerId: 'providerId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    scope: 'scope'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    expires: 'expires'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    name: 'name',
    key: 'key',
    url: 'url',
    size: 'size',
    type: 'type',
    altText: 'altText',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const SeoScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    canonicalUrl: 'canonicalUrl',
    version: 'version',
    noIndex: 'noIndex',
    noFollow: 'noFollow',
    ogTwitterType: 'ogTwitterType',
    ogTwitterTitle: 'ogTwitterTitle',
    ogTwitterDescription: 'ogTwitterDescription',
    ogTwitterImageId: 'ogTwitterImageId',
    ogTwitterLocale: 'ogTwitterLocale',
    ogTwitterUrl: 'ogTwitterUrl',
    rootId: 'rootId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SeoScalarFieldEnum = (typeof SeoScalarFieldEnum)[keyof typeof SeoScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    description: 'description',
    version: 'version',
    status: 'status',
    isLatest: 'isLatest',
    editorType: 'editorType',
    bodyData: 'bodyData',
    tiptapBodyData: 'tiptapBodyData',
    rootId: 'rootId',
    imageCoverId: 'imageCoverId',
    seoId: 'seoId',
    userId: 'userId',
    firstPublishedAt: 'firstPublishedAt',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const PostAuthorScalarFieldEnum: {
    postId: 'postId',
    userId: 'userId',
    sort: 'sort'
  };

  export type PostAuthorScalarFieldEnum = (typeof PostAuthorScalarFieldEnum)[keyof typeof PostAuthorScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    description: 'description',
    version: 'version',
    status: 'status',
    isLatest: 'isLatest',
    rootId: 'rootId',
    seoId: 'seoId',
    firstPublishedAt: 'firstPublishedAt',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const PostCategoryScalarFieldEnum: {
    postId: 'postId',
    categoryId: 'categoryId',
    sort: 'sort'
  };

  export type PostCategoryScalarFieldEnum = (typeof PostCategoryScalarFieldEnum)[keyof typeof PostCategoryScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    description: 'description',
    version: 'version',
    status: 'status',
    isLatest: 'isLatest',
    rootId: 'rootId',
    seoId: 'seoId',
    firstPublishedAt: 'firstPublishedAt',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const EmailSettingScalarFieldEnum: {
    id: 'id',
    emailSender: 'emailSender',
    emailSenderName: 'emailSenderName',
    emailResponse: 'emailResponse',
    emailProvider: 'emailProvider',
    emailApiKey: 'emailApiKey',
    maxEmailsPerDay: 'maxEmailsPerDay',
    subscriptionTemplateId: 'subscriptionTemplateId',
    freeEbookTemplateId: 'freeEbookTemplateId',
    webinarTemplateId: 'webinarTemplateId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailSettingScalarFieldEnum = (typeof EmailSettingScalarFieldEnum)[keyof typeof EmailSettingScalarFieldEnum]


  export const EmailTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    designData: 'designData',
    bodyHtml: 'bodyHtml',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailTemplateScalarFieldEnum = (typeof EmailTemplateScalarFieldEnum)[keyof typeof EmailTemplateScalarFieldEnum]


  export const EmailAudienceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailAudienceScalarFieldEnum = (typeof EmailAudienceScalarFieldEnum)[keyof typeof EmailAudienceScalarFieldEnum]


  export const EmailContactScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    emailVerified: 'emailVerified',
    isSubscriber: 'isSubscriber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailContactScalarFieldEnum = (typeof EmailContactScalarFieldEnum)[keyof typeof EmailContactScalarFieldEnum]


  export const EmailContactInteractionScalarFieldEnum: {
    id: 'id',
    interactionType: 'interactionType',
    interactionDate: 'interactionDate',
    contactId: 'contactId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailContactInteractionScalarFieldEnum = (typeof EmailContactInteractionScalarFieldEnum)[keyof typeof EmailContactInteractionScalarFieldEnum]


  export const EmailSingleSendScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subject: 'subject',
    designData: 'designData',
    bodyHtml: 'bodyHtml',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailSingleSendScalarFieldEnum = (typeof EmailSingleSendScalarFieldEnum)[keyof typeof EmailSingleSendScalarFieldEnum]


  export const EmailSubscriptionTokenScalarFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    expires: 'expires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailSubscriptionTokenScalarFieldEnum = (typeof EmailSubscriptionTokenScalarFieldEnum)[keyof typeof EmailSubscriptionTokenScalarFieldEnum]


  export const EmailSendLogScalarFieldEnum: {
    id: 'id',
    to: 'to',
    from: 'from',
    subject: 'subject',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailSendLogScalarFieldEnum = (typeof EmailSendLogScalarFieldEnum)[keyof typeof EmailSendLogScalarFieldEnum]


  export const EmailSingleSendLogScalarFieldEnum: {
    id: 'id',
    contactId: 'contactId',
    singleSendId: 'singleSendId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailSingleSendLogScalarFieldEnum = (typeof EmailSingleSendLogScalarFieldEnum)[keyof typeof EmailSingleSendLogScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    description: 'description',
    tiptapDescription: 'tiptapDescription',
    type: 'type',
    version: 'version',
    status: 'status',
    isLatest: 'isLatest',
    imageCoverId: 'imageCoverId',
    categoryId: 'categoryId',
    acquisitionMode: 'acquisitionMode',
    price: 'price',
    discountedPrice: 'discountedPrice',
    isFree: 'isFree',
    metadata: 'metadata',
    formId: 'formId',
    rootId: 'rootId',
    seoId: 'seoId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductCategoryScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    description: 'description',
    version: 'version',
    status: 'status',
    isLatest: 'isLatest',
    rootId: 'rootId',
    seoId: 'seoId',
    firstPublishedAt: 'firstPublishedAt',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]


  export const ProductGalleryScalarFieldEnum: {
    id: 'id',
    sort: 'sort',
    productId: 'productId',
    mediaId: 'mediaId'
  };

  export type ProductGalleryScalarFieldEnum = (typeof ProductGalleryScalarFieldEnum)[keyof typeof ProductGalleryScalarFieldEnum]


  export const ProductExtraScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    productId: 'productId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductExtraScalarFieldEnum = (typeof ProductExtraScalarFieldEnum)[keyof typeof ProductExtraScalarFieldEnum]


  export const ProductFAQScalarFieldEnum: {
    id: 'id',
    question: 'question',
    answer: 'answer',
    sort: 'sort',
    productId: 'productId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductFAQScalarFieldEnum = (typeof ProductFAQScalarFieldEnum)[keyof typeof ProductFAQScalarFieldEnum]


  export const AdCampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdCampaignScalarFieldEnum = (typeof AdCampaignScalarFieldEnum)[keyof typeof AdCampaignScalarFieldEnum]


  export const AdBlockScalarFieldEnum: {
    id: 'id',
    label: 'label',
    layoutType: 'layoutType',
    isActive: 'isActive',
    campaignId: 'campaignId',
    placement: 'placement',
    reference: 'reference',
    referenceCount: 'referenceCount',
    minWords: 'minWords',
    excludedPostIds: 'excludedPostIds',
    excludedCategoryIds: 'excludedCategoryIds',
    excludedTagIds: 'excludedTagIds',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdBlockScalarFieldEnum = (typeof AdBlockScalarFieldEnum)[keyof typeof AdBlockScalarFieldEnum]


  export const AdItemScalarFieldEnum: {
    id: 'id',
    sourceType: 'sourceType',
    adBlockId: 'adBlockId',
    title: 'title',
    description: 'description',
    imageUrl: 'imageUrl',
    url: 'url',
    postRootId: 'postRootId',
    productRootId: 'productRootId',
    sort: 'sort',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdItemScalarFieldEnum = (typeof AdItemScalarFieldEnum)[keyof typeof AdItemScalarFieldEnum]


  export const PurchaseScalarFieldEnum: {
    id: 'id',
    email: 'email',
    productId: 'productId',
    productRootId: 'productRootId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseScalarFieldEnum = (typeof PurchaseScalarFieldEnum)[keyof typeof PurchaseScalarFieldEnum]


  export const ContactFormScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    subject: 'subject',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactFormScalarFieldEnum = (typeof ContactFormScalarFieldEnum)[keyof typeof ContactFormScalarFieldEnum]


  export const FormScalarFieldEnum: {
    id: 'id',
    name: 'name',
    fields: 'fields',
    submitLabel: 'submitLabel',
    gtmEventName: 'gtmEventName',
    gtmCategory: 'gtmCategory',
    gtmLabel: 'gtmLabel',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FormScalarFieldEnum = (typeof FormScalarFieldEnum)[keyof typeof FormScalarFieldEnum]


  export const FormSubmissionScalarFieldEnum: {
    id: 'id',
    formId: 'formId',
    email: 'email',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FormSubmissionScalarFieldEnum = (typeof FormSubmissionScalarFieldEnum)[keyof typeof FormSubmissionScalarFieldEnum]


  export const FormatScalarFieldEnum: {
    id: 'id',
    title: 'title',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FormatScalarFieldEnum = (typeof FormatScalarFieldEnum)[keyof typeof FormatScalarFieldEnum]


  export const GenreScalarFieldEnum: {
    id: 'id',
    title: 'title',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GenreScalarFieldEnum = (typeof GenreScalarFieldEnum)[keyof typeof GenreScalarFieldEnum]


  export const ImpressionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    pageCount: 'pageCount',
    formatId: 'formatId',
    genreId: 'genreId',
    fileId: 'fileId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ImpressionScalarFieldEnum = (typeof ImpressionScalarFieldEnum)[keyof typeof ImpressionScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    message: 'message',
    isRead: 'isRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SocialChannelScalarFieldEnum: {
    id: 'id',
    key: 'key',
    url: 'url',
    entityId: 'entityId',
    entityType: 'entityType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SocialChannelScalarFieldEnum = (typeof SocialChannelScalarFieldEnum)[keyof typeof SocialChannelScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'WidgetSection'
   */
  export type EnumWidgetSectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WidgetSection'>
    


  /**
   * Reference to a field of type 'WidgetSection[]'
   */
  export type ListEnumWidgetSectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WidgetSection[]'>
    


  /**
   * Reference to a field of type 'WidgetType'
   */
  export type EnumWidgetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WidgetType'>
    


  /**
   * Reference to a field of type 'WidgetType[]'
   */
  export type ListEnumWidgetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WidgetType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


  /**
   * Reference to a field of type 'MediaType[]'
   */
  export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    


  /**
   * Reference to a field of type 'ContentStatus'
   */
  export type EnumContentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentStatus'>
    


  /**
   * Reference to a field of type 'ContentStatus[]'
   */
  export type ListEnumContentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentStatus[]'>
    


  /**
   * Reference to a field of type 'EditorType'
   */
  export type EnumEditorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EditorType'>
    


  /**
   * Reference to a field of type 'EditorType[]'
   */
  export type ListEnumEditorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EditorType[]'>
    


  /**
   * Reference to a field of type 'EmailProvider'
   */
  export type EnumEmailProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailProvider'>
    


  /**
   * Reference to a field of type 'EmailProvider[]'
   */
  export type ListEnumEmailProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailProvider[]'>
    


  /**
   * Reference to a field of type 'AudienceType'
   */
  export type EnumAudienceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AudienceType'>
    


  /**
   * Reference to a field of type 'AudienceType[]'
   */
  export type ListEnumAudienceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AudienceType[]'>
    


  /**
   * Reference to a field of type 'ProductType'
   */
  export type EnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType'>
    


  /**
   * Reference to a field of type 'ProductType[]'
   */
  export type ListEnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType[]'>
    


  /**
   * Reference to a field of type 'ProductAcquisitionMode'
   */
  export type EnumProductAcquisitionModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductAcquisitionMode'>
    


  /**
   * Reference to a field of type 'ProductAcquisitionMode[]'
   */
  export type ListEnumProductAcquisitionModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductAcquisitionMode[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'AdLayoutType'
   */
  export type EnumAdLayoutTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdLayoutType'>
    


  /**
   * Reference to a field of type 'AdLayoutType[]'
   */
  export type ListEnumAdLayoutTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdLayoutType[]'>
    


  /**
   * Reference to a field of type 'AdPositionPlacement'
   */
  export type EnumAdPositionPlacementFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdPositionPlacement'>
    


  /**
   * Reference to a field of type 'AdPositionPlacement[]'
   */
  export type ListEnumAdPositionPlacementFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdPositionPlacement[]'>
    


  /**
   * Reference to a field of type 'AdPositionReference'
   */
  export type EnumAdPositionReferenceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdPositionReference'>
    


  /**
   * Reference to a field of type 'AdPositionReference[]'
   */
  export type ListEnumAdPositionReferenceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdPositionReference[]'>
    


  /**
   * Reference to a field of type 'AdItemSourceType'
   */
  export type EnumAdItemSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdItemSourceType'>
    


  /**
   * Reference to a field of type 'AdItemSourceType[]'
   */
  export type ListEnumAdItemSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdItemSourceType[]'>
    


  /**
   * Reference to a field of type 'SocialKey'
   */
  export type EnumSocialKeyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SocialKey'>
    


  /**
   * Reference to a field of type 'SocialKey[]'
   */
  export type ListEnumSocialKeyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SocialKey[]'>
    


  /**
   * Reference to a field of type 'SocialEntityType'
   */
  export type EnumSocialEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SocialEntityType'>
    


  /**
   * Reference to a field of type 'SocialEntityType[]'
   */
  export type ListEnumSocialEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SocialEntityType[]'>
    
  /**
   * Deep Input Types
   */


  export type LanguageWhereInput = {
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    id?: StringFilter<"Language"> | string
    code?: StringFilter<"Language"> | string
    name?: StringFilter<"Language"> | string
    slug?: StringNullableFilter<"Language"> | string | null
    isActive?: BoolFilter<"Language"> | boolean
    isDefault?: BoolFilter<"Language"> | boolean
    createdAt?: DateTimeFilter<"Language"> | Date | string
    updatedAt?: DateTimeFilter<"Language"> | Date | string
  }

  export type LanguageOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LanguageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    name?: StringFilter<"Language"> | string
    slug?: StringNullableFilter<"Language"> | string | null
    isActive?: BoolFilter<"Language"> | boolean
    isDefault?: BoolFilter<"Language"> | boolean
    createdAt?: DateTimeFilter<"Language"> | Date | string
    updatedAt?: DateTimeFilter<"Language"> | Date | string
  }, "id" | "code">

  export type LanguageOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LanguageCountOrderByAggregateInput
    _max?: LanguageMaxOrderByAggregateInput
    _min?: LanguageMinOrderByAggregateInput
  }

  export type LanguageScalarWhereWithAggregatesInput = {
    AND?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    OR?: LanguageScalarWhereWithAggregatesInput[]
    NOT?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Language"> | string
    code?: StringWithAggregatesFilter<"Language"> | string
    name?: StringWithAggregatesFilter<"Language"> | string
    slug?: StringNullableWithAggregatesFilter<"Language"> | string | null
    isActive?: BoolWithAggregatesFilter<"Language"> | boolean
    isDefault?: BoolWithAggregatesFilter<"Language"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Language"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Language"> | Date | string
  }

  export type SettingsWhereInput = {
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    id?: StringFilter<"Settings"> | string
    siteName?: StringNullableFilter<"Settings"> | string | null
    siteUrl?: StringNullableFilter<"Settings"> | string | null
    deployWebhookUrl?: StringNullableFilter<"Settings"> | string | null
    logoUrl?: StringNullableFilter<"Settings"> | string | null
    scripts?: JsonFilter<"Settings">
    seoId?: StringNullableFilter<"Settings"> | string | null
    createdAt?: DateTimeFilter<"Settings"> | Date | string
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
    seo?: XOR<SeoNullableScalarRelationFilter, SeoWhereInput> | null
  }

  export type SettingsOrderByWithRelationInput = {
    id?: SortOrder
    siteName?: SortOrderInput | SortOrder
    siteUrl?: SortOrderInput | SortOrder
    deployWebhookUrl?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    scripts?: SortOrder
    seoId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seo?: SeoOrderByWithRelationInput
  }

  export type SettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    siteName?: StringNullableFilter<"Settings"> | string | null
    siteUrl?: StringNullableFilter<"Settings"> | string | null
    deployWebhookUrl?: StringNullableFilter<"Settings"> | string | null
    logoUrl?: StringNullableFilter<"Settings"> | string | null
    scripts?: JsonFilter<"Settings">
    seoId?: StringNullableFilter<"Settings"> | string | null
    createdAt?: DateTimeFilter<"Settings"> | Date | string
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
    seo?: XOR<SeoNullableScalarRelationFilter, SeoWhereInput> | null
  }, "id">

  export type SettingsOrderByWithAggregationInput = {
    id?: SortOrder
    siteName?: SortOrderInput | SortOrder
    siteUrl?: SortOrderInput | SortOrder
    deployWebhookUrl?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    scripts?: SortOrder
    seoId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SettingsCountOrderByAggregateInput
    _max?: SettingsMaxOrderByAggregateInput
    _min?: SettingsMinOrderByAggregateInput
  }

  export type SettingsScalarWhereWithAggregatesInput = {
    AND?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    OR?: SettingsScalarWhereWithAggregatesInput[]
    NOT?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Settings"> | string
    siteName?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    siteUrl?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    deployWebhookUrl?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    scripts?: JsonWithAggregatesFilter<"Settings">
    seoId?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Settings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Settings"> | Date | string
  }

  export type WidgetWhereInput = {
    AND?: WidgetWhereInput | WidgetWhereInput[]
    OR?: WidgetWhereInput[]
    NOT?: WidgetWhereInput | WidgetWhereInput[]
    id?: StringFilter<"Widget"> | string
    name?: StringFilter<"Widget"> | string
    section?: EnumWidgetSectionFilter<"Widget"> | $Enums.WidgetSection
    type?: EnumWidgetTypeFilter<"Widget"> | $Enums.WidgetType
    sort?: IntFilter<"Widget"> | number
    isEnabled?: BoolFilter<"Widget"> | boolean
    metadata?: JsonNullableFilter<"Widget">
    createdAt?: DateTimeFilter<"Widget"> | Date | string
    updatedAt?: DateTimeFilter<"Widget"> | Date | string
  }

  export type WidgetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    section?: SortOrder
    type?: SortOrder
    sort?: SortOrder
    isEnabled?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WidgetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WidgetWhereInput | WidgetWhereInput[]
    OR?: WidgetWhereInput[]
    NOT?: WidgetWhereInput | WidgetWhereInput[]
    name?: StringFilter<"Widget"> | string
    section?: EnumWidgetSectionFilter<"Widget"> | $Enums.WidgetSection
    type?: EnumWidgetTypeFilter<"Widget"> | $Enums.WidgetType
    sort?: IntFilter<"Widget"> | number
    isEnabled?: BoolFilter<"Widget"> | boolean
    metadata?: JsonNullableFilter<"Widget">
    createdAt?: DateTimeFilter<"Widget"> | Date | string
    updatedAt?: DateTimeFilter<"Widget"> | Date | string
  }, "id">

  export type WidgetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    section?: SortOrder
    type?: SortOrder
    sort?: SortOrder
    isEnabled?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WidgetCountOrderByAggregateInput
    _avg?: WidgetAvgOrderByAggregateInput
    _max?: WidgetMaxOrderByAggregateInput
    _min?: WidgetMinOrderByAggregateInput
    _sum?: WidgetSumOrderByAggregateInput
  }

  export type WidgetScalarWhereWithAggregatesInput = {
    AND?: WidgetScalarWhereWithAggregatesInput | WidgetScalarWhereWithAggregatesInput[]
    OR?: WidgetScalarWhereWithAggregatesInput[]
    NOT?: WidgetScalarWhereWithAggregatesInput | WidgetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Widget"> | string
    name?: StringWithAggregatesFilter<"Widget"> | string
    section?: EnumWidgetSectionWithAggregatesFilter<"Widget"> | $Enums.WidgetSection
    type?: EnumWidgetTypeWithAggregatesFilter<"Widget"> | $Enums.WidgetType
    sort?: IntWithAggregatesFilter<"Widget"> | number
    isEnabled?: BoolWithAggregatesFilter<"Widget"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Widget">
    createdAt?: DateTimeWithAggregatesFilter<"Widget"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Widget"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    token?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userId?: StringWithAggregatesFilter<"Session"> | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    profileImageId?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    imageUrl?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    profileImage?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    posts?: PostListRelationFilter
    postAuthors?: PostAuthorListRelationFilter
    notifications?: NotificationListRelationFilter
    products?: ProductListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    profileImageId?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileImage?: MediaOrderByWithRelationInput
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    postAuthors?: PostAuthorOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    profileImageId?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    imageUrl?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    profileImage?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    posts?: PostListRelationFilter
    postAuthors?: PostAuthorListRelationFilter
    notifications?: NotificationListRelationFilter
    products?: ProductListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    profileImageId?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    profileImageId?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    scope?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    scope?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    scope?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    scope?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    id?: StringFilter<"VerificationToken"> | string
    email?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    email_token?: VerificationTokenEmailTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    email?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "id" | "token" | "email_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerificationToken"> | string
    email?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    email?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    expires?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    email_token?: PasswordResetTokenEmailTokenCompoundUniqueInput
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    email?: StringFilter<"PasswordResetToken"> | string
    expires?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }, "id" | "token" | "email_token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    email?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expires?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: StringFilter<"Media"> | string
    name?: StringFilter<"Media"> | string
    key?: StringNullableFilter<"Media"> | string | null
    url?: StringFilter<"Media"> | string
    size?: IntNullableFilter<"Media"> | number | null
    type?: EnumMediaTypeFilter<"Media"> | $Enums.MediaType
    altText?: StringNullableFilter<"Media"> | string | null
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    post?: PostListRelationFilter
    seo?: SeoListRelationFilter
    product?: ProductListRelationFilter
    impression?: XOR<ImpressionNullableScalarRelationFilter, ImpressionWhereInput> | null
    products?: ProductGalleryListRelationFilter
    user?: UserListRelationFilter
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrderInput | SortOrder
    url?: SortOrder
    size?: SortOrderInput | SortOrder
    type?: SortOrder
    altText?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    post?: PostOrderByRelationAggregateInput
    seo?: SeoOrderByRelationAggregateInput
    product?: ProductOrderByRelationAggregateInput
    impression?: ImpressionOrderByWithRelationInput
    products?: ProductGalleryOrderByRelationAggregateInput
    user?: UserOrderByRelationAggregateInput
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    url?: string
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    name?: StringFilter<"Media"> | string
    key?: StringNullableFilter<"Media"> | string | null
    size?: IntNullableFilter<"Media"> | number | null
    type?: EnumMediaTypeFilter<"Media"> | $Enums.MediaType
    altText?: StringNullableFilter<"Media"> | string | null
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    post?: PostListRelationFilter
    seo?: SeoListRelationFilter
    product?: ProductListRelationFilter
    impression?: XOR<ImpressionNullableScalarRelationFilter, ImpressionWhereInput> | null
    products?: ProductGalleryListRelationFilter
    user?: UserListRelationFilter
  }, "id" | "url">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrderInput | SortOrder
    url?: SortOrder
    size?: SortOrderInput | SortOrder
    type?: SortOrder
    altText?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MediaCountOrderByAggregateInput
    _avg?: MediaAvgOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
    _sum?: MediaSumOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Media"> | string
    name?: StringWithAggregatesFilter<"Media"> | string
    key?: StringNullableWithAggregatesFilter<"Media"> | string | null
    url?: StringWithAggregatesFilter<"Media"> | string
    size?: IntNullableWithAggregatesFilter<"Media"> | number | null
    type?: EnumMediaTypeWithAggregatesFilter<"Media"> | $Enums.MediaType
    altText?: StringNullableWithAggregatesFilter<"Media"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
  }

  export type SeoWhereInput = {
    AND?: SeoWhereInput | SeoWhereInput[]
    OR?: SeoWhereInput[]
    NOT?: SeoWhereInput | SeoWhereInput[]
    id?: StringFilter<"Seo"> | string
    title?: StringFilter<"Seo"> | string
    description?: StringNullableFilter<"Seo"> | string | null
    canonicalUrl?: StringNullableFilter<"Seo"> | string | null
    version?: IntFilter<"Seo"> | number
    noIndex?: BoolFilter<"Seo"> | boolean
    noFollow?: BoolFilter<"Seo"> | boolean
    ogTwitterType?: StringNullableFilter<"Seo"> | string | null
    ogTwitterTitle?: StringNullableFilter<"Seo"> | string | null
    ogTwitterDescription?: StringNullableFilter<"Seo"> | string | null
    ogTwitterImageId?: StringNullableFilter<"Seo"> | string | null
    ogTwitterLocale?: StringNullableFilter<"Seo"> | string | null
    ogTwitterUrl?: StringNullableFilter<"Seo"> | string | null
    rootId?: StringNullableFilter<"Seo"> | string | null
    createdAt?: DateTimeFilter<"Seo"> | Date | string
    updatedAt?: DateTimeFilter<"Seo"> | Date | string
    ogTwitterImage?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    root?: XOR<SeoNullableScalarRelationFilter, SeoWhereInput> | null
    rootChildren?: SeoListRelationFilter
    settings?: SettingsListRelationFilter
    posts?: PostListRelationFilter
    categories?: CategoryListRelationFilter
    tags?: TagListRelationFilter
    products?: ProductListRelationFilter
    productCategories?: ProductCategoryListRelationFilter
  }

  export type SeoOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    canonicalUrl?: SortOrderInput | SortOrder
    version?: SortOrder
    noIndex?: SortOrder
    noFollow?: SortOrder
    ogTwitterType?: SortOrderInput | SortOrder
    ogTwitterTitle?: SortOrderInput | SortOrder
    ogTwitterDescription?: SortOrderInput | SortOrder
    ogTwitterImageId?: SortOrderInput | SortOrder
    ogTwitterLocale?: SortOrderInput | SortOrder
    ogTwitterUrl?: SortOrderInput | SortOrder
    rootId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ogTwitterImage?: MediaOrderByWithRelationInput
    root?: SeoOrderByWithRelationInput
    rootChildren?: SeoOrderByRelationAggregateInput
    settings?: SettingsOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    categories?: CategoryOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    productCategories?: ProductCategoryOrderByRelationAggregateInput
  }

  export type SeoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SeoWhereInput | SeoWhereInput[]
    OR?: SeoWhereInput[]
    NOT?: SeoWhereInput | SeoWhereInput[]
    title?: StringFilter<"Seo"> | string
    description?: StringNullableFilter<"Seo"> | string | null
    canonicalUrl?: StringNullableFilter<"Seo"> | string | null
    version?: IntFilter<"Seo"> | number
    noIndex?: BoolFilter<"Seo"> | boolean
    noFollow?: BoolFilter<"Seo"> | boolean
    ogTwitterType?: StringNullableFilter<"Seo"> | string | null
    ogTwitterTitle?: StringNullableFilter<"Seo"> | string | null
    ogTwitterDescription?: StringNullableFilter<"Seo"> | string | null
    ogTwitterImageId?: StringNullableFilter<"Seo"> | string | null
    ogTwitterLocale?: StringNullableFilter<"Seo"> | string | null
    ogTwitterUrl?: StringNullableFilter<"Seo"> | string | null
    rootId?: StringNullableFilter<"Seo"> | string | null
    createdAt?: DateTimeFilter<"Seo"> | Date | string
    updatedAt?: DateTimeFilter<"Seo"> | Date | string
    ogTwitterImage?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    root?: XOR<SeoNullableScalarRelationFilter, SeoWhereInput> | null
    rootChildren?: SeoListRelationFilter
    settings?: SettingsListRelationFilter
    posts?: PostListRelationFilter
    categories?: CategoryListRelationFilter
    tags?: TagListRelationFilter
    products?: ProductListRelationFilter
    productCategories?: ProductCategoryListRelationFilter
  }, "id">

  export type SeoOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    canonicalUrl?: SortOrderInput | SortOrder
    version?: SortOrder
    noIndex?: SortOrder
    noFollow?: SortOrder
    ogTwitterType?: SortOrderInput | SortOrder
    ogTwitterTitle?: SortOrderInput | SortOrder
    ogTwitterDescription?: SortOrderInput | SortOrder
    ogTwitterImageId?: SortOrderInput | SortOrder
    ogTwitterLocale?: SortOrderInput | SortOrder
    ogTwitterUrl?: SortOrderInput | SortOrder
    rootId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SeoCountOrderByAggregateInput
    _avg?: SeoAvgOrderByAggregateInput
    _max?: SeoMaxOrderByAggregateInput
    _min?: SeoMinOrderByAggregateInput
    _sum?: SeoSumOrderByAggregateInput
  }

  export type SeoScalarWhereWithAggregatesInput = {
    AND?: SeoScalarWhereWithAggregatesInput | SeoScalarWhereWithAggregatesInput[]
    OR?: SeoScalarWhereWithAggregatesInput[]
    NOT?: SeoScalarWhereWithAggregatesInput | SeoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Seo"> | string
    title?: StringWithAggregatesFilter<"Seo"> | string
    description?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    canonicalUrl?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    version?: IntWithAggregatesFilter<"Seo"> | number
    noIndex?: BoolWithAggregatesFilter<"Seo"> | boolean
    noFollow?: BoolWithAggregatesFilter<"Seo"> | boolean
    ogTwitterType?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    ogTwitterTitle?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    ogTwitterDescription?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    ogTwitterImageId?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    ogTwitterLocale?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    ogTwitterUrl?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    rootId?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Seo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Seo"> | Date | string
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: StringFilter<"Post"> | string
    title?: StringFilter<"Post"> | string
    slug?: StringFilter<"Post"> | string
    description?: StringNullableFilter<"Post"> | string | null
    version?: IntFilter<"Post"> | number
    status?: EnumContentStatusFilter<"Post"> | $Enums.ContentStatus
    isLatest?: BoolFilter<"Post"> | boolean
    editorType?: EnumEditorTypeFilter<"Post"> | $Enums.EditorType
    bodyData?: JsonFilter<"Post">
    tiptapBodyData?: JsonNullableFilter<"Post">
    rootId?: StringNullableFilter<"Post"> | string | null
    imageCoverId?: StringNullableFilter<"Post"> | string | null
    seoId?: StringNullableFilter<"Post"> | string | null
    userId?: StringNullableFilter<"Post"> | string | null
    firstPublishedAt?: DateTimeFilter<"Post"> | Date | string
    publishedAt?: DateTimeFilter<"Post"> | Date | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    root?: XOR<PostNullableScalarRelationFilter, PostWhereInput> | null
    rootChildren?: PostListRelationFilter
    imageCover?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    postCategories?: PostCategoryListRelationFilter
    tags?: TagListRelationFilter
    seo?: XOR<SeoNullableScalarRelationFilter, SeoWhereInput> | null
    postAuthors?: PostAuthorListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    editorType?: SortOrder
    bodyData?: SortOrder
    tiptapBodyData?: SortOrderInput | SortOrder
    rootId?: SortOrderInput | SortOrder
    imageCoverId?: SortOrderInput | SortOrder
    seoId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    firstPublishedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    root?: PostOrderByWithRelationInput
    rootChildren?: PostOrderByRelationAggregateInput
    imageCover?: MediaOrderByWithRelationInput
    postCategories?: PostCategoryOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    seo?: SeoOrderByWithRelationInput
    postAuthors?: PostAuthorOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    title?: StringFilter<"Post"> | string
    slug?: StringFilter<"Post"> | string
    description?: StringNullableFilter<"Post"> | string | null
    version?: IntFilter<"Post"> | number
    status?: EnumContentStatusFilter<"Post"> | $Enums.ContentStatus
    isLatest?: BoolFilter<"Post"> | boolean
    editorType?: EnumEditorTypeFilter<"Post"> | $Enums.EditorType
    bodyData?: JsonFilter<"Post">
    tiptapBodyData?: JsonNullableFilter<"Post">
    rootId?: StringNullableFilter<"Post"> | string | null
    imageCoverId?: StringNullableFilter<"Post"> | string | null
    seoId?: StringNullableFilter<"Post"> | string | null
    userId?: StringNullableFilter<"Post"> | string | null
    firstPublishedAt?: DateTimeFilter<"Post"> | Date | string
    publishedAt?: DateTimeFilter<"Post"> | Date | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    root?: XOR<PostNullableScalarRelationFilter, PostWhereInput> | null
    rootChildren?: PostListRelationFilter
    imageCover?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    postCategories?: PostCategoryListRelationFilter
    tags?: TagListRelationFilter
    seo?: XOR<SeoNullableScalarRelationFilter, SeoWhereInput> | null
    postAuthors?: PostAuthorListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    editorType?: SortOrder
    bodyData?: SortOrder
    tiptapBodyData?: SortOrderInput | SortOrder
    rootId?: SortOrderInput | SortOrder
    imageCoverId?: SortOrderInput | SortOrder
    seoId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    firstPublishedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Post"> | string
    title?: StringWithAggregatesFilter<"Post"> | string
    slug?: StringWithAggregatesFilter<"Post"> | string
    description?: StringNullableWithAggregatesFilter<"Post"> | string | null
    version?: IntWithAggregatesFilter<"Post"> | number
    status?: EnumContentStatusWithAggregatesFilter<"Post"> | $Enums.ContentStatus
    isLatest?: BoolWithAggregatesFilter<"Post"> | boolean
    editorType?: EnumEditorTypeWithAggregatesFilter<"Post"> | $Enums.EditorType
    bodyData?: JsonWithAggregatesFilter<"Post">
    tiptapBodyData?: JsonNullableWithAggregatesFilter<"Post">
    rootId?: StringNullableWithAggregatesFilter<"Post"> | string | null
    imageCoverId?: StringNullableWithAggregatesFilter<"Post"> | string | null
    seoId?: StringNullableWithAggregatesFilter<"Post"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Post"> | string | null
    firstPublishedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    publishedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
  }

  export type PostAuthorWhereInput = {
    AND?: PostAuthorWhereInput | PostAuthorWhereInput[]
    OR?: PostAuthorWhereInput[]
    NOT?: PostAuthorWhereInput | PostAuthorWhereInput[]
    postId?: StringFilter<"PostAuthor"> | string
    userId?: StringFilter<"PostAuthor"> | string
    sort?: IntFilter<"PostAuthor"> | number
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PostAuthorOrderByWithRelationInput = {
    postId?: SortOrder
    userId?: SortOrder
    sort?: SortOrder
    post?: PostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PostAuthorWhereUniqueInput = Prisma.AtLeast<{
    postId_userId?: PostAuthorPostIdUserIdCompoundUniqueInput
    AND?: PostAuthorWhereInput | PostAuthorWhereInput[]
    OR?: PostAuthorWhereInput[]
    NOT?: PostAuthorWhereInput | PostAuthorWhereInput[]
    postId?: StringFilter<"PostAuthor"> | string
    userId?: StringFilter<"PostAuthor"> | string
    sort?: IntFilter<"PostAuthor"> | number
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "postId_userId">

  export type PostAuthorOrderByWithAggregationInput = {
    postId?: SortOrder
    userId?: SortOrder
    sort?: SortOrder
    _count?: PostAuthorCountOrderByAggregateInput
    _avg?: PostAuthorAvgOrderByAggregateInput
    _max?: PostAuthorMaxOrderByAggregateInput
    _min?: PostAuthorMinOrderByAggregateInput
    _sum?: PostAuthorSumOrderByAggregateInput
  }

  export type PostAuthorScalarWhereWithAggregatesInput = {
    AND?: PostAuthorScalarWhereWithAggregatesInput | PostAuthorScalarWhereWithAggregatesInput[]
    OR?: PostAuthorScalarWhereWithAggregatesInput[]
    NOT?: PostAuthorScalarWhereWithAggregatesInput | PostAuthorScalarWhereWithAggregatesInput[]
    postId?: StringWithAggregatesFilter<"PostAuthor"> | string
    userId?: StringWithAggregatesFilter<"PostAuthor"> | string
    sort?: IntWithAggregatesFilter<"PostAuthor"> | number
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    title?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    version?: IntFilter<"Category"> | number
    status?: EnumContentStatusFilter<"Category"> | $Enums.ContentStatus
    isLatest?: BoolFilter<"Category"> | boolean
    rootId?: StringNullableFilter<"Category"> | string | null
    seoId?: StringNullableFilter<"Category"> | string | null
    firstPublishedAt?: DateTimeFilter<"Category"> | Date | string
    publishedAt?: DateTimeFilter<"Category"> | Date | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    root?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    rootChildren?: CategoryListRelationFilter
    postCategories?: PostCategoryListRelationFilter
    seo?: XOR<SeoNullableScalarRelationFilter, SeoWhereInput> | null
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    rootId?: SortOrderInput | SortOrder
    seoId?: SortOrderInput | SortOrder
    firstPublishedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    root?: CategoryOrderByWithRelationInput
    rootChildren?: CategoryOrderByRelationAggregateInput
    postCategories?: PostCategoryOrderByRelationAggregateInput
    seo?: SeoOrderByWithRelationInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    title?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    version?: IntFilter<"Category"> | number
    status?: EnumContentStatusFilter<"Category"> | $Enums.ContentStatus
    isLatest?: BoolFilter<"Category"> | boolean
    rootId?: StringNullableFilter<"Category"> | string | null
    seoId?: StringNullableFilter<"Category"> | string | null
    firstPublishedAt?: DateTimeFilter<"Category"> | Date | string
    publishedAt?: DateTimeFilter<"Category"> | Date | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    root?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    rootChildren?: CategoryListRelationFilter
    postCategories?: PostCategoryListRelationFilter
    seo?: XOR<SeoNullableScalarRelationFilter, SeoWhereInput> | null
  }, "id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    rootId?: SortOrderInput | SortOrder
    seoId?: SortOrderInput | SortOrder
    firstPublishedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    title?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    version?: IntWithAggregatesFilter<"Category"> | number
    status?: EnumContentStatusWithAggregatesFilter<"Category"> | $Enums.ContentStatus
    isLatest?: BoolWithAggregatesFilter<"Category"> | boolean
    rootId?: StringNullableWithAggregatesFilter<"Category"> | string | null
    seoId?: StringNullableWithAggregatesFilter<"Category"> | string | null
    firstPublishedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    publishedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type PostCategoryWhereInput = {
    AND?: PostCategoryWhereInput | PostCategoryWhereInput[]
    OR?: PostCategoryWhereInput[]
    NOT?: PostCategoryWhereInput | PostCategoryWhereInput[]
    postId?: StringFilter<"PostCategory"> | string
    categoryId?: StringFilter<"PostCategory"> | string
    sort?: IntFilter<"PostCategory"> | number
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }

  export type PostCategoryOrderByWithRelationInput = {
    postId?: SortOrder
    categoryId?: SortOrder
    sort?: SortOrder
    post?: PostOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
  }

  export type PostCategoryWhereUniqueInput = Prisma.AtLeast<{
    postId_categoryId?: PostCategoryPostIdCategoryIdCompoundUniqueInput
    AND?: PostCategoryWhereInput | PostCategoryWhereInput[]
    OR?: PostCategoryWhereInput[]
    NOT?: PostCategoryWhereInput | PostCategoryWhereInput[]
    postId?: StringFilter<"PostCategory"> | string
    categoryId?: StringFilter<"PostCategory"> | string
    sort?: IntFilter<"PostCategory"> | number
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }, "postId_categoryId">

  export type PostCategoryOrderByWithAggregationInput = {
    postId?: SortOrder
    categoryId?: SortOrder
    sort?: SortOrder
    _count?: PostCategoryCountOrderByAggregateInput
    _avg?: PostCategoryAvgOrderByAggregateInput
    _max?: PostCategoryMaxOrderByAggregateInput
    _min?: PostCategoryMinOrderByAggregateInput
    _sum?: PostCategorySumOrderByAggregateInput
  }

  export type PostCategoryScalarWhereWithAggregatesInput = {
    AND?: PostCategoryScalarWhereWithAggregatesInput | PostCategoryScalarWhereWithAggregatesInput[]
    OR?: PostCategoryScalarWhereWithAggregatesInput[]
    NOT?: PostCategoryScalarWhereWithAggregatesInput | PostCategoryScalarWhereWithAggregatesInput[]
    postId?: StringWithAggregatesFilter<"PostCategory"> | string
    categoryId?: StringWithAggregatesFilter<"PostCategory"> | string
    sort?: IntWithAggregatesFilter<"PostCategory"> | number
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    title?: StringFilter<"Tag"> | string
    slug?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    version?: IntFilter<"Tag"> | number
    status?: EnumContentStatusFilter<"Tag"> | $Enums.ContentStatus
    isLatest?: BoolFilter<"Tag"> | boolean
    rootId?: StringNullableFilter<"Tag"> | string | null
    seoId?: StringNullableFilter<"Tag"> | string | null
    firstPublishedAt?: DateTimeFilter<"Tag"> | Date | string
    publishedAt?: DateTimeFilter<"Tag"> | Date | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    root?: XOR<TagNullableScalarRelationFilter, TagWhereInput> | null
    rootChildren?: TagListRelationFilter
    posts?: PostListRelationFilter
    seo?: XOR<SeoNullableScalarRelationFilter, SeoWhereInput> | null
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    rootId?: SortOrderInput | SortOrder
    seoId?: SortOrderInput | SortOrder
    firstPublishedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    root?: TagOrderByWithRelationInput
    rootChildren?: TagOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    seo?: SeoOrderByWithRelationInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    title?: StringFilter<"Tag"> | string
    slug?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    version?: IntFilter<"Tag"> | number
    status?: EnumContentStatusFilter<"Tag"> | $Enums.ContentStatus
    isLatest?: BoolFilter<"Tag"> | boolean
    rootId?: StringNullableFilter<"Tag"> | string | null
    seoId?: StringNullableFilter<"Tag"> | string | null
    firstPublishedAt?: DateTimeFilter<"Tag"> | Date | string
    publishedAt?: DateTimeFilter<"Tag"> | Date | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    root?: XOR<TagNullableScalarRelationFilter, TagWhereInput> | null
    rootChildren?: TagListRelationFilter
    posts?: PostListRelationFilter
    seo?: XOR<SeoNullableScalarRelationFilter, SeoWhereInput> | null
  }, "id">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    rootId?: SortOrderInput | SortOrder
    seoId?: SortOrderInput | SortOrder
    firstPublishedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _avg?: TagAvgOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
    _sum?: TagSumOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    title?: StringWithAggregatesFilter<"Tag"> | string
    slug?: StringWithAggregatesFilter<"Tag"> | string
    description?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    version?: IntWithAggregatesFilter<"Tag"> | number
    status?: EnumContentStatusWithAggregatesFilter<"Tag"> | $Enums.ContentStatus
    isLatest?: BoolWithAggregatesFilter<"Tag"> | boolean
    rootId?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    seoId?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    firstPublishedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    publishedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type EmailSettingWhereInput = {
    AND?: EmailSettingWhereInput | EmailSettingWhereInput[]
    OR?: EmailSettingWhereInput[]
    NOT?: EmailSettingWhereInput | EmailSettingWhereInput[]
    id?: StringFilter<"EmailSetting"> | string
    emailSender?: StringNullableFilter<"EmailSetting"> | string | null
    emailSenderName?: StringNullableFilter<"EmailSetting"> | string | null
    emailResponse?: StringNullableFilter<"EmailSetting"> | string | null
    emailProvider?: EnumEmailProviderNullableFilter<"EmailSetting"> | $Enums.EmailProvider | null
    emailApiKey?: StringNullableFilter<"EmailSetting"> | string | null
    maxEmailsPerDay?: IntNullableFilter<"EmailSetting"> | number | null
    subscriptionTemplateId?: StringNullableFilter<"EmailSetting"> | string | null
    freeEbookTemplateId?: StringNullableFilter<"EmailSetting"> | string | null
    webinarTemplateId?: StringNullableFilter<"EmailSetting"> | string | null
    createdAt?: DateTimeFilter<"EmailSetting"> | Date | string
    updatedAt?: DateTimeFilter<"EmailSetting"> | Date | string
    subscriptionTemplate?: XOR<EmailTemplateNullableScalarRelationFilter, EmailTemplateWhereInput> | null
    freeEbookTemplate?: XOR<EmailTemplateNullableScalarRelationFilter, EmailTemplateWhereInput> | null
    webinarTemplate?: XOR<EmailTemplateNullableScalarRelationFilter, EmailTemplateWhereInput> | null
  }

  export type EmailSettingOrderByWithRelationInput = {
    id?: SortOrder
    emailSender?: SortOrderInput | SortOrder
    emailSenderName?: SortOrderInput | SortOrder
    emailResponse?: SortOrderInput | SortOrder
    emailProvider?: SortOrderInput | SortOrder
    emailApiKey?: SortOrderInput | SortOrder
    maxEmailsPerDay?: SortOrderInput | SortOrder
    subscriptionTemplateId?: SortOrderInput | SortOrder
    freeEbookTemplateId?: SortOrderInput | SortOrder
    webinarTemplateId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscriptionTemplate?: EmailTemplateOrderByWithRelationInput
    freeEbookTemplate?: EmailTemplateOrderByWithRelationInput
    webinarTemplate?: EmailTemplateOrderByWithRelationInput
  }

  export type EmailSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailSettingWhereInput | EmailSettingWhereInput[]
    OR?: EmailSettingWhereInput[]
    NOT?: EmailSettingWhereInput | EmailSettingWhereInput[]
    emailSender?: StringNullableFilter<"EmailSetting"> | string | null
    emailSenderName?: StringNullableFilter<"EmailSetting"> | string | null
    emailResponse?: StringNullableFilter<"EmailSetting"> | string | null
    emailProvider?: EnumEmailProviderNullableFilter<"EmailSetting"> | $Enums.EmailProvider | null
    emailApiKey?: StringNullableFilter<"EmailSetting"> | string | null
    maxEmailsPerDay?: IntNullableFilter<"EmailSetting"> | number | null
    subscriptionTemplateId?: StringNullableFilter<"EmailSetting"> | string | null
    freeEbookTemplateId?: StringNullableFilter<"EmailSetting"> | string | null
    webinarTemplateId?: StringNullableFilter<"EmailSetting"> | string | null
    createdAt?: DateTimeFilter<"EmailSetting"> | Date | string
    updatedAt?: DateTimeFilter<"EmailSetting"> | Date | string
    subscriptionTemplate?: XOR<EmailTemplateNullableScalarRelationFilter, EmailTemplateWhereInput> | null
    freeEbookTemplate?: XOR<EmailTemplateNullableScalarRelationFilter, EmailTemplateWhereInput> | null
    webinarTemplate?: XOR<EmailTemplateNullableScalarRelationFilter, EmailTemplateWhereInput> | null
  }, "id">

  export type EmailSettingOrderByWithAggregationInput = {
    id?: SortOrder
    emailSender?: SortOrderInput | SortOrder
    emailSenderName?: SortOrderInput | SortOrder
    emailResponse?: SortOrderInput | SortOrder
    emailProvider?: SortOrderInput | SortOrder
    emailApiKey?: SortOrderInput | SortOrder
    maxEmailsPerDay?: SortOrderInput | SortOrder
    subscriptionTemplateId?: SortOrderInput | SortOrder
    freeEbookTemplateId?: SortOrderInput | SortOrder
    webinarTemplateId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailSettingCountOrderByAggregateInput
    _avg?: EmailSettingAvgOrderByAggregateInput
    _max?: EmailSettingMaxOrderByAggregateInput
    _min?: EmailSettingMinOrderByAggregateInput
    _sum?: EmailSettingSumOrderByAggregateInput
  }

  export type EmailSettingScalarWhereWithAggregatesInput = {
    AND?: EmailSettingScalarWhereWithAggregatesInput | EmailSettingScalarWhereWithAggregatesInput[]
    OR?: EmailSettingScalarWhereWithAggregatesInput[]
    NOT?: EmailSettingScalarWhereWithAggregatesInput | EmailSettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailSetting"> | string
    emailSender?: StringNullableWithAggregatesFilter<"EmailSetting"> | string | null
    emailSenderName?: StringNullableWithAggregatesFilter<"EmailSetting"> | string | null
    emailResponse?: StringNullableWithAggregatesFilter<"EmailSetting"> | string | null
    emailProvider?: EnumEmailProviderNullableWithAggregatesFilter<"EmailSetting"> | $Enums.EmailProvider | null
    emailApiKey?: StringNullableWithAggregatesFilter<"EmailSetting"> | string | null
    maxEmailsPerDay?: IntNullableWithAggregatesFilter<"EmailSetting"> | number | null
    subscriptionTemplateId?: StringNullableWithAggregatesFilter<"EmailSetting"> | string | null
    freeEbookTemplateId?: StringNullableWithAggregatesFilter<"EmailSetting"> | string | null
    webinarTemplateId?: StringNullableWithAggregatesFilter<"EmailSetting"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailSetting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailSetting"> | Date | string
  }

  export type EmailTemplateWhereInput = {
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    id?: StringFilter<"EmailTemplate"> | string
    name?: StringFilter<"EmailTemplate"> | string
    description?: StringNullableFilter<"EmailTemplate"> | string | null
    designData?: JsonNullableFilter<"EmailTemplate">
    bodyHtml?: StringNullableFilter<"EmailTemplate"> | string | null
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    emailSettingSubscription?: EmailSettingListRelationFilter
    emailSettingFreeEbook?: EmailSettingListRelationFilter
    emailSettingWebinar?: EmailSettingListRelationFilter
  }

  export type EmailTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    designData?: SortOrderInput | SortOrder
    bodyHtml?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailSettingSubscription?: EmailSettingOrderByRelationAggregateInput
    emailSettingFreeEbook?: EmailSettingOrderByRelationAggregateInput
    emailSettingWebinar?: EmailSettingOrderByRelationAggregateInput
  }

  export type EmailTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    name?: StringFilter<"EmailTemplate"> | string
    description?: StringNullableFilter<"EmailTemplate"> | string | null
    designData?: JsonNullableFilter<"EmailTemplate">
    bodyHtml?: StringNullableFilter<"EmailTemplate"> | string | null
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    emailSettingSubscription?: EmailSettingListRelationFilter
    emailSettingFreeEbook?: EmailSettingListRelationFilter
    emailSettingWebinar?: EmailSettingListRelationFilter
  }, "id">

  export type EmailTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    designData?: SortOrderInput | SortOrder
    bodyHtml?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailTemplateCountOrderByAggregateInput
    _max?: EmailTemplateMaxOrderByAggregateInput
    _min?: EmailTemplateMinOrderByAggregateInput
  }

  export type EmailTemplateScalarWhereWithAggregatesInput = {
    AND?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    OR?: EmailTemplateScalarWhereWithAggregatesInput[]
    NOT?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailTemplate"> | string
    name?: StringWithAggregatesFilter<"EmailTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"EmailTemplate"> | string | null
    designData?: JsonNullableWithAggregatesFilter<"EmailTemplate">
    bodyHtml?: StringNullableWithAggregatesFilter<"EmailTemplate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
  }

  export type EmailAudienceWhereInput = {
    AND?: EmailAudienceWhereInput | EmailAudienceWhereInput[]
    OR?: EmailAudienceWhereInput[]
    NOT?: EmailAudienceWhereInput | EmailAudienceWhereInput[]
    id?: StringFilter<"EmailAudience"> | string
    name?: StringFilter<"EmailAudience"> | string
    type?: EnumAudienceTypeFilter<"EmailAudience"> | $Enums.AudienceType
    description?: StringNullableFilter<"EmailAudience"> | string | null
    createdAt?: DateTimeFilter<"EmailAudience"> | Date | string
    updatedAt?: DateTimeFilter<"EmailAudience"> | Date | string
    contacts?: EmailContactListRelationFilter
    emailSingleSends?: EmailSingleSendListRelationFilter
  }

  export type EmailAudienceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contacts?: EmailContactOrderByRelationAggregateInput
    emailSingleSends?: EmailSingleSendOrderByRelationAggregateInput
  }

  export type EmailAudienceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailAudienceWhereInput | EmailAudienceWhereInput[]
    OR?: EmailAudienceWhereInput[]
    NOT?: EmailAudienceWhereInput | EmailAudienceWhereInput[]
    name?: StringFilter<"EmailAudience"> | string
    type?: EnumAudienceTypeFilter<"EmailAudience"> | $Enums.AudienceType
    description?: StringNullableFilter<"EmailAudience"> | string | null
    createdAt?: DateTimeFilter<"EmailAudience"> | Date | string
    updatedAt?: DateTimeFilter<"EmailAudience"> | Date | string
    contacts?: EmailContactListRelationFilter
    emailSingleSends?: EmailSingleSendListRelationFilter
  }, "id">

  export type EmailAudienceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailAudienceCountOrderByAggregateInput
    _max?: EmailAudienceMaxOrderByAggregateInput
    _min?: EmailAudienceMinOrderByAggregateInput
  }

  export type EmailAudienceScalarWhereWithAggregatesInput = {
    AND?: EmailAudienceScalarWhereWithAggregatesInput | EmailAudienceScalarWhereWithAggregatesInput[]
    OR?: EmailAudienceScalarWhereWithAggregatesInput[]
    NOT?: EmailAudienceScalarWhereWithAggregatesInput | EmailAudienceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailAudience"> | string
    name?: StringWithAggregatesFilter<"EmailAudience"> | string
    type?: EnumAudienceTypeWithAggregatesFilter<"EmailAudience"> | $Enums.AudienceType
    description?: StringNullableWithAggregatesFilter<"EmailAudience"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailAudience"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailAudience"> | Date | string
  }

  export type EmailContactWhereInput = {
    AND?: EmailContactWhereInput | EmailContactWhereInput[]
    OR?: EmailContactWhereInput[]
    NOT?: EmailContactWhereInput | EmailContactWhereInput[]
    id?: StringFilter<"EmailContact"> | string
    firstName?: StringNullableFilter<"EmailContact"> | string | null
    lastName?: StringNullableFilter<"EmailContact"> | string | null
    email?: StringFilter<"EmailContact"> | string
    emailVerified?: DateTimeNullableFilter<"EmailContact"> | Date | string | null
    isSubscriber?: BoolFilter<"EmailContact"> | boolean
    createdAt?: DateTimeFilter<"EmailContact"> | Date | string
    updatedAt?: DateTimeFilter<"EmailContact"> | Date | string
    audiences?: EmailAudienceListRelationFilter
    interactions?: EmailContactInteractionListRelationFilter
    emailSingleSendLogs?: EmailSingleSendLogListRelationFilter
  }

  export type EmailContactOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    isSubscriber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    audiences?: EmailAudienceOrderByRelationAggregateInput
    interactions?: EmailContactInteractionOrderByRelationAggregateInput
    emailSingleSendLogs?: EmailSingleSendLogOrderByRelationAggregateInput
  }

  export type EmailContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: EmailContactWhereInput | EmailContactWhereInput[]
    OR?: EmailContactWhereInput[]
    NOT?: EmailContactWhereInput | EmailContactWhereInput[]
    firstName?: StringNullableFilter<"EmailContact"> | string | null
    lastName?: StringNullableFilter<"EmailContact"> | string | null
    emailVerified?: DateTimeNullableFilter<"EmailContact"> | Date | string | null
    isSubscriber?: BoolFilter<"EmailContact"> | boolean
    createdAt?: DateTimeFilter<"EmailContact"> | Date | string
    updatedAt?: DateTimeFilter<"EmailContact"> | Date | string
    audiences?: EmailAudienceListRelationFilter
    interactions?: EmailContactInteractionListRelationFilter
    emailSingleSendLogs?: EmailSingleSendLogListRelationFilter
  }, "id" | "email">

  export type EmailContactOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    isSubscriber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailContactCountOrderByAggregateInput
    _max?: EmailContactMaxOrderByAggregateInput
    _min?: EmailContactMinOrderByAggregateInput
  }

  export type EmailContactScalarWhereWithAggregatesInput = {
    AND?: EmailContactScalarWhereWithAggregatesInput | EmailContactScalarWhereWithAggregatesInput[]
    OR?: EmailContactScalarWhereWithAggregatesInput[]
    NOT?: EmailContactScalarWhereWithAggregatesInput | EmailContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailContact"> | string
    firstName?: StringNullableWithAggregatesFilter<"EmailContact"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"EmailContact"> | string | null
    email?: StringWithAggregatesFilter<"EmailContact"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"EmailContact"> | Date | string | null
    isSubscriber?: BoolWithAggregatesFilter<"EmailContact"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EmailContact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailContact"> | Date | string
  }

  export type EmailContactInteractionWhereInput = {
    AND?: EmailContactInteractionWhereInput | EmailContactInteractionWhereInput[]
    OR?: EmailContactInteractionWhereInput[]
    NOT?: EmailContactInteractionWhereInput | EmailContactInteractionWhereInput[]
    id?: StringFilter<"EmailContactInteraction"> | string
    interactionType?: StringFilter<"EmailContactInteraction"> | string
    interactionDate?: DateTimeFilter<"EmailContactInteraction"> | Date | string
    contactId?: StringFilter<"EmailContactInteraction"> | string
    createdAt?: DateTimeFilter<"EmailContactInteraction"> | Date | string
    updatedAt?: DateTimeFilter<"EmailContactInteraction"> | Date | string
    contact?: XOR<EmailContactScalarRelationFilter, EmailContactWhereInput>
  }

  export type EmailContactInteractionOrderByWithRelationInput = {
    id?: SortOrder
    interactionType?: SortOrder
    interactionDate?: SortOrder
    contactId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contact?: EmailContactOrderByWithRelationInput
  }

  export type EmailContactInteractionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contactId_interactionType?: EmailContactInteractionContactIdInteractionTypeCompoundUniqueInput
    AND?: EmailContactInteractionWhereInput | EmailContactInteractionWhereInput[]
    OR?: EmailContactInteractionWhereInput[]
    NOT?: EmailContactInteractionWhereInput | EmailContactInteractionWhereInput[]
    interactionType?: StringFilter<"EmailContactInteraction"> | string
    interactionDate?: DateTimeFilter<"EmailContactInteraction"> | Date | string
    contactId?: StringFilter<"EmailContactInteraction"> | string
    createdAt?: DateTimeFilter<"EmailContactInteraction"> | Date | string
    updatedAt?: DateTimeFilter<"EmailContactInteraction"> | Date | string
    contact?: XOR<EmailContactScalarRelationFilter, EmailContactWhereInput>
  }, "id" | "contactId_interactionType">

  export type EmailContactInteractionOrderByWithAggregationInput = {
    id?: SortOrder
    interactionType?: SortOrder
    interactionDate?: SortOrder
    contactId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailContactInteractionCountOrderByAggregateInput
    _max?: EmailContactInteractionMaxOrderByAggregateInput
    _min?: EmailContactInteractionMinOrderByAggregateInput
  }

  export type EmailContactInteractionScalarWhereWithAggregatesInput = {
    AND?: EmailContactInteractionScalarWhereWithAggregatesInput | EmailContactInteractionScalarWhereWithAggregatesInput[]
    OR?: EmailContactInteractionScalarWhereWithAggregatesInput[]
    NOT?: EmailContactInteractionScalarWhereWithAggregatesInput | EmailContactInteractionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailContactInteraction"> | string
    interactionType?: StringWithAggregatesFilter<"EmailContactInteraction"> | string
    interactionDate?: DateTimeWithAggregatesFilter<"EmailContactInteraction"> | Date | string
    contactId?: StringWithAggregatesFilter<"EmailContactInteraction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailContactInteraction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailContactInteraction"> | Date | string
  }

  export type EmailSingleSendWhereInput = {
    AND?: EmailSingleSendWhereInput | EmailSingleSendWhereInput[]
    OR?: EmailSingleSendWhereInput[]
    NOT?: EmailSingleSendWhereInput | EmailSingleSendWhereInput[]
    id?: StringFilter<"EmailSingleSend"> | string
    name?: StringFilter<"EmailSingleSend"> | string
    subject?: StringNullableFilter<"EmailSingleSend"> | string | null
    designData?: JsonNullableFilter<"EmailSingleSend">
    bodyHtml?: StringNullableFilter<"EmailSingleSend"> | string | null
    createdAt?: DateTimeFilter<"EmailSingleSend"> | Date | string
    updatedAt?: DateTimeFilter<"EmailSingleSend"> | Date | string
    audiences?: EmailAudienceListRelationFilter
    emailSingleSendLogs?: EmailSingleSendLogListRelationFilter
  }

  export type EmailSingleSendOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrderInput | SortOrder
    designData?: SortOrderInput | SortOrder
    bodyHtml?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    audiences?: EmailAudienceOrderByRelationAggregateInput
    emailSingleSendLogs?: EmailSingleSendLogOrderByRelationAggregateInput
  }

  export type EmailSingleSendWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailSingleSendWhereInput | EmailSingleSendWhereInput[]
    OR?: EmailSingleSendWhereInput[]
    NOT?: EmailSingleSendWhereInput | EmailSingleSendWhereInput[]
    name?: StringFilter<"EmailSingleSend"> | string
    subject?: StringNullableFilter<"EmailSingleSend"> | string | null
    designData?: JsonNullableFilter<"EmailSingleSend">
    bodyHtml?: StringNullableFilter<"EmailSingleSend"> | string | null
    createdAt?: DateTimeFilter<"EmailSingleSend"> | Date | string
    updatedAt?: DateTimeFilter<"EmailSingleSend"> | Date | string
    audiences?: EmailAudienceListRelationFilter
    emailSingleSendLogs?: EmailSingleSendLogListRelationFilter
  }, "id">

  export type EmailSingleSendOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrderInput | SortOrder
    designData?: SortOrderInput | SortOrder
    bodyHtml?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailSingleSendCountOrderByAggregateInput
    _max?: EmailSingleSendMaxOrderByAggregateInput
    _min?: EmailSingleSendMinOrderByAggregateInput
  }

  export type EmailSingleSendScalarWhereWithAggregatesInput = {
    AND?: EmailSingleSendScalarWhereWithAggregatesInput | EmailSingleSendScalarWhereWithAggregatesInput[]
    OR?: EmailSingleSendScalarWhereWithAggregatesInput[]
    NOT?: EmailSingleSendScalarWhereWithAggregatesInput | EmailSingleSendScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailSingleSend"> | string
    name?: StringWithAggregatesFilter<"EmailSingleSend"> | string
    subject?: StringNullableWithAggregatesFilter<"EmailSingleSend"> | string | null
    designData?: JsonNullableWithAggregatesFilter<"EmailSingleSend">
    bodyHtml?: StringNullableWithAggregatesFilter<"EmailSingleSend"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailSingleSend"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailSingleSend"> | Date | string
  }

  export type EmailSubscriptionTokenWhereInput = {
    AND?: EmailSubscriptionTokenWhereInput | EmailSubscriptionTokenWhereInput[]
    OR?: EmailSubscriptionTokenWhereInput[]
    NOT?: EmailSubscriptionTokenWhereInput | EmailSubscriptionTokenWhereInput[]
    id?: StringFilter<"EmailSubscriptionToken"> | string
    email?: StringFilter<"EmailSubscriptionToken"> | string
    token?: StringFilter<"EmailSubscriptionToken"> | string
    expires?: DateTimeFilter<"EmailSubscriptionToken"> | Date | string
    createdAt?: DateTimeFilter<"EmailSubscriptionToken"> | Date | string
    updatedAt?: DateTimeFilter<"EmailSubscriptionToken"> | Date | string
  }

  export type EmailSubscriptionTokenOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailSubscriptionTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    email_token?: EmailSubscriptionTokenEmailTokenCompoundUniqueInput
    AND?: EmailSubscriptionTokenWhereInput | EmailSubscriptionTokenWhereInput[]
    OR?: EmailSubscriptionTokenWhereInput[]
    NOT?: EmailSubscriptionTokenWhereInput | EmailSubscriptionTokenWhereInput[]
    email?: StringFilter<"EmailSubscriptionToken"> | string
    expires?: DateTimeFilter<"EmailSubscriptionToken"> | Date | string
    createdAt?: DateTimeFilter<"EmailSubscriptionToken"> | Date | string
    updatedAt?: DateTimeFilter<"EmailSubscriptionToken"> | Date | string
  }, "id" | "token" | "email_token">

  export type EmailSubscriptionTokenOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailSubscriptionTokenCountOrderByAggregateInput
    _max?: EmailSubscriptionTokenMaxOrderByAggregateInput
    _min?: EmailSubscriptionTokenMinOrderByAggregateInput
  }

  export type EmailSubscriptionTokenScalarWhereWithAggregatesInput = {
    AND?: EmailSubscriptionTokenScalarWhereWithAggregatesInput | EmailSubscriptionTokenScalarWhereWithAggregatesInput[]
    OR?: EmailSubscriptionTokenScalarWhereWithAggregatesInput[]
    NOT?: EmailSubscriptionTokenScalarWhereWithAggregatesInput | EmailSubscriptionTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailSubscriptionToken"> | string
    email?: StringWithAggregatesFilter<"EmailSubscriptionToken"> | string
    token?: StringWithAggregatesFilter<"EmailSubscriptionToken"> | string
    expires?: DateTimeWithAggregatesFilter<"EmailSubscriptionToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailSubscriptionToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailSubscriptionToken"> | Date | string
  }

  export type EmailSendLogWhereInput = {
    AND?: EmailSendLogWhereInput | EmailSendLogWhereInput[]
    OR?: EmailSendLogWhereInput[]
    NOT?: EmailSendLogWhereInput | EmailSendLogWhereInput[]
    id?: StringFilter<"EmailSendLog"> | string
    to?: StringFilter<"EmailSendLog"> | string
    from?: StringFilter<"EmailSendLog"> | string
    subject?: StringNullableFilter<"EmailSendLog"> | string | null
    type?: StringFilter<"EmailSendLog"> | string
    createdAt?: DateTimeFilter<"EmailSendLog"> | Date | string
    updatedAt?: DateTimeFilter<"EmailSendLog"> | Date | string
  }

  export type EmailSendLogOrderByWithRelationInput = {
    id?: SortOrder
    to?: SortOrder
    from?: SortOrder
    subject?: SortOrderInput | SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailSendLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailSendLogWhereInput | EmailSendLogWhereInput[]
    OR?: EmailSendLogWhereInput[]
    NOT?: EmailSendLogWhereInput | EmailSendLogWhereInput[]
    to?: StringFilter<"EmailSendLog"> | string
    from?: StringFilter<"EmailSendLog"> | string
    subject?: StringNullableFilter<"EmailSendLog"> | string | null
    type?: StringFilter<"EmailSendLog"> | string
    createdAt?: DateTimeFilter<"EmailSendLog"> | Date | string
    updatedAt?: DateTimeFilter<"EmailSendLog"> | Date | string
  }, "id">

  export type EmailSendLogOrderByWithAggregationInput = {
    id?: SortOrder
    to?: SortOrder
    from?: SortOrder
    subject?: SortOrderInput | SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailSendLogCountOrderByAggregateInput
    _max?: EmailSendLogMaxOrderByAggregateInput
    _min?: EmailSendLogMinOrderByAggregateInput
  }

  export type EmailSendLogScalarWhereWithAggregatesInput = {
    AND?: EmailSendLogScalarWhereWithAggregatesInput | EmailSendLogScalarWhereWithAggregatesInput[]
    OR?: EmailSendLogScalarWhereWithAggregatesInput[]
    NOT?: EmailSendLogScalarWhereWithAggregatesInput | EmailSendLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailSendLog"> | string
    to?: StringWithAggregatesFilter<"EmailSendLog"> | string
    from?: StringWithAggregatesFilter<"EmailSendLog"> | string
    subject?: StringNullableWithAggregatesFilter<"EmailSendLog"> | string | null
    type?: StringWithAggregatesFilter<"EmailSendLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailSendLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailSendLog"> | Date | string
  }

  export type EmailSingleSendLogWhereInput = {
    AND?: EmailSingleSendLogWhereInput | EmailSingleSendLogWhereInput[]
    OR?: EmailSingleSendLogWhereInput[]
    NOT?: EmailSingleSendLogWhereInput | EmailSingleSendLogWhereInput[]
    id?: StringFilter<"EmailSingleSendLog"> | string
    contactId?: StringFilter<"EmailSingleSendLog"> | string
    singleSendId?: StringFilter<"EmailSingleSendLog"> | string
    createdAt?: DateTimeFilter<"EmailSingleSendLog"> | Date | string
    updatedAt?: DateTimeFilter<"EmailSingleSendLog"> | Date | string
    contact?: XOR<EmailContactScalarRelationFilter, EmailContactWhereInput>
    singleSend?: XOR<EmailSingleSendScalarRelationFilter, EmailSingleSendWhereInput>
  }

  export type EmailSingleSendLogOrderByWithRelationInput = {
    id?: SortOrder
    contactId?: SortOrder
    singleSendId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contact?: EmailContactOrderByWithRelationInput
    singleSend?: EmailSingleSendOrderByWithRelationInput
  }

  export type EmailSingleSendLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contactId_singleSendId?: EmailSingleSendLogContactIdSingleSendIdCompoundUniqueInput
    AND?: EmailSingleSendLogWhereInput | EmailSingleSendLogWhereInput[]
    OR?: EmailSingleSendLogWhereInput[]
    NOT?: EmailSingleSendLogWhereInput | EmailSingleSendLogWhereInput[]
    contactId?: StringFilter<"EmailSingleSendLog"> | string
    singleSendId?: StringFilter<"EmailSingleSendLog"> | string
    createdAt?: DateTimeFilter<"EmailSingleSendLog"> | Date | string
    updatedAt?: DateTimeFilter<"EmailSingleSendLog"> | Date | string
    contact?: XOR<EmailContactScalarRelationFilter, EmailContactWhereInput>
    singleSend?: XOR<EmailSingleSendScalarRelationFilter, EmailSingleSendWhereInput>
  }, "id" | "contactId_singleSendId">

  export type EmailSingleSendLogOrderByWithAggregationInput = {
    id?: SortOrder
    contactId?: SortOrder
    singleSendId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailSingleSendLogCountOrderByAggregateInput
    _max?: EmailSingleSendLogMaxOrderByAggregateInput
    _min?: EmailSingleSendLogMinOrderByAggregateInput
  }

  export type EmailSingleSendLogScalarWhereWithAggregatesInput = {
    AND?: EmailSingleSendLogScalarWhereWithAggregatesInput | EmailSingleSendLogScalarWhereWithAggregatesInput[]
    OR?: EmailSingleSendLogScalarWhereWithAggregatesInput[]
    NOT?: EmailSingleSendLogScalarWhereWithAggregatesInput | EmailSingleSendLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailSingleSendLog"> | string
    contactId?: StringWithAggregatesFilter<"EmailSingleSendLog"> | string
    singleSendId?: StringWithAggregatesFilter<"EmailSingleSendLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailSingleSendLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailSingleSendLog"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    title?: StringFilter<"Product"> | string
    slug?: StringFilter<"Product"> | string
    description?: JsonFilter<"Product">
    tiptapDescription?: JsonNullableFilter<"Product">
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    version?: IntFilter<"Product"> | number
    status?: EnumContentStatusFilter<"Product"> | $Enums.ContentStatus
    isLatest?: BoolFilter<"Product"> | boolean
    imageCoverId?: StringNullableFilter<"Product"> | string | null
    categoryId?: StringNullableFilter<"Product"> | string | null
    acquisitionMode?: EnumProductAcquisitionModeFilter<"Product"> | $Enums.ProductAcquisitionMode
    price?: FloatNullableFilter<"Product"> | number | null
    discountedPrice?: FloatNullableFilter<"Product"> | number | null
    isFree?: BoolFilter<"Product"> | boolean
    metadata?: JsonNullableFilter<"Product">
    formId?: StringNullableFilter<"Product"> | string | null
    rootId?: StringNullableFilter<"Product"> | string | null
    seoId?: StringNullableFilter<"Product"> | string | null
    userId?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    imageCover?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    category?: XOR<ProductCategoryNullableScalarRelationFilter, ProductCategoryWhereInput> | null
    extras?: ProductExtraListRelationFilter
    form?: XOR<FormNullableScalarRelationFilter, FormWhereInput> | null
    root?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    rootChildren?: ProductListRelationFilter
    gallery?: ProductGalleryListRelationFilter
    faqs?: ProductFAQListRelationFilter
    purchases?: PurchaseListRelationFilter
    seo?: XOR<SeoNullableScalarRelationFilter, SeoWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    tiptapDescription?: SortOrderInput | SortOrder
    type?: SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    imageCoverId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    acquisitionMode?: SortOrder
    price?: SortOrderInput | SortOrder
    discountedPrice?: SortOrderInput | SortOrder
    isFree?: SortOrder
    metadata?: SortOrderInput | SortOrder
    formId?: SortOrderInput | SortOrder
    rootId?: SortOrderInput | SortOrder
    seoId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageCover?: MediaOrderByWithRelationInput
    category?: ProductCategoryOrderByWithRelationInput
    extras?: ProductExtraOrderByRelationAggregateInput
    form?: FormOrderByWithRelationInput
    root?: ProductOrderByWithRelationInput
    rootChildren?: ProductOrderByRelationAggregateInput
    gallery?: ProductGalleryOrderByRelationAggregateInput
    faqs?: ProductFAQOrderByRelationAggregateInput
    purchases?: PurchaseOrderByRelationAggregateInput
    seo?: SeoOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    title?: StringFilter<"Product"> | string
    slug?: StringFilter<"Product"> | string
    description?: JsonFilter<"Product">
    tiptapDescription?: JsonNullableFilter<"Product">
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    version?: IntFilter<"Product"> | number
    status?: EnumContentStatusFilter<"Product"> | $Enums.ContentStatus
    isLatest?: BoolFilter<"Product"> | boolean
    imageCoverId?: StringNullableFilter<"Product"> | string | null
    categoryId?: StringNullableFilter<"Product"> | string | null
    acquisitionMode?: EnumProductAcquisitionModeFilter<"Product"> | $Enums.ProductAcquisitionMode
    price?: FloatNullableFilter<"Product"> | number | null
    discountedPrice?: FloatNullableFilter<"Product"> | number | null
    isFree?: BoolFilter<"Product"> | boolean
    metadata?: JsonNullableFilter<"Product">
    formId?: StringNullableFilter<"Product"> | string | null
    rootId?: StringNullableFilter<"Product"> | string | null
    seoId?: StringNullableFilter<"Product"> | string | null
    userId?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    imageCover?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    category?: XOR<ProductCategoryNullableScalarRelationFilter, ProductCategoryWhereInput> | null
    extras?: ProductExtraListRelationFilter
    form?: XOR<FormNullableScalarRelationFilter, FormWhereInput> | null
    root?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    rootChildren?: ProductListRelationFilter
    gallery?: ProductGalleryListRelationFilter
    faqs?: ProductFAQListRelationFilter
    purchases?: PurchaseListRelationFilter
    seo?: XOR<SeoNullableScalarRelationFilter, SeoWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    tiptapDescription?: SortOrderInput | SortOrder
    type?: SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    imageCoverId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    acquisitionMode?: SortOrder
    price?: SortOrderInput | SortOrder
    discountedPrice?: SortOrderInput | SortOrder
    isFree?: SortOrder
    metadata?: SortOrderInput | SortOrder
    formId?: SortOrderInput | SortOrder
    rootId?: SortOrderInput | SortOrder
    seoId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    title?: StringWithAggregatesFilter<"Product"> | string
    slug?: StringWithAggregatesFilter<"Product"> | string
    description?: JsonWithAggregatesFilter<"Product">
    tiptapDescription?: JsonNullableWithAggregatesFilter<"Product">
    type?: EnumProductTypeWithAggregatesFilter<"Product"> | $Enums.ProductType
    version?: IntWithAggregatesFilter<"Product"> | number
    status?: EnumContentStatusWithAggregatesFilter<"Product"> | $Enums.ContentStatus
    isLatest?: BoolWithAggregatesFilter<"Product"> | boolean
    imageCoverId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    categoryId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    acquisitionMode?: EnumProductAcquisitionModeWithAggregatesFilter<"Product"> | $Enums.ProductAcquisitionMode
    price?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    discountedPrice?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    isFree?: BoolWithAggregatesFilter<"Product"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Product">
    formId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    rootId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    seoId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type ProductCategoryWhereInput = {
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    id?: StringFilter<"ProductCategory"> | string
    title?: StringFilter<"ProductCategory"> | string
    slug?: StringFilter<"ProductCategory"> | string
    description?: StringNullableFilter<"ProductCategory"> | string | null
    version?: IntFilter<"ProductCategory"> | number
    status?: EnumContentStatusFilter<"ProductCategory"> | $Enums.ContentStatus
    isLatest?: BoolFilter<"ProductCategory"> | boolean
    rootId?: StringNullableFilter<"ProductCategory"> | string | null
    seoId?: StringNullableFilter<"ProductCategory"> | string | null
    firstPublishedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    publishedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    root?: XOR<ProductCategoryNullableScalarRelationFilter, ProductCategoryWhereInput> | null
    rootChildren?: ProductCategoryListRelationFilter
    products?: ProductListRelationFilter
    seo?: XOR<SeoNullableScalarRelationFilter, SeoWhereInput> | null
  }

  export type ProductCategoryOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    rootId?: SortOrderInput | SortOrder
    seoId?: SortOrderInput | SortOrder
    firstPublishedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    root?: ProductCategoryOrderByWithRelationInput
    rootChildren?: ProductCategoryOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    seo?: SeoOrderByWithRelationInput
  }

  export type ProductCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    title?: StringFilter<"ProductCategory"> | string
    slug?: StringFilter<"ProductCategory"> | string
    description?: StringNullableFilter<"ProductCategory"> | string | null
    version?: IntFilter<"ProductCategory"> | number
    status?: EnumContentStatusFilter<"ProductCategory"> | $Enums.ContentStatus
    isLatest?: BoolFilter<"ProductCategory"> | boolean
    rootId?: StringNullableFilter<"ProductCategory"> | string | null
    seoId?: StringNullableFilter<"ProductCategory"> | string | null
    firstPublishedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    publishedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    root?: XOR<ProductCategoryNullableScalarRelationFilter, ProductCategoryWhereInput> | null
    rootChildren?: ProductCategoryListRelationFilter
    products?: ProductListRelationFilter
    seo?: XOR<SeoNullableScalarRelationFilter, SeoWhereInput> | null
  }, "id">

  export type ProductCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    rootId?: SortOrderInput | SortOrder
    seoId?: SortOrderInput | SortOrder
    firstPublishedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCategoryCountOrderByAggregateInput
    _avg?: ProductCategoryAvgOrderByAggregateInput
    _max?: ProductCategoryMaxOrderByAggregateInput
    _min?: ProductCategoryMinOrderByAggregateInput
    _sum?: ProductCategorySumOrderByAggregateInput
  }

  export type ProductCategoryScalarWhereWithAggregatesInput = {
    AND?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    OR?: ProductCategoryScalarWhereWithAggregatesInput[]
    NOT?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductCategory"> | string
    title?: StringWithAggregatesFilter<"ProductCategory"> | string
    slug?: StringWithAggregatesFilter<"ProductCategory"> | string
    description?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    version?: IntWithAggregatesFilter<"ProductCategory"> | number
    status?: EnumContentStatusWithAggregatesFilter<"ProductCategory"> | $Enums.ContentStatus
    isLatest?: BoolWithAggregatesFilter<"ProductCategory"> | boolean
    rootId?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    seoId?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    firstPublishedAt?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
    publishedAt?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
  }

  export type ProductGalleryWhereInput = {
    AND?: ProductGalleryWhereInput | ProductGalleryWhereInput[]
    OR?: ProductGalleryWhereInput[]
    NOT?: ProductGalleryWhereInput | ProductGalleryWhereInput[]
    id?: StringFilter<"ProductGallery"> | string
    sort?: IntFilter<"ProductGallery"> | number
    productId?: StringFilter<"ProductGallery"> | string
    mediaId?: StringFilter<"ProductGallery"> | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    media?: XOR<MediaScalarRelationFilter, MediaWhereInput>
  }

  export type ProductGalleryOrderByWithRelationInput = {
    id?: SortOrder
    sort?: SortOrder
    productId?: SortOrder
    mediaId?: SortOrder
    product?: ProductOrderByWithRelationInput
    media?: MediaOrderByWithRelationInput
  }

  export type ProductGalleryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_mediaId?: ProductGalleryProductIdMediaIdCompoundUniqueInput
    AND?: ProductGalleryWhereInput | ProductGalleryWhereInput[]
    OR?: ProductGalleryWhereInput[]
    NOT?: ProductGalleryWhereInput | ProductGalleryWhereInput[]
    sort?: IntFilter<"ProductGallery"> | number
    productId?: StringFilter<"ProductGallery"> | string
    mediaId?: StringFilter<"ProductGallery"> | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    media?: XOR<MediaScalarRelationFilter, MediaWhereInput>
  }, "id" | "productId_mediaId">

  export type ProductGalleryOrderByWithAggregationInput = {
    id?: SortOrder
    sort?: SortOrder
    productId?: SortOrder
    mediaId?: SortOrder
    _count?: ProductGalleryCountOrderByAggregateInput
    _avg?: ProductGalleryAvgOrderByAggregateInput
    _max?: ProductGalleryMaxOrderByAggregateInput
    _min?: ProductGalleryMinOrderByAggregateInput
    _sum?: ProductGallerySumOrderByAggregateInput
  }

  export type ProductGalleryScalarWhereWithAggregatesInput = {
    AND?: ProductGalleryScalarWhereWithAggregatesInput | ProductGalleryScalarWhereWithAggregatesInput[]
    OR?: ProductGalleryScalarWhereWithAggregatesInput[]
    NOT?: ProductGalleryScalarWhereWithAggregatesInput | ProductGalleryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductGallery"> | string
    sort?: IntWithAggregatesFilter<"ProductGallery"> | number
    productId?: StringWithAggregatesFilter<"ProductGallery"> | string
    mediaId?: StringWithAggregatesFilter<"ProductGallery"> | string
  }

  export type ProductExtraWhereInput = {
    AND?: ProductExtraWhereInput | ProductExtraWhereInput[]
    OR?: ProductExtraWhereInput[]
    NOT?: ProductExtraWhereInput | ProductExtraWhereInput[]
    id?: StringFilter<"ProductExtra"> | string
    name?: StringFilter<"ProductExtra"> | string
    description?: StringNullableFilter<"ProductExtra"> | string | null
    price?: FloatFilter<"ProductExtra"> | number
    productId?: StringFilter<"ProductExtra"> | string
    createdAt?: DateTimeFilter<"ProductExtra"> | Date | string
    updatedAt?: DateTimeFilter<"ProductExtra"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductExtraOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ProductExtraWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductExtraWhereInput | ProductExtraWhereInput[]
    OR?: ProductExtraWhereInput[]
    NOT?: ProductExtraWhereInput | ProductExtraWhereInput[]
    name?: StringFilter<"ProductExtra"> | string
    description?: StringNullableFilter<"ProductExtra"> | string | null
    price?: FloatFilter<"ProductExtra"> | number
    productId?: StringFilter<"ProductExtra"> | string
    createdAt?: DateTimeFilter<"ProductExtra"> | Date | string
    updatedAt?: DateTimeFilter<"ProductExtra"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type ProductExtraOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductExtraCountOrderByAggregateInput
    _avg?: ProductExtraAvgOrderByAggregateInput
    _max?: ProductExtraMaxOrderByAggregateInput
    _min?: ProductExtraMinOrderByAggregateInput
    _sum?: ProductExtraSumOrderByAggregateInput
  }

  export type ProductExtraScalarWhereWithAggregatesInput = {
    AND?: ProductExtraScalarWhereWithAggregatesInput | ProductExtraScalarWhereWithAggregatesInput[]
    OR?: ProductExtraScalarWhereWithAggregatesInput[]
    NOT?: ProductExtraScalarWhereWithAggregatesInput | ProductExtraScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductExtra"> | string
    name?: StringWithAggregatesFilter<"ProductExtra"> | string
    description?: StringNullableWithAggregatesFilter<"ProductExtra"> | string | null
    price?: FloatWithAggregatesFilter<"ProductExtra"> | number
    productId?: StringWithAggregatesFilter<"ProductExtra"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductExtra"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductExtra"> | Date | string
  }

  export type ProductFAQWhereInput = {
    AND?: ProductFAQWhereInput | ProductFAQWhereInput[]
    OR?: ProductFAQWhereInput[]
    NOT?: ProductFAQWhereInput | ProductFAQWhereInput[]
    id?: StringFilter<"ProductFAQ"> | string
    question?: StringFilter<"ProductFAQ"> | string
    answer?: StringFilter<"ProductFAQ"> | string
    sort?: IntFilter<"ProductFAQ"> | number
    productId?: StringFilter<"ProductFAQ"> | string
    createdAt?: DateTimeFilter<"ProductFAQ"> | Date | string
    updatedAt?: DateTimeFilter<"ProductFAQ"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductFAQOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    sort?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ProductFAQWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductFAQWhereInput | ProductFAQWhereInput[]
    OR?: ProductFAQWhereInput[]
    NOT?: ProductFAQWhereInput | ProductFAQWhereInput[]
    question?: StringFilter<"ProductFAQ"> | string
    answer?: StringFilter<"ProductFAQ"> | string
    sort?: IntFilter<"ProductFAQ"> | number
    productId?: StringFilter<"ProductFAQ"> | string
    createdAt?: DateTimeFilter<"ProductFAQ"> | Date | string
    updatedAt?: DateTimeFilter<"ProductFAQ"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type ProductFAQOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    sort?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductFAQCountOrderByAggregateInput
    _avg?: ProductFAQAvgOrderByAggregateInput
    _max?: ProductFAQMaxOrderByAggregateInput
    _min?: ProductFAQMinOrderByAggregateInput
    _sum?: ProductFAQSumOrderByAggregateInput
  }

  export type ProductFAQScalarWhereWithAggregatesInput = {
    AND?: ProductFAQScalarWhereWithAggregatesInput | ProductFAQScalarWhereWithAggregatesInput[]
    OR?: ProductFAQScalarWhereWithAggregatesInput[]
    NOT?: ProductFAQScalarWhereWithAggregatesInput | ProductFAQScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductFAQ"> | string
    question?: StringWithAggregatesFilter<"ProductFAQ"> | string
    answer?: StringWithAggregatesFilter<"ProductFAQ"> | string
    sort?: IntWithAggregatesFilter<"ProductFAQ"> | number
    productId?: StringWithAggregatesFilter<"ProductFAQ"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductFAQ"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductFAQ"> | Date | string
  }

  export type AdCampaignWhereInput = {
    AND?: AdCampaignWhereInput | AdCampaignWhereInput[]
    OR?: AdCampaignWhereInput[]
    NOT?: AdCampaignWhereInput | AdCampaignWhereInput[]
    id?: StringFilter<"AdCampaign"> | string
    name?: StringFilter<"AdCampaign"> | string
    description?: StringNullableFilter<"AdCampaign"> | string | null
    startDate?: DateTimeNullableFilter<"AdCampaign"> | Date | string | null
    endDate?: DateTimeNullableFilter<"AdCampaign"> | Date | string | null
    isActive?: BoolFilter<"AdCampaign"> | boolean
    createdAt?: DateTimeFilter<"AdCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"AdCampaign"> | Date | string
    blocks?: AdBlockListRelationFilter
  }

  export type AdCampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    blocks?: AdBlockOrderByRelationAggregateInput
  }

  export type AdCampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdCampaignWhereInput | AdCampaignWhereInput[]
    OR?: AdCampaignWhereInput[]
    NOT?: AdCampaignWhereInput | AdCampaignWhereInput[]
    name?: StringFilter<"AdCampaign"> | string
    description?: StringNullableFilter<"AdCampaign"> | string | null
    startDate?: DateTimeNullableFilter<"AdCampaign"> | Date | string | null
    endDate?: DateTimeNullableFilter<"AdCampaign"> | Date | string | null
    isActive?: BoolFilter<"AdCampaign"> | boolean
    createdAt?: DateTimeFilter<"AdCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"AdCampaign"> | Date | string
    blocks?: AdBlockListRelationFilter
  }, "id">

  export type AdCampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdCampaignCountOrderByAggregateInput
    _max?: AdCampaignMaxOrderByAggregateInput
    _min?: AdCampaignMinOrderByAggregateInput
  }

  export type AdCampaignScalarWhereWithAggregatesInput = {
    AND?: AdCampaignScalarWhereWithAggregatesInput | AdCampaignScalarWhereWithAggregatesInput[]
    OR?: AdCampaignScalarWhereWithAggregatesInput[]
    NOT?: AdCampaignScalarWhereWithAggregatesInput | AdCampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdCampaign"> | string
    name?: StringWithAggregatesFilter<"AdCampaign"> | string
    description?: StringNullableWithAggregatesFilter<"AdCampaign"> | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"AdCampaign"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"AdCampaign"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"AdCampaign"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AdCampaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdCampaign"> | Date | string
  }

  export type AdBlockWhereInput = {
    AND?: AdBlockWhereInput | AdBlockWhereInput[]
    OR?: AdBlockWhereInput[]
    NOT?: AdBlockWhereInput | AdBlockWhereInput[]
    id?: StringFilter<"AdBlock"> | string
    label?: StringFilter<"AdBlock"> | string
    layoutType?: EnumAdLayoutTypeFilter<"AdBlock"> | $Enums.AdLayoutType
    isActive?: BoolFilter<"AdBlock"> | boolean
    campaignId?: StringFilter<"AdBlock"> | string
    placement?: EnumAdPositionPlacementFilter<"AdBlock"> | $Enums.AdPositionPlacement
    reference?: EnumAdPositionReferenceFilter<"AdBlock"> | $Enums.AdPositionReference
    referenceCount?: IntFilter<"AdBlock"> | number
    minWords?: IntFilter<"AdBlock"> | number
    excludedPostIds?: StringNullableListFilter<"AdBlock">
    excludedCategoryIds?: StringNullableListFilter<"AdBlock">
    excludedTagIds?: StringNullableListFilter<"AdBlock">
    createdAt?: DateTimeFilter<"AdBlock"> | Date | string
    updatedAt?: DateTimeFilter<"AdBlock"> | Date | string
    campaign?: XOR<AdCampaignScalarRelationFilter, AdCampaignWhereInput>
    items?: AdItemListRelationFilter
  }

  export type AdBlockOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    layoutType?: SortOrder
    isActive?: SortOrder
    campaignId?: SortOrder
    placement?: SortOrder
    reference?: SortOrder
    referenceCount?: SortOrder
    minWords?: SortOrder
    excludedPostIds?: SortOrder
    excludedCategoryIds?: SortOrder
    excludedTagIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: AdCampaignOrderByWithRelationInput
    items?: AdItemOrderByRelationAggregateInput
  }

  export type AdBlockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdBlockWhereInput | AdBlockWhereInput[]
    OR?: AdBlockWhereInput[]
    NOT?: AdBlockWhereInput | AdBlockWhereInput[]
    label?: StringFilter<"AdBlock"> | string
    layoutType?: EnumAdLayoutTypeFilter<"AdBlock"> | $Enums.AdLayoutType
    isActive?: BoolFilter<"AdBlock"> | boolean
    campaignId?: StringFilter<"AdBlock"> | string
    placement?: EnumAdPositionPlacementFilter<"AdBlock"> | $Enums.AdPositionPlacement
    reference?: EnumAdPositionReferenceFilter<"AdBlock"> | $Enums.AdPositionReference
    referenceCount?: IntFilter<"AdBlock"> | number
    minWords?: IntFilter<"AdBlock"> | number
    excludedPostIds?: StringNullableListFilter<"AdBlock">
    excludedCategoryIds?: StringNullableListFilter<"AdBlock">
    excludedTagIds?: StringNullableListFilter<"AdBlock">
    createdAt?: DateTimeFilter<"AdBlock"> | Date | string
    updatedAt?: DateTimeFilter<"AdBlock"> | Date | string
    campaign?: XOR<AdCampaignScalarRelationFilter, AdCampaignWhereInput>
    items?: AdItemListRelationFilter
  }, "id">

  export type AdBlockOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    layoutType?: SortOrder
    isActive?: SortOrder
    campaignId?: SortOrder
    placement?: SortOrder
    reference?: SortOrder
    referenceCount?: SortOrder
    minWords?: SortOrder
    excludedPostIds?: SortOrder
    excludedCategoryIds?: SortOrder
    excludedTagIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdBlockCountOrderByAggregateInput
    _avg?: AdBlockAvgOrderByAggregateInput
    _max?: AdBlockMaxOrderByAggregateInput
    _min?: AdBlockMinOrderByAggregateInput
    _sum?: AdBlockSumOrderByAggregateInput
  }

  export type AdBlockScalarWhereWithAggregatesInput = {
    AND?: AdBlockScalarWhereWithAggregatesInput | AdBlockScalarWhereWithAggregatesInput[]
    OR?: AdBlockScalarWhereWithAggregatesInput[]
    NOT?: AdBlockScalarWhereWithAggregatesInput | AdBlockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdBlock"> | string
    label?: StringWithAggregatesFilter<"AdBlock"> | string
    layoutType?: EnumAdLayoutTypeWithAggregatesFilter<"AdBlock"> | $Enums.AdLayoutType
    isActive?: BoolWithAggregatesFilter<"AdBlock"> | boolean
    campaignId?: StringWithAggregatesFilter<"AdBlock"> | string
    placement?: EnumAdPositionPlacementWithAggregatesFilter<"AdBlock"> | $Enums.AdPositionPlacement
    reference?: EnumAdPositionReferenceWithAggregatesFilter<"AdBlock"> | $Enums.AdPositionReference
    referenceCount?: IntWithAggregatesFilter<"AdBlock"> | number
    minWords?: IntWithAggregatesFilter<"AdBlock"> | number
    excludedPostIds?: StringNullableListFilter<"AdBlock">
    excludedCategoryIds?: StringNullableListFilter<"AdBlock">
    excludedTagIds?: StringNullableListFilter<"AdBlock">
    createdAt?: DateTimeWithAggregatesFilter<"AdBlock"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdBlock"> | Date | string
  }

  export type AdItemWhereInput = {
    AND?: AdItemWhereInput | AdItemWhereInput[]
    OR?: AdItemWhereInput[]
    NOT?: AdItemWhereInput | AdItemWhereInput[]
    id?: StringFilter<"AdItem"> | string
    sourceType?: EnumAdItemSourceTypeFilter<"AdItem"> | $Enums.AdItemSourceType
    adBlockId?: StringFilter<"AdItem"> | string
    title?: StringNullableFilter<"AdItem"> | string | null
    description?: StringNullableFilter<"AdItem"> | string | null
    imageUrl?: StringNullableFilter<"AdItem"> | string | null
    url?: StringNullableFilter<"AdItem"> | string | null
    postRootId?: StringNullableFilter<"AdItem"> | string | null
    productRootId?: StringNullableFilter<"AdItem"> | string | null
    sort?: IntNullableFilter<"AdItem"> | number | null
    isActive?: BoolFilter<"AdItem"> | boolean
    createdAt?: DateTimeFilter<"AdItem"> | Date | string
    updatedAt?: DateTimeFilter<"AdItem"> | Date | string
    adBlock?: XOR<AdBlockScalarRelationFilter, AdBlockWhereInput>
  }

  export type AdItemOrderByWithRelationInput = {
    id?: SortOrder
    sourceType?: SortOrder
    adBlockId?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    postRootId?: SortOrderInput | SortOrder
    productRootId?: SortOrderInput | SortOrder
    sort?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adBlock?: AdBlockOrderByWithRelationInput
  }

  export type AdItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdItemWhereInput | AdItemWhereInput[]
    OR?: AdItemWhereInput[]
    NOT?: AdItemWhereInput | AdItemWhereInput[]
    sourceType?: EnumAdItemSourceTypeFilter<"AdItem"> | $Enums.AdItemSourceType
    adBlockId?: StringFilter<"AdItem"> | string
    title?: StringNullableFilter<"AdItem"> | string | null
    description?: StringNullableFilter<"AdItem"> | string | null
    imageUrl?: StringNullableFilter<"AdItem"> | string | null
    url?: StringNullableFilter<"AdItem"> | string | null
    postRootId?: StringNullableFilter<"AdItem"> | string | null
    productRootId?: StringNullableFilter<"AdItem"> | string | null
    sort?: IntNullableFilter<"AdItem"> | number | null
    isActive?: BoolFilter<"AdItem"> | boolean
    createdAt?: DateTimeFilter<"AdItem"> | Date | string
    updatedAt?: DateTimeFilter<"AdItem"> | Date | string
    adBlock?: XOR<AdBlockScalarRelationFilter, AdBlockWhereInput>
  }, "id">

  export type AdItemOrderByWithAggregationInput = {
    id?: SortOrder
    sourceType?: SortOrder
    adBlockId?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    postRootId?: SortOrderInput | SortOrder
    productRootId?: SortOrderInput | SortOrder
    sort?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdItemCountOrderByAggregateInput
    _avg?: AdItemAvgOrderByAggregateInput
    _max?: AdItemMaxOrderByAggregateInput
    _min?: AdItemMinOrderByAggregateInput
    _sum?: AdItemSumOrderByAggregateInput
  }

  export type AdItemScalarWhereWithAggregatesInput = {
    AND?: AdItemScalarWhereWithAggregatesInput | AdItemScalarWhereWithAggregatesInput[]
    OR?: AdItemScalarWhereWithAggregatesInput[]
    NOT?: AdItemScalarWhereWithAggregatesInput | AdItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdItem"> | string
    sourceType?: EnumAdItemSourceTypeWithAggregatesFilter<"AdItem"> | $Enums.AdItemSourceType
    adBlockId?: StringWithAggregatesFilter<"AdItem"> | string
    title?: StringNullableWithAggregatesFilter<"AdItem"> | string | null
    description?: StringNullableWithAggregatesFilter<"AdItem"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"AdItem"> | string | null
    url?: StringNullableWithAggregatesFilter<"AdItem"> | string | null
    postRootId?: StringNullableWithAggregatesFilter<"AdItem"> | string | null
    productRootId?: StringNullableWithAggregatesFilter<"AdItem"> | string | null
    sort?: IntNullableWithAggregatesFilter<"AdItem"> | number | null
    isActive?: BoolWithAggregatesFilter<"AdItem"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AdItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdItem"> | Date | string
  }

  export type PurchaseWhereInput = {
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    id?: StringFilter<"Purchase"> | string
    email?: StringFilter<"Purchase"> | string
    productId?: StringFilter<"Purchase"> | string
    productRootId?: StringFilter<"Purchase"> | string
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type PurchaseOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    productId?: SortOrder
    productRootId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type PurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    email?: StringFilter<"Purchase"> | string
    productId?: StringFilter<"Purchase"> | string
    productRootId?: StringFilter<"Purchase"> | string
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type PurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    productId?: SortOrder
    productRootId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseCountOrderByAggregateInput
    _max?: PurchaseMaxOrderByAggregateInput
    _min?: PurchaseMinOrderByAggregateInput
  }

  export type PurchaseScalarWhereWithAggregatesInput = {
    AND?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    OR?: PurchaseScalarWhereWithAggregatesInput[]
    NOT?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Purchase"> | string
    email?: StringWithAggregatesFilter<"Purchase"> | string
    productId?: StringWithAggregatesFilter<"Purchase"> | string
    productRootId?: StringWithAggregatesFilter<"Purchase"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
  }

  export type ContactFormWhereInput = {
    AND?: ContactFormWhereInput | ContactFormWhereInput[]
    OR?: ContactFormWhereInput[]
    NOT?: ContactFormWhereInput | ContactFormWhereInput[]
    id?: StringFilter<"ContactForm"> | string
    name?: StringNullableFilter<"ContactForm"> | string | null
    email?: StringNullableFilter<"ContactForm"> | string | null
    subject?: StringNullableFilter<"ContactForm"> | string | null
    message?: StringNullableFilter<"ContactForm"> | string | null
    createdAt?: DateTimeFilter<"ContactForm"> | Date | string
    updatedAt?: DateTimeFilter<"ContactForm"> | Date | string
  }

  export type ContactFormOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactFormWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactFormWhereInput | ContactFormWhereInput[]
    OR?: ContactFormWhereInput[]
    NOT?: ContactFormWhereInput | ContactFormWhereInput[]
    name?: StringNullableFilter<"ContactForm"> | string | null
    email?: StringNullableFilter<"ContactForm"> | string | null
    subject?: StringNullableFilter<"ContactForm"> | string | null
    message?: StringNullableFilter<"ContactForm"> | string | null
    createdAt?: DateTimeFilter<"ContactForm"> | Date | string
    updatedAt?: DateTimeFilter<"ContactForm"> | Date | string
  }, "id">

  export type ContactFormOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactFormCountOrderByAggregateInput
    _max?: ContactFormMaxOrderByAggregateInput
    _min?: ContactFormMinOrderByAggregateInput
  }

  export type ContactFormScalarWhereWithAggregatesInput = {
    AND?: ContactFormScalarWhereWithAggregatesInput | ContactFormScalarWhereWithAggregatesInput[]
    OR?: ContactFormScalarWhereWithAggregatesInput[]
    NOT?: ContactFormScalarWhereWithAggregatesInput | ContactFormScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactForm"> | string
    name?: StringNullableWithAggregatesFilter<"ContactForm"> | string | null
    email?: StringNullableWithAggregatesFilter<"ContactForm"> | string | null
    subject?: StringNullableWithAggregatesFilter<"ContactForm"> | string | null
    message?: StringNullableWithAggregatesFilter<"ContactForm"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContactForm"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactForm"> | Date | string
  }

  export type FormWhereInput = {
    AND?: FormWhereInput | FormWhereInput[]
    OR?: FormWhereInput[]
    NOT?: FormWhereInput | FormWhereInput[]
    id?: StringFilter<"Form"> | string
    name?: StringFilter<"Form"> | string
    fields?: JsonNullableFilter<"Form">
    submitLabel?: StringNullableFilter<"Form"> | string | null
    gtmEventName?: StringNullableFilter<"Form"> | string | null
    gtmCategory?: StringNullableFilter<"Form"> | string | null
    gtmLabel?: StringNullableFilter<"Form"> | string | null
    createdAt?: DateTimeFilter<"Form"> | Date | string
    updatedAt?: DateTimeFilter<"Form"> | Date | string
    products?: ProductListRelationFilter
    submissions?: FormSubmissionListRelationFilter
  }

  export type FormOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    fields?: SortOrderInput | SortOrder
    submitLabel?: SortOrderInput | SortOrder
    gtmEventName?: SortOrderInput | SortOrder
    gtmCategory?: SortOrderInput | SortOrder
    gtmLabel?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    submissions?: FormSubmissionOrderByRelationAggregateInput
  }

  export type FormWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FormWhereInput | FormWhereInput[]
    OR?: FormWhereInput[]
    NOT?: FormWhereInput | FormWhereInput[]
    name?: StringFilter<"Form"> | string
    fields?: JsonNullableFilter<"Form">
    submitLabel?: StringNullableFilter<"Form"> | string | null
    gtmEventName?: StringNullableFilter<"Form"> | string | null
    gtmCategory?: StringNullableFilter<"Form"> | string | null
    gtmLabel?: StringNullableFilter<"Form"> | string | null
    createdAt?: DateTimeFilter<"Form"> | Date | string
    updatedAt?: DateTimeFilter<"Form"> | Date | string
    products?: ProductListRelationFilter
    submissions?: FormSubmissionListRelationFilter
  }, "id">

  export type FormOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    fields?: SortOrderInput | SortOrder
    submitLabel?: SortOrderInput | SortOrder
    gtmEventName?: SortOrderInput | SortOrder
    gtmCategory?: SortOrderInput | SortOrder
    gtmLabel?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FormCountOrderByAggregateInput
    _max?: FormMaxOrderByAggregateInput
    _min?: FormMinOrderByAggregateInput
  }

  export type FormScalarWhereWithAggregatesInput = {
    AND?: FormScalarWhereWithAggregatesInput | FormScalarWhereWithAggregatesInput[]
    OR?: FormScalarWhereWithAggregatesInput[]
    NOT?: FormScalarWhereWithAggregatesInput | FormScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Form"> | string
    name?: StringWithAggregatesFilter<"Form"> | string
    fields?: JsonNullableWithAggregatesFilter<"Form">
    submitLabel?: StringNullableWithAggregatesFilter<"Form"> | string | null
    gtmEventName?: StringNullableWithAggregatesFilter<"Form"> | string | null
    gtmCategory?: StringNullableWithAggregatesFilter<"Form"> | string | null
    gtmLabel?: StringNullableWithAggregatesFilter<"Form"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Form"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Form"> | Date | string
  }

  export type FormSubmissionWhereInput = {
    AND?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    OR?: FormSubmissionWhereInput[]
    NOT?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    id?: StringFilter<"FormSubmission"> | string
    formId?: StringFilter<"FormSubmission"> | string
    email?: StringNullableFilter<"FormSubmission"> | string | null
    data?: JsonFilter<"FormSubmission">
    createdAt?: DateTimeFilter<"FormSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"FormSubmission"> | Date | string
    form?: XOR<FormScalarRelationFilter, FormWhereInput>
  }

  export type FormSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    formId?: SortOrder
    email?: SortOrderInput | SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    form?: FormOrderByWithRelationInput
  }

  export type FormSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    OR?: FormSubmissionWhereInput[]
    NOT?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    formId?: StringFilter<"FormSubmission"> | string
    email?: StringNullableFilter<"FormSubmission"> | string | null
    data?: JsonFilter<"FormSubmission">
    createdAt?: DateTimeFilter<"FormSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"FormSubmission"> | Date | string
    form?: XOR<FormScalarRelationFilter, FormWhereInput>
  }, "id">

  export type FormSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    formId?: SortOrder
    email?: SortOrderInput | SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FormSubmissionCountOrderByAggregateInput
    _max?: FormSubmissionMaxOrderByAggregateInput
    _min?: FormSubmissionMinOrderByAggregateInput
  }

  export type FormSubmissionScalarWhereWithAggregatesInput = {
    AND?: FormSubmissionScalarWhereWithAggregatesInput | FormSubmissionScalarWhereWithAggregatesInput[]
    OR?: FormSubmissionScalarWhereWithAggregatesInput[]
    NOT?: FormSubmissionScalarWhereWithAggregatesInput | FormSubmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormSubmission"> | string
    formId?: StringWithAggregatesFilter<"FormSubmission"> | string
    email?: StringNullableWithAggregatesFilter<"FormSubmission"> | string | null
    data?: JsonWithAggregatesFilter<"FormSubmission">
    createdAt?: DateTimeWithAggregatesFilter<"FormSubmission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FormSubmission"> | Date | string
  }

  export type FormatWhereInput = {
    AND?: FormatWhereInput | FormatWhereInput[]
    OR?: FormatWhereInput[]
    NOT?: FormatWhereInput | FormatWhereInput[]
    id?: StringFilter<"Format"> | string
    title?: StringFilter<"Format"> | string
    createdAt?: DateTimeFilter<"Format"> | Date | string
    updatedAt?: DateTimeFilter<"Format"> | Date | string
    Impression?: ImpressionListRelationFilter
  }

  export type FormatOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Impression?: ImpressionOrderByRelationAggregateInput
  }

  export type FormatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FormatWhereInput | FormatWhereInput[]
    OR?: FormatWhereInput[]
    NOT?: FormatWhereInput | FormatWhereInput[]
    title?: StringFilter<"Format"> | string
    createdAt?: DateTimeFilter<"Format"> | Date | string
    updatedAt?: DateTimeFilter<"Format"> | Date | string
    Impression?: ImpressionListRelationFilter
  }, "id">

  export type FormatOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FormatCountOrderByAggregateInput
    _max?: FormatMaxOrderByAggregateInput
    _min?: FormatMinOrderByAggregateInput
  }

  export type FormatScalarWhereWithAggregatesInput = {
    AND?: FormatScalarWhereWithAggregatesInput | FormatScalarWhereWithAggregatesInput[]
    OR?: FormatScalarWhereWithAggregatesInput[]
    NOT?: FormatScalarWhereWithAggregatesInput | FormatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Format"> | string
    title?: StringWithAggregatesFilter<"Format"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Format"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Format"> | Date | string
  }

  export type GenreWhereInput = {
    AND?: GenreWhereInput | GenreWhereInput[]
    OR?: GenreWhereInput[]
    NOT?: GenreWhereInput | GenreWhereInput[]
    id?: StringFilter<"Genre"> | string
    title?: StringFilter<"Genre"> | string
    createdAt?: DateTimeFilter<"Genre"> | Date | string
    updatedAt?: DateTimeFilter<"Genre"> | Date | string
    Impression?: ImpressionListRelationFilter
  }

  export type GenreOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Impression?: ImpressionOrderByRelationAggregateInput
  }

  export type GenreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GenreWhereInput | GenreWhereInput[]
    OR?: GenreWhereInput[]
    NOT?: GenreWhereInput | GenreWhereInput[]
    title?: StringFilter<"Genre"> | string
    createdAt?: DateTimeFilter<"Genre"> | Date | string
    updatedAt?: DateTimeFilter<"Genre"> | Date | string
    Impression?: ImpressionListRelationFilter
  }, "id">

  export type GenreOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GenreCountOrderByAggregateInput
    _max?: GenreMaxOrderByAggregateInput
    _min?: GenreMinOrderByAggregateInput
  }

  export type GenreScalarWhereWithAggregatesInput = {
    AND?: GenreScalarWhereWithAggregatesInput | GenreScalarWhereWithAggregatesInput[]
    OR?: GenreScalarWhereWithAggregatesInput[]
    NOT?: GenreScalarWhereWithAggregatesInput | GenreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Genre"> | string
    title?: StringWithAggregatesFilter<"Genre"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Genre"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Genre"> | Date | string
  }

  export type ImpressionWhereInput = {
    AND?: ImpressionWhereInput | ImpressionWhereInput[]
    OR?: ImpressionWhereInput[]
    NOT?: ImpressionWhereInput | ImpressionWhereInput[]
    id?: StringFilter<"Impression"> | string
    title?: StringFilter<"Impression"> | string
    firstName?: StringNullableFilter<"Impression"> | string | null
    lastName?: StringNullableFilter<"Impression"> | string | null
    email?: StringFilter<"Impression"> | string
    pageCount?: IntNullableFilter<"Impression"> | number | null
    formatId?: StringNullableFilter<"Impression"> | string | null
    genreId?: StringNullableFilter<"Impression"> | string | null
    fileId?: StringNullableFilter<"Impression"> | string | null
    createdAt?: DateTimeFilter<"Impression"> | Date | string
    updatedAt?: DateTimeFilter<"Impression"> | Date | string
    format?: XOR<FormatNullableScalarRelationFilter, FormatWhereInput> | null
    genre?: XOR<GenreNullableScalarRelationFilter, GenreWhereInput> | null
    file?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
  }

  export type ImpressionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrder
    pageCount?: SortOrderInput | SortOrder
    formatId?: SortOrderInput | SortOrder
    genreId?: SortOrderInput | SortOrder
    fileId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    format?: FormatOrderByWithRelationInput
    genre?: GenreOrderByWithRelationInput
    file?: MediaOrderByWithRelationInput
  }

  export type ImpressionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fileId?: string
    AND?: ImpressionWhereInput | ImpressionWhereInput[]
    OR?: ImpressionWhereInput[]
    NOT?: ImpressionWhereInput | ImpressionWhereInput[]
    title?: StringFilter<"Impression"> | string
    firstName?: StringNullableFilter<"Impression"> | string | null
    lastName?: StringNullableFilter<"Impression"> | string | null
    email?: StringFilter<"Impression"> | string
    pageCount?: IntNullableFilter<"Impression"> | number | null
    formatId?: StringNullableFilter<"Impression"> | string | null
    genreId?: StringNullableFilter<"Impression"> | string | null
    createdAt?: DateTimeFilter<"Impression"> | Date | string
    updatedAt?: DateTimeFilter<"Impression"> | Date | string
    format?: XOR<FormatNullableScalarRelationFilter, FormatWhereInput> | null
    genre?: XOR<GenreNullableScalarRelationFilter, GenreWhereInput> | null
    file?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
  }, "id" | "fileId">

  export type ImpressionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrder
    pageCount?: SortOrderInput | SortOrder
    formatId?: SortOrderInput | SortOrder
    genreId?: SortOrderInput | SortOrder
    fileId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ImpressionCountOrderByAggregateInput
    _avg?: ImpressionAvgOrderByAggregateInput
    _max?: ImpressionMaxOrderByAggregateInput
    _min?: ImpressionMinOrderByAggregateInput
    _sum?: ImpressionSumOrderByAggregateInput
  }

  export type ImpressionScalarWhereWithAggregatesInput = {
    AND?: ImpressionScalarWhereWithAggregatesInput | ImpressionScalarWhereWithAggregatesInput[]
    OR?: ImpressionScalarWhereWithAggregatesInput[]
    NOT?: ImpressionScalarWhereWithAggregatesInput | ImpressionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Impression"> | string
    title?: StringWithAggregatesFilter<"Impression"> | string
    firstName?: StringNullableWithAggregatesFilter<"Impression"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"Impression"> | string | null
    email?: StringWithAggregatesFilter<"Impression"> | string
    pageCount?: IntNullableWithAggregatesFilter<"Impression"> | number | null
    formatId?: StringNullableWithAggregatesFilter<"Impression"> | string | null
    genreId?: StringNullableWithAggregatesFilter<"Impression"> | string | null
    fileId?: StringNullableWithAggregatesFilter<"Impression"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Impression"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Impression"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type SocialChannelWhereInput = {
    AND?: SocialChannelWhereInput | SocialChannelWhereInput[]
    OR?: SocialChannelWhereInput[]
    NOT?: SocialChannelWhereInput | SocialChannelWhereInput[]
    id?: StringFilter<"SocialChannel"> | string
    key?: EnumSocialKeyFilter<"SocialChannel"> | $Enums.SocialKey
    url?: StringNullableFilter<"SocialChannel"> | string | null
    entityId?: StringFilter<"SocialChannel"> | string
    entityType?: EnumSocialEntityTypeFilter<"SocialChannel"> | $Enums.SocialEntityType
    createdAt?: DateTimeFilter<"SocialChannel"> | Date | string
    updatedAt?: DateTimeFilter<"SocialChannel"> | Date | string
  }

  export type SocialChannelOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    url?: SortOrderInput | SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialChannelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key_entityId_entityType?: SocialChannelKeyEntityIdEntityTypeCompoundUniqueInput
    AND?: SocialChannelWhereInput | SocialChannelWhereInput[]
    OR?: SocialChannelWhereInput[]
    NOT?: SocialChannelWhereInput | SocialChannelWhereInput[]
    key?: EnumSocialKeyFilter<"SocialChannel"> | $Enums.SocialKey
    url?: StringNullableFilter<"SocialChannel"> | string | null
    entityId?: StringFilter<"SocialChannel"> | string
    entityType?: EnumSocialEntityTypeFilter<"SocialChannel"> | $Enums.SocialEntityType
    createdAt?: DateTimeFilter<"SocialChannel"> | Date | string
    updatedAt?: DateTimeFilter<"SocialChannel"> | Date | string
  }, "id" | "key_entityId_entityType">

  export type SocialChannelOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    url?: SortOrderInput | SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SocialChannelCountOrderByAggregateInput
    _max?: SocialChannelMaxOrderByAggregateInput
    _min?: SocialChannelMinOrderByAggregateInput
  }

  export type SocialChannelScalarWhereWithAggregatesInput = {
    AND?: SocialChannelScalarWhereWithAggregatesInput | SocialChannelScalarWhereWithAggregatesInput[]
    OR?: SocialChannelScalarWhereWithAggregatesInput[]
    NOT?: SocialChannelScalarWhereWithAggregatesInput | SocialChannelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SocialChannel"> | string
    key?: EnumSocialKeyWithAggregatesFilter<"SocialChannel"> | $Enums.SocialKey
    url?: StringNullableWithAggregatesFilter<"SocialChannel"> | string | null
    entityId?: StringWithAggregatesFilter<"SocialChannel"> | string
    entityType?: EnumSocialEntityTypeWithAggregatesFilter<"SocialChannel"> | $Enums.SocialEntityType
    createdAt?: DateTimeWithAggregatesFilter<"SocialChannel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SocialChannel"> | Date | string
  }

  export type LanguageCreateInput = {
    id?: string
    code: string
    name: string
    slug?: string | null
    isActive?: boolean
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LanguageUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    slug?: string | null
    isActive?: boolean
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LanguageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageCreateManyInput = {
    id?: string
    code: string
    name: string
    slug?: string | null
    isActive?: boolean
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LanguageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsCreateInput = {
    id?: string
    siteName?: string | null
    siteUrl?: string | null
    deployWebhookUrl?: string | null
    logoUrl?: string | null
    scripts?:PrismaJson.Scripts
    createdAt?: Date | string
    updatedAt?: Date | string
    seo?: SeoCreateNestedOneWithoutSettingsInput
  }

  export type SettingsUncheckedCreateInput = {
    id?: string
    siteName?: string | null
    siteUrl?: string | null
    deployWebhookUrl?: string | null
    logoUrl?: string | null
    scripts?:PrismaJson.Scripts
    seoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    siteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deployWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scripts?:PrismaJson.Scripts
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seo?: SeoUpdateOneWithoutSettingsNestedInput
  }

  export type SettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    siteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deployWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scripts?:PrismaJson.Scripts
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsCreateManyInput = {
    id?: string
    siteName?: string | null
    siteUrl?: string | null
    deployWebhookUrl?: string | null
    logoUrl?: string | null
    scripts?:PrismaJson.Scripts
    seoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    siteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deployWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scripts?:PrismaJson.Scripts
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    siteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deployWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scripts?:PrismaJson.Scripts
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WidgetCreateInput = {
    id?: string
    name: string
    section: $Enums.WidgetSection
    type: $Enums.WidgetType
    sort: number
    isEnabled?: boolean
    metadata?:PrismaJson.WidgetMetadata | NullableJsonNullValueInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WidgetUncheckedCreateInput = {
    id?: string
    name: string
    section: $Enums.WidgetSection
    type: $Enums.WidgetType
    sort: number
    isEnabled?: boolean
    metadata?:PrismaJson.WidgetMetadata | NullableJsonNullValueInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WidgetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: EnumWidgetSectionFieldUpdateOperationsInput | $Enums.WidgetSection
    type?: EnumWidgetTypeFieldUpdateOperationsInput | $Enums.WidgetType
    sort?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.WidgetMetadata | NullableJsonNullValueInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WidgetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: EnumWidgetSectionFieldUpdateOperationsInput | $Enums.WidgetSection
    type?: EnumWidgetTypeFieldUpdateOperationsInput | $Enums.WidgetType
    sort?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.WidgetMetadata | NullableJsonNullValueInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WidgetCreateManyInput = {
    id?: string
    name: string
    section: $Enums.WidgetSection
    type: $Enums.WidgetType
    sort: number
    isEnabled?: boolean
    metadata?:PrismaJson.WidgetMetadata | NullableJsonNullValueInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WidgetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: EnumWidgetSectionFieldUpdateOperationsInput | $Enums.WidgetSection
    type?: EnumWidgetTypeFieldUpdateOperationsInput | $Enums.WidgetType
    sort?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.WidgetMetadata | NullableJsonNullValueInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WidgetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: EnumWidgetSectionFieldUpdateOperationsInput | $Enums.WidgetSection
    type?: EnumWidgetTypeFieldUpdateOperationsInput | $Enums.WidgetType
    sort?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.WidgetMetadata | NullableJsonNullValueInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateManyInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUncheckedCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    bio?: string | null
    imageUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    profileImage?: MediaCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    postAuthors?: PostAuthorCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    profileImageId?: string | null
    bio?: string | null
    imageUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    postAuthors?: PostAuthorUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: MediaUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    postAuthors?: PostAuthorUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageId?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    postAuthors?: PostAuthorUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    profileImageId?: string | null
    bio?: string | null
    imageUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageId?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scope?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scope?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scope?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerificationTokenCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCreateInput = {
    id?: string
    name: string
    key?: string | null
    url: string
    size?: number | null
    type?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    post?: PostCreateNestedManyWithoutImageCoverInput
    seo?: SeoCreateNestedManyWithoutOgTwitterImageInput
    product?: ProductCreateNestedManyWithoutImageCoverInput
    impression?: ImpressionCreateNestedOneWithoutFileInput
    products?: ProductGalleryCreateNestedManyWithoutMediaInput
    user?: UserCreateNestedManyWithoutProfileImageInput
  }

  export type MediaUncheckedCreateInput = {
    id?: string
    name: string
    key?: string | null
    url: string
    size?: number | null
    type?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    post?: PostUncheckedCreateNestedManyWithoutImageCoverInput
    seo?: SeoUncheckedCreateNestedManyWithoutOgTwitterImageInput
    product?: ProductUncheckedCreateNestedManyWithoutImageCoverInput
    impression?: ImpressionUncheckedCreateNestedOneWithoutFileInput
    products?: ProductGalleryUncheckedCreateNestedManyWithoutMediaInput
    user?: UserUncheckedCreateNestedManyWithoutProfileImageInput
  }

  export type MediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateManyWithoutImageCoverNestedInput
    seo?: SeoUpdateManyWithoutOgTwitterImageNestedInput
    product?: ProductUpdateManyWithoutImageCoverNestedInput
    impression?: ImpressionUpdateOneWithoutFileNestedInput
    products?: ProductGalleryUpdateManyWithoutMediaNestedInput
    user?: UserUpdateManyWithoutProfileImageNestedInput
  }

  export type MediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUncheckedUpdateManyWithoutImageCoverNestedInput
    seo?: SeoUncheckedUpdateManyWithoutOgTwitterImageNestedInput
    product?: ProductUncheckedUpdateManyWithoutImageCoverNestedInput
    impression?: ImpressionUncheckedUpdateOneWithoutFileNestedInput
    products?: ProductGalleryUncheckedUpdateManyWithoutMediaNestedInput
    user?: UserUncheckedUpdateManyWithoutProfileImageNestedInput
  }

  export type MediaCreateManyInput = {
    id?: string
    name: string
    key?: string | null
    url: string
    size?: number | null
    type?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeoCreateInput = {
    id?: string
    title: string
    description?: string | null
    canonicalUrl?: string | null
    version: number
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: string | null
    ogTwitterTitle?: string | null
    ogTwitterDescription?: string | null
    ogTwitterLocale?: string | null
    ogTwitterUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ogTwitterImage?: MediaCreateNestedOneWithoutSeoInput
    root?: SeoCreateNestedOneWithoutRootChildrenInput
    rootChildren?: SeoCreateNestedManyWithoutRootInput
    settings?: SettingsCreateNestedManyWithoutSeoInput
    posts?: PostCreateNestedManyWithoutSeoInput
    categories?: CategoryCreateNestedManyWithoutSeoInput
    tags?: TagCreateNestedManyWithoutSeoInput
    products?: ProductCreateNestedManyWithoutSeoInput
    productCategories?: ProductCategoryCreateNestedManyWithoutSeoInput
  }

  export type SeoUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    canonicalUrl?: string | null
    version: number
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: string | null
    ogTwitterTitle?: string | null
    ogTwitterDescription?: string | null
    ogTwitterImageId?: string | null
    ogTwitterLocale?: string | null
    ogTwitterUrl?: string | null
    rootId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: SeoUncheckedCreateNestedManyWithoutRootInput
    settings?: SettingsUncheckedCreateNestedManyWithoutSeoInput
    posts?: PostUncheckedCreateNestedManyWithoutSeoInput
    categories?: CategoryUncheckedCreateNestedManyWithoutSeoInput
    tags?: TagUncheckedCreateNestedManyWithoutSeoInput
    products?: ProductUncheckedCreateNestedManyWithoutSeoInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutSeoInput
  }

  export type SeoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    ogTwitterType?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterLocale?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ogTwitterImage?: MediaUpdateOneWithoutSeoNestedInput
    root?: SeoUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: SeoUpdateManyWithoutRootNestedInput
    settings?: SettingsUpdateManyWithoutSeoNestedInput
    posts?: PostUpdateManyWithoutSeoNestedInput
    categories?: CategoryUpdateManyWithoutSeoNestedInput
    tags?: TagUpdateManyWithoutSeoNestedInput
    products?: ProductUpdateManyWithoutSeoNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutSeoNestedInput
  }

  export type SeoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    ogTwitterType?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterImageId?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterLocale?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: SeoUncheckedUpdateManyWithoutRootNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutSeoNestedInput
    posts?: PostUncheckedUpdateManyWithoutSeoNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutSeoNestedInput
    tags?: TagUncheckedUpdateManyWithoutSeoNestedInput
    products?: ProductUncheckedUpdateManyWithoutSeoNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutSeoNestedInput
  }

  export type SeoCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    canonicalUrl?: string | null
    version: number
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: string | null
    ogTwitterTitle?: string | null
    ogTwitterDescription?: string | null
    ogTwitterImageId?: string | null
    ogTwitterLocale?: string | null
    ogTwitterUrl?: string | null
    rootId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    ogTwitterType?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterLocale?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    ogTwitterType?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterImageId?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterLocale?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    editorType?: $Enums.EditorType
    bodyData:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    root?: PostCreateNestedOneWithoutRootChildrenInput
    rootChildren?: PostCreateNestedManyWithoutRootInput
    imageCover?: MediaCreateNestedOneWithoutPostInput
    postCategories?: PostCategoryCreateNestedManyWithoutPostInput
    tags?: TagCreateNestedManyWithoutPostsInput
    seo?: SeoCreateNestedOneWithoutPostsInput
    postAuthors?: PostAuthorCreateNestedManyWithoutPostInput
    user?: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    editorType?: $Enums.EditorType
    bodyData:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: string | null
    imageCoverId?: string | null
    seoId?: string | null
    userId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: PostUncheckedCreateNestedManyWithoutRootInput
    postCategories?: PostCategoryUncheckedCreateNestedManyWithoutPostInput
    tags?: TagUncheckedCreateNestedManyWithoutPostsInput
    postAuthors?: PostAuthorUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    root?: PostUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: PostUpdateManyWithoutRootNestedInput
    imageCover?: MediaUpdateOneWithoutPostNestedInput
    postCategories?: PostCategoryUpdateManyWithoutPostNestedInput
    tags?: TagUpdateManyWithoutPostsNestedInput
    seo?: SeoUpdateOneWithoutPostsNestedInput
    postAuthors?: PostAuthorUpdateManyWithoutPostNestedInput
    user?: UserUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: PostUncheckedUpdateManyWithoutRootNestedInput
    postCategories?: PostCategoryUncheckedUpdateManyWithoutPostNestedInput
    tags?: TagUncheckedUpdateManyWithoutPostsNestedInput
    postAuthors?: PostAuthorUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    editorType?: $Enums.EditorType
    bodyData:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: string | null
    imageCoverId?: string | null
    seoId?: string | null
    userId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAuthorCreateInput = {
    sort: number
    post: PostCreateNestedOneWithoutPostAuthorsInput
    user: UserCreateNestedOneWithoutPostAuthorsInput
  }

  export type PostAuthorUncheckedCreateInput = {
    postId: string
    userId: string
    sort: number
  }

  export type PostAuthorUpdateInput = {
    sort?: IntFieldUpdateOperationsInput | number
    post?: PostUpdateOneRequiredWithoutPostAuthorsNestedInput
    user?: UserUpdateOneRequiredWithoutPostAuthorsNestedInput
  }

  export type PostAuthorUncheckedUpdateInput = {
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
  }

  export type PostAuthorCreateManyInput = {
    postId: string
    userId: string
    sort: number
  }

  export type PostAuthorUpdateManyMutationInput = {
    sort?: IntFieldUpdateOperationsInput | number
  }

  export type PostAuthorUncheckedUpdateManyInput = {
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
  }

  export type CategoryCreateInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    root?: CategoryCreateNestedOneWithoutRootChildrenInput
    rootChildren?: CategoryCreateNestedManyWithoutRootInput
    postCategories?: PostCategoryCreateNestedManyWithoutCategoryInput
    seo?: SeoCreateNestedOneWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    rootId?: string | null
    seoId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: CategoryUncheckedCreateNestedManyWithoutRootInput
    postCategories?: PostCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    root?: CategoryUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: CategoryUpdateManyWithoutRootNestedInput
    postCategories?: PostCategoryUpdateManyWithoutCategoryNestedInput
    seo?: SeoUpdateOneWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: CategoryUncheckedUpdateManyWithoutRootNestedInput
    postCategories?: PostCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    rootId?: string | null
    seoId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCategoryCreateInput = {
    sort: number
    post: PostCreateNestedOneWithoutPostCategoriesInput
    category: CategoryCreateNestedOneWithoutPostCategoriesInput
  }

  export type PostCategoryUncheckedCreateInput = {
    postId: string
    categoryId: string
    sort: number
  }

  export type PostCategoryUpdateInput = {
    sort?: IntFieldUpdateOperationsInput | number
    post?: PostUpdateOneRequiredWithoutPostCategoriesNestedInput
    category?: CategoryUpdateOneRequiredWithoutPostCategoriesNestedInput
  }

  export type PostCategoryUncheckedUpdateInput = {
    postId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
  }

  export type PostCategoryCreateManyInput = {
    postId: string
    categoryId: string
    sort: number
  }

  export type PostCategoryUpdateManyMutationInput = {
    sort?: IntFieldUpdateOperationsInput | number
  }

  export type PostCategoryUncheckedUpdateManyInput = {
    postId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
  }

  export type TagCreateInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    root?: TagCreateNestedOneWithoutRootChildrenInput
    rootChildren?: TagCreateNestedManyWithoutRootInput
    posts?: PostCreateNestedManyWithoutTagsInput
    seo?: SeoCreateNestedOneWithoutTagsInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    rootId?: string | null
    seoId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: TagUncheckedCreateNestedManyWithoutRootInput
    posts?: PostUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    root?: TagUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: TagUpdateManyWithoutRootNestedInput
    posts?: PostUpdateManyWithoutTagsNestedInput
    seo?: SeoUpdateOneWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: TagUncheckedUpdateManyWithoutRootNestedInput
    posts?: PostUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    rootId?: string | null
    seoId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSettingCreateInput = {
    id?: string
    emailSender?: string | null
    emailSenderName?: string | null
    emailResponse?: string | null
    emailProvider?: $Enums.EmailProvider | null
    emailApiKey?: string | null
    maxEmailsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionTemplate?: EmailTemplateCreateNestedOneWithoutEmailSettingSubscriptionInput
    freeEbookTemplate?: EmailTemplateCreateNestedOneWithoutEmailSettingFreeEbookInput
    webinarTemplate?: EmailTemplateCreateNestedOneWithoutEmailSettingWebinarInput
  }

  export type EmailSettingUncheckedCreateInput = {
    id?: string
    emailSender?: string | null
    emailSenderName?: string | null
    emailResponse?: string | null
    emailProvider?: $Enums.EmailProvider | null
    emailApiKey?: string | null
    maxEmailsPerDay?: number | null
    subscriptionTemplateId?: string | null
    freeEbookTemplateId?: string | null
    webinarTemplateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailSender?: NullableStringFieldUpdateOperationsInput | string | null
    emailSenderName?: NullableStringFieldUpdateOperationsInput | string | null
    emailResponse?: NullableStringFieldUpdateOperationsInput | string | null
    emailProvider?: NullableEnumEmailProviderFieldUpdateOperationsInput | $Enums.EmailProvider | null
    emailApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    maxEmailsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionTemplate?: EmailTemplateUpdateOneWithoutEmailSettingSubscriptionNestedInput
    freeEbookTemplate?: EmailTemplateUpdateOneWithoutEmailSettingFreeEbookNestedInput
    webinarTemplate?: EmailTemplateUpdateOneWithoutEmailSettingWebinarNestedInput
  }

  export type EmailSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailSender?: NullableStringFieldUpdateOperationsInput | string | null
    emailSenderName?: NullableStringFieldUpdateOperationsInput | string | null
    emailResponse?: NullableStringFieldUpdateOperationsInput | string | null
    emailProvider?: NullableEnumEmailProviderFieldUpdateOperationsInput | $Enums.EmailProvider | null
    emailApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    maxEmailsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    freeEbookTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    webinarTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSettingCreateManyInput = {
    id?: string
    emailSender?: string | null
    emailSenderName?: string | null
    emailResponse?: string | null
    emailProvider?: $Enums.EmailProvider | null
    emailApiKey?: string | null
    maxEmailsPerDay?: number | null
    subscriptionTemplateId?: string | null
    freeEbookTemplateId?: string | null
    webinarTemplateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailSender?: NullableStringFieldUpdateOperationsInput | string | null
    emailSenderName?: NullableStringFieldUpdateOperationsInput | string | null
    emailResponse?: NullableStringFieldUpdateOperationsInput | string | null
    emailProvider?: NullableEnumEmailProviderFieldUpdateOperationsInput | $Enums.EmailProvider | null
    emailApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    maxEmailsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailSender?: NullableStringFieldUpdateOperationsInput | string | null
    emailSenderName?: NullableStringFieldUpdateOperationsInput | string | null
    emailResponse?: NullableStringFieldUpdateOperationsInput | string | null
    emailProvider?: NullableEnumEmailProviderFieldUpdateOperationsInput | $Enums.EmailProvider | null
    emailApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    maxEmailsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    freeEbookTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    webinarTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailSettingSubscription?: EmailSettingCreateNestedManyWithoutSubscriptionTemplateInput
    emailSettingFreeEbook?: EmailSettingCreateNestedManyWithoutFreeEbookTemplateInput
    emailSettingWebinar?: EmailSettingCreateNestedManyWithoutWebinarTemplateInput
  }

  export type EmailTemplateUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailSettingSubscription?: EmailSettingUncheckedCreateNestedManyWithoutSubscriptionTemplateInput
    emailSettingFreeEbook?: EmailSettingUncheckedCreateNestedManyWithoutFreeEbookTemplateInput
    emailSettingWebinar?: EmailSettingUncheckedCreateNestedManyWithoutWebinarTemplateInput
  }

  export type EmailTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailSettingSubscription?: EmailSettingUpdateManyWithoutSubscriptionTemplateNestedInput
    emailSettingFreeEbook?: EmailSettingUpdateManyWithoutFreeEbookTemplateNestedInput
    emailSettingWebinar?: EmailSettingUpdateManyWithoutWebinarTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailSettingSubscription?: EmailSettingUncheckedUpdateManyWithoutSubscriptionTemplateNestedInput
    emailSettingFreeEbook?: EmailSettingUncheckedUpdateManyWithoutFreeEbookTemplateNestedInput
    emailSettingWebinar?: EmailSettingUncheckedUpdateManyWithoutWebinarTemplateNestedInput
  }

  export type EmailTemplateCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAudienceCreateInput = {
    id?: string
    name: string
    type?: $Enums.AudienceType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: EmailContactCreateNestedManyWithoutAudiencesInput
    emailSingleSends?: EmailSingleSendCreateNestedManyWithoutAudiencesInput
  }

  export type EmailAudienceUncheckedCreateInput = {
    id?: string
    name: string
    type?: $Enums.AudienceType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: EmailContactUncheckedCreateNestedManyWithoutAudiencesInput
    emailSingleSends?: EmailSingleSendUncheckedCreateNestedManyWithoutAudiencesInput
  }

  export type EmailAudienceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAudienceTypeFieldUpdateOperationsInput | $Enums.AudienceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: EmailContactUpdateManyWithoutAudiencesNestedInput
    emailSingleSends?: EmailSingleSendUpdateManyWithoutAudiencesNestedInput
  }

  export type EmailAudienceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAudienceTypeFieldUpdateOperationsInput | $Enums.AudienceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: EmailContactUncheckedUpdateManyWithoutAudiencesNestedInput
    emailSingleSends?: EmailSingleSendUncheckedUpdateManyWithoutAudiencesNestedInput
  }

  export type EmailAudienceCreateManyInput = {
    id?: string
    name: string
    type?: $Enums.AudienceType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailAudienceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAudienceTypeFieldUpdateOperationsInput | $Enums.AudienceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAudienceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAudienceTypeFieldUpdateOperationsInput | $Enums.AudienceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailContactCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    isSubscriber?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    audiences?: EmailAudienceCreateNestedManyWithoutContactsInput
    interactions?: EmailContactInteractionCreateNestedManyWithoutContactInput
    emailSingleSendLogs?: EmailSingleSendLogCreateNestedManyWithoutContactInput
  }

  export type EmailContactUncheckedCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    isSubscriber?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    audiences?: EmailAudienceUncheckedCreateNestedManyWithoutContactsInput
    interactions?: EmailContactInteractionUncheckedCreateNestedManyWithoutContactInput
    emailSingleSendLogs?: EmailSingleSendLogUncheckedCreateNestedManyWithoutContactInput
  }

  export type EmailContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscriber?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audiences?: EmailAudienceUpdateManyWithoutContactsNestedInput
    interactions?: EmailContactInteractionUpdateManyWithoutContactNestedInput
    emailSingleSendLogs?: EmailSingleSendLogUpdateManyWithoutContactNestedInput
  }

  export type EmailContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscriber?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audiences?: EmailAudienceUncheckedUpdateManyWithoutContactsNestedInput
    interactions?: EmailContactInteractionUncheckedUpdateManyWithoutContactNestedInput
    emailSingleSendLogs?: EmailSingleSendLogUncheckedUpdateManyWithoutContactNestedInput
  }

  export type EmailContactCreateManyInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    isSubscriber?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscriber?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscriber?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailContactInteractionCreateInput = {
    id?: string
    interactionType: string
    interactionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: EmailContactCreateNestedOneWithoutInteractionsInput
  }

  export type EmailContactInteractionUncheckedCreateInput = {
    id?: string
    interactionType: string
    interactionDate?: Date | string
    contactId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailContactInteractionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: EmailContactUpdateOneRequiredWithoutInteractionsNestedInput
  }

  export type EmailContactInteractionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailContactInteractionCreateManyInput = {
    id?: string
    interactionType: string
    interactionDate?: Date | string
    contactId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailContactInteractionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailContactInteractionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSingleSendCreateInput = {
    id?: string
    name: string
    subject?: string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audiences?: EmailAudienceCreateNestedManyWithoutEmailSingleSendsInput
    emailSingleSendLogs?: EmailSingleSendLogCreateNestedManyWithoutSingleSendInput
  }

  export type EmailSingleSendUncheckedCreateInput = {
    id?: string
    name: string
    subject?: string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audiences?: EmailAudienceUncheckedCreateNestedManyWithoutEmailSingleSendsInput
    emailSingleSendLogs?: EmailSingleSendLogUncheckedCreateNestedManyWithoutSingleSendInput
  }

  export type EmailSingleSendUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audiences?: EmailAudienceUpdateManyWithoutEmailSingleSendsNestedInput
    emailSingleSendLogs?: EmailSingleSendLogUpdateManyWithoutSingleSendNestedInput
  }

  export type EmailSingleSendUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audiences?: EmailAudienceUncheckedUpdateManyWithoutEmailSingleSendsNestedInput
    emailSingleSendLogs?: EmailSingleSendLogUncheckedUpdateManyWithoutSingleSendNestedInput
  }

  export type EmailSingleSendCreateManyInput = {
    id?: string
    name: string
    subject?: string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailSingleSendUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSingleSendUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSubscriptionTokenCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailSubscriptionTokenUncheckedCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailSubscriptionTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSubscriptionTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSubscriptionTokenCreateManyInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailSubscriptionTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSubscriptionTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSendLogCreateInput = {
    id?: string
    to: string
    from: string
    subject?: string | null
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailSendLogUncheckedCreateInput = {
    id?: string
    to: string
    from: string
    subject?: string | null
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailSendLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSendLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSendLogCreateManyInput = {
    id?: string
    to: string
    from: string
    subject?: string | null
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailSendLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSendLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSingleSendLogCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: EmailContactCreateNestedOneWithoutEmailSingleSendLogsInput
    singleSend: EmailSingleSendCreateNestedOneWithoutEmailSingleSendLogsInput
  }

  export type EmailSingleSendLogUncheckedCreateInput = {
    id?: string
    contactId: string
    singleSendId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailSingleSendLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: EmailContactUpdateOneRequiredWithoutEmailSingleSendLogsNestedInput
    singleSend?: EmailSingleSendUpdateOneRequiredWithoutEmailSingleSendLogsNestedInput
  }

  export type EmailSingleSendLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    singleSendId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSingleSendLogCreateManyInput = {
    id?: string
    contactId: string
    singleSendId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailSingleSendLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSingleSendLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    singleSendId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: Date | string
    updatedAt?: Date | string
    imageCover?: MediaCreateNestedOneWithoutProductInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    extras?: ProductExtraCreateNestedManyWithoutProductInput
    form?: FormCreateNestedOneWithoutProductsInput
    root?: ProductCreateNestedOneWithoutRootChildrenInput
    rootChildren?: ProductCreateNestedManyWithoutRootInput
    gallery?: ProductGalleryCreateNestedManyWithoutProductInput
    faqs?: ProductFAQCreateNestedManyWithoutProductInput
    purchases?: PurchaseCreateNestedManyWithoutProductInput
    seo?: SeoCreateNestedOneWithoutProductsInput
    user?: UserCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    imageCoverId?: string | null
    categoryId?: string | null
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: string | null
    rootId?: string | null
    seoId?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    extras?: ProductExtraUncheckedCreateNestedManyWithoutProductInput
    rootChildren?: ProductUncheckedCreateNestedManyWithoutRootInput
    gallery?: ProductGalleryUncheckedCreateNestedManyWithoutProductInput
    faqs?: ProductFAQUncheckedCreateNestedManyWithoutProductInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageCover?: MediaUpdateOneWithoutProductNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    extras?: ProductExtraUpdateManyWithoutProductNestedInput
    form?: FormUpdateOneWithoutProductsNestedInput
    root?: ProductUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: ProductUpdateManyWithoutRootNestedInput
    gallery?: ProductGalleryUpdateManyWithoutProductNestedInput
    faqs?: ProductFAQUpdateManyWithoutProductNestedInput
    purchases?: PurchaseUpdateManyWithoutProductNestedInput
    seo?: SeoUpdateOneWithoutProductsNestedInput
    user?: UserUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extras?: ProductExtraUncheckedUpdateManyWithoutProductNestedInput
    rootChildren?: ProductUncheckedUpdateManyWithoutRootNestedInput
    gallery?: ProductGalleryUncheckedUpdateManyWithoutProductNestedInput
    faqs?: ProductFAQUncheckedUpdateManyWithoutProductNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    imageCoverId?: string | null
    categoryId?: string | null
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: string | null
    rootId?: string | null
    seoId?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryCreateInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    root?: ProductCategoryCreateNestedOneWithoutRootChildrenInput
    rootChildren?: ProductCategoryCreateNestedManyWithoutRootInput
    products?: ProductCreateNestedManyWithoutCategoryInput
    seo?: SeoCreateNestedOneWithoutProductCategoriesInput
  }

  export type ProductCategoryUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    rootId?: string | null
    seoId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: ProductCategoryUncheckedCreateNestedManyWithoutRootInput
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    root?: ProductCategoryUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: ProductCategoryUpdateManyWithoutRootNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
    seo?: SeoUpdateOneWithoutProductCategoriesNestedInput
  }

  export type ProductCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: ProductCategoryUncheckedUpdateManyWithoutRootNestedInput
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryCreateManyInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    rootId?: string | null
    seoId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductGalleryCreateInput = {
    id?: string
    sort: number
    product: ProductCreateNestedOneWithoutGalleryInput
    media: MediaCreateNestedOneWithoutProductsInput
  }

  export type ProductGalleryUncheckedCreateInput = {
    id?: string
    sort: number
    productId: string
    mediaId: string
  }

  export type ProductGalleryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutGalleryNestedInput
    media?: MediaUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductGalleryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductGalleryCreateManyInput = {
    id?: string
    sort: number
    productId: string
    mediaId: string
  }

  export type ProductGalleryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
  }

  export type ProductGalleryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductExtraCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutExtrasInput
  }

  export type ProductExtraUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductExtraUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutExtrasNestedInput
  }

  export type ProductExtraUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductExtraCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductExtraUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductExtraUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductFAQCreateInput = {
    id?: string
    question: string
    answer: string
    sort: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutFaqsInput
  }

  export type ProductFAQUncheckedCreateInput = {
    id?: string
    question: string
    answer: string
    sort: number
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductFAQUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutFaqsNestedInput
  }

  export type ProductFAQUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductFAQCreateManyInput = {
    id?: string
    question: string
    answer: string
    sort: number
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductFAQUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductFAQUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdCampaignCreateInput = {
    id?: string
    name: string
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blocks?: AdBlockCreateNestedManyWithoutCampaignInput
  }

  export type AdCampaignUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blocks?: AdBlockUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type AdCampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: AdBlockUpdateManyWithoutCampaignNestedInput
  }

  export type AdCampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: AdBlockUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type AdCampaignCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdCampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdCampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdBlockCreateInput = {
    id?: string
    label: string
    layoutType: $Enums.AdLayoutType
    isActive?: boolean
    placement?: $Enums.AdPositionPlacement
    reference?: $Enums.AdPositionReference
    referenceCount?: number
    minWords?: number
    excludedPostIds?: AdBlockCreateexcludedPostIdsInput | string[]
    excludedCategoryIds?: AdBlockCreateexcludedCategoryIdsInput | string[]
    excludedTagIds?: AdBlockCreateexcludedTagIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: AdCampaignCreateNestedOneWithoutBlocksInput
    items?: AdItemCreateNestedManyWithoutAdBlockInput
  }

  export type AdBlockUncheckedCreateInput = {
    id?: string
    label: string
    layoutType: $Enums.AdLayoutType
    isActive?: boolean
    campaignId: string
    placement?: $Enums.AdPositionPlacement
    reference?: $Enums.AdPositionReference
    referenceCount?: number
    minWords?: number
    excludedPostIds?: AdBlockCreateexcludedPostIdsInput | string[]
    excludedCategoryIds?: AdBlockCreateexcludedCategoryIdsInput | string[]
    excludedTagIds?: AdBlockCreateexcludedTagIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: AdItemUncheckedCreateNestedManyWithoutAdBlockInput
  }

  export type AdBlockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    layoutType?: EnumAdLayoutTypeFieldUpdateOperationsInput | $Enums.AdLayoutType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    placement?: EnumAdPositionPlacementFieldUpdateOperationsInput | $Enums.AdPositionPlacement
    reference?: EnumAdPositionReferenceFieldUpdateOperationsInput | $Enums.AdPositionReference
    referenceCount?: IntFieldUpdateOperationsInput | number
    minWords?: IntFieldUpdateOperationsInput | number
    excludedPostIds?: AdBlockUpdateexcludedPostIdsInput | string[]
    excludedCategoryIds?: AdBlockUpdateexcludedCategoryIdsInput | string[]
    excludedTagIds?: AdBlockUpdateexcludedTagIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: AdCampaignUpdateOneRequiredWithoutBlocksNestedInput
    items?: AdItemUpdateManyWithoutAdBlockNestedInput
  }

  export type AdBlockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    layoutType?: EnumAdLayoutTypeFieldUpdateOperationsInput | $Enums.AdLayoutType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campaignId?: StringFieldUpdateOperationsInput | string
    placement?: EnumAdPositionPlacementFieldUpdateOperationsInput | $Enums.AdPositionPlacement
    reference?: EnumAdPositionReferenceFieldUpdateOperationsInput | $Enums.AdPositionReference
    referenceCount?: IntFieldUpdateOperationsInput | number
    minWords?: IntFieldUpdateOperationsInput | number
    excludedPostIds?: AdBlockUpdateexcludedPostIdsInput | string[]
    excludedCategoryIds?: AdBlockUpdateexcludedCategoryIdsInput | string[]
    excludedTagIds?: AdBlockUpdateexcludedTagIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: AdItemUncheckedUpdateManyWithoutAdBlockNestedInput
  }

  export type AdBlockCreateManyInput = {
    id?: string
    label: string
    layoutType: $Enums.AdLayoutType
    isActive?: boolean
    campaignId: string
    placement?: $Enums.AdPositionPlacement
    reference?: $Enums.AdPositionReference
    referenceCount?: number
    minWords?: number
    excludedPostIds?: AdBlockCreateexcludedPostIdsInput | string[]
    excludedCategoryIds?: AdBlockCreateexcludedCategoryIdsInput | string[]
    excludedTagIds?: AdBlockCreateexcludedTagIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdBlockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    layoutType?: EnumAdLayoutTypeFieldUpdateOperationsInput | $Enums.AdLayoutType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    placement?: EnumAdPositionPlacementFieldUpdateOperationsInput | $Enums.AdPositionPlacement
    reference?: EnumAdPositionReferenceFieldUpdateOperationsInput | $Enums.AdPositionReference
    referenceCount?: IntFieldUpdateOperationsInput | number
    minWords?: IntFieldUpdateOperationsInput | number
    excludedPostIds?: AdBlockUpdateexcludedPostIdsInput | string[]
    excludedCategoryIds?: AdBlockUpdateexcludedCategoryIdsInput | string[]
    excludedTagIds?: AdBlockUpdateexcludedTagIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdBlockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    layoutType?: EnumAdLayoutTypeFieldUpdateOperationsInput | $Enums.AdLayoutType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campaignId?: StringFieldUpdateOperationsInput | string
    placement?: EnumAdPositionPlacementFieldUpdateOperationsInput | $Enums.AdPositionPlacement
    reference?: EnumAdPositionReferenceFieldUpdateOperationsInput | $Enums.AdPositionReference
    referenceCount?: IntFieldUpdateOperationsInput | number
    minWords?: IntFieldUpdateOperationsInput | number
    excludedPostIds?: AdBlockUpdateexcludedPostIdsInput | string[]
    excludedCategoryIds?: AdBlockUpdateexcludedCategoryIdsInput | string[]
    excludedTagIds?: AdBlockUpdateexcludedTagIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdItemCreateInput = {
    id?: string
    sourceType: $Enums.AdItemSourceType
    title?: string | null
    description?: string | null
    imageUrl?: string | null
    url?: string | null
    postRootId?: string | null
    productRootId?: string | null
    sort?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    adBlock: AdBlockCreateNestedOneWithoutItemsInput
  }

  export type AdItemUncheckedCreateInput = {
    id?: string
    sourceType: $Enums.AdItemSourceType
    adBlockId: string
    title?: string | null
    description?: string | null
    imageUrl?: string | null
    url?: string | null
    postRootId?: string | null
    productRootId?: string | null
    sort?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumAdItemSourceTypeFieldUpdateOperationsInput | $Enums.AdItemSourceType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    postRootId?: NullableStringFieldUpdateOperationsInput | string | null
    productRootId?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adBlock?: AdBlockUpdateOneRequiredWithoutItemsNestedInput
  }

  export type AdItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumAdItemSourceTypeFieldUpdateOperationsInput | $Enums.AdItemSourceType
    adBlockId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    postRootId?: NullableStringFieldUpdateOperationsInput | string | null
    productRootId?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdItemCreateManyInput = {
    id?: string
    sourceType: $Enums.AdItemSourceType
    adBlockId: string
    title?: string | null
    description?: string | null
    imageUrl?: string | null
    url?: string | null
    postRootId?: string | null
    productRootId?: string | null
    sort?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumAdItemSourceTypeFieldUpdateOperationsInput | $Enums.AdItemSourceType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    postRootId?: NullableStringFieldUpdateOperationsInput | string | null
    productRootId?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumAdItemSourceTypeFieldUpdateOperationsInput | $Enums.AdItemSourceType
    adBlockId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    postRootId?: NullableStringFieldUpdateOperationsInput | string | null
    productRootId?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseCreateInput = {
    id?: string
    email: string
    productRootId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseUncheckedCreateInput = {
    id?: string
    email: string
    productId: string
    productRootId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    productRootId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    productRootId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseCreateManyInput = {
    id?: string
    email: string
    productId: string
    productRootId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    productRootId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    productRootId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFormCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    subject?: string | null
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactFormUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    subject?: string | null
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactFormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFormCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    subject?: string | null
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactFormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormCreateInput = {
    id?: string
    name: string
    fields?:PrismaJson.FormFields | NullableJsonNullValueInput
    submitLabel?: string | null
    gtmEventName?: string | null
    gtmCategory?: string | null
    gtmLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutFormInput
    submissions?: FormSubmissionCreateNestedManyWithoutFormInput
  }

  export type FormUncheckedCreateInput = {
    id?: string
    name: string
    fields?:PrismaJson.FormFields | NullableJsonNullValueInput
    submitLabel?: string | null
    gtmEventName?: string | null
    gtmCategory?: string | null
    gtmLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutFormInput
    submissions?: FormSubmissionUncheckedCreateNestedManyWithoutFormInput
  }

  export type FormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fields?:PrismaJson.FormFields | NullableJsonNullValueInput
    submitLabel?: NullableStringFieldUpdateOperationsInput | string | null
    gtmEventName?: NullableStringFieldUpdateOperationsInput | string | null
    gtmCategory?: NullableStringFieldUpdateOperationsInput | string | null
    gtmLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutFormNestedInput
    submissions?: FormSubmissionUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fields?:PrismaJson.FormFields | NullableJsonNullValueInput
    submitLabel?: NullableStringFieldUpdateOperationsInput | string | null
    gtmEventName?: NullableStringFieldUpdateOperationsInput | string | null
    gtmCategory?: NullableStringFieldUpdateOperationsInput | string | null
    gtmLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutFormNestedInput
    submissions?: FormSubmissionUncheckedUpdateManyWithoutFormNestedInput
  }

  export type FormCreateManyInput = {
    id?: string
    name: string
    fields?:PrismaJson.FormFields | NullableJsonNullValueInput
    submitLabel?: string | null
    gtmEventName?: string | null
    gtmCategory?: string | null
    gtmLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fields?:PrismaJson.FormFields | NullableJsonNullValueInput
    submitLabel?: NullableStringFieldUpdateOperationsInput | string | null
    gtmEventName?: NullableStringFieldUpdateOperationsInput | string | null
    gtmCategory?: NullableStringFieldUpdateOperationsInput | string | null
    gtmLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fields?:PrismaJson.FormFields | NullableJsonNullValueInput
    submitLabel?: NullableStringFieldUpdateOperationsInput | string | null
    gtmEventName?: NullableStringFieldUpdateOperationsInput | string | null
    gtmCategory?: NullableStringFieldUpdateOperationsInput | string | null
    gtmLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionCreateInput = {
    id?: string
    email?: string | null
    data:unknown
    createdAt?: Date | string
    updatedAt?: Date | string
    form: FormCreateNestedOneWithoutSubmissionsInput
  }

  export type FormSubmissionUncheckedCreateInput = {
    id?: string
    formId: string
    email?: string | null
    data:unknown
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    data?:unknown
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: FormUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type FormSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    data?:unknown
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionCreateManyInput = {
    id?: string
    formId: string
    email?: string | null
    data:unknown
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    data?:unknown
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    data?:unknown
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormatCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Impression?: ImpressionCreateNestedManyWithoutFormatInput
  }

  export type FormatUncheckedCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Impression?: ImpressionUncheckedCreateNestedManyWithoutFormatInput
  }

  export type FormatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Impression?: ImpressionUpdateManyWithoutFormatNestedInput
  }

  export type FormatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Impression?: ImpressionUncheckedUpdateManyWithoutFormatNestedInput
  }

  export type FormatCreateManyInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GenreCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Impression?: ImpressionCreateNestedManyWithoutGenreInput
  }

  export type GenreUncheckedCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Impression?: ImpressionUncheckedCreateNestedManyWithoutGenreInput
  }

  export type GenreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Impression?: ImpressionUpdateManyWithoutGenreNestedInput
  }

  export type GenreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Impression?: ImpressionUncheckedUpdateManyWithoutGenreNestedInput
  }

  export type GenreCreateManyInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GenreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GenreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpressionCreateInput = {
    id?: string
    title: string
    firstName?: string | null
    lastName?: string | null
    email: string
    pageCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    format?: FormatCreateNestedOneWithoutImpressionInput
    genre?: GenreCreateNestedOneWithoutImpressionInput
    file?: MediaCreateNestedOneWithoutImpressionInput
  }

  export type ImpressionUncheckedCreateInput = {
    id?: string
    title: string
    firstName?: string | null
    lastName?: string | null
    email: string
    pageCount?: number | null
    formatId?: string | null
    genreId?: string | null
    fileId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImpressionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    format?: FormatUpdateOneWithoutImpressionNestedInput
    genre?: GenreUpdateOneWithoutImpressionNestedInput
    file?: MediaUpdateOneWithoutImpressionNestedInput
  }

  export type ImpressionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    formatId?: NullableStringFieldUpdateOperationsInput | string | null
    genreId?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpressionCreateManyInput = {
    id?: string
    title: string
    firstName?: string | null
    lastName?: string | null
    email: string
    pageCount?: number | null
    formatId?: string | null
    genreId?: string | null
    fileId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImpressionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpressionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    formatId?: NullableStringFieldUpdateOperationsInput | string | null
    genreId?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialChannelCreateInput = {
    id?: string
    key: $Enums.SocialKey
    url?: string | null
    entityId: string
    entityType: $Enums.SocialEntityType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialChannelUncheckedCreateInput = {
    id?: string
    key: $Enums.SocialKey
    url?: string | null
    entityId: string
    entityType: $Enums.SocialEntityType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialChannelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: EnumSocialKeyFieldUpdateOperationsInput | $Enums.SocialKey
    url?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumSocialEntityTypeFieldUpdateOperationsInput | $Enums.SocialEntityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialChannelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: EnumSocialKeyFieldUpdateOperationsInput | $Enums.SocialKey
    url?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumSocialEntityTypeFieldUpdateOperationsInput | $Enums.SocialEntityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialChannelCreateManyInput = {
    id?: string
    key: $Enums.SocialKey
    url?: string | null
    entityId: string
    entityType: $Enums.SocialEntityType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialChannelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: EnumSocialKeyFieldUpdateOperationsInput | $Enums.SocialKey
    url?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumSocialEntityTypeFieldUpdateOperationsInput | $Enums.SocialEntityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialChannelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: EnumSocialKeyFieldUpdateOperationsInput | $Enums.SocialKey
    url?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumSocialEntityTypeFieldUpdateOperationsInput | $Enums.SocialEntityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type LanguageCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    isActive?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LanguageMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    isActive?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LanguageMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    isActive?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SeoNullableScalarRelationFilter = {
    is?: SeoWhereInput | null
    isNot?: SeoWhereInput | null
  }

  export type SettingsCountOrderByAggregateInput = {
    id?: SortOrder
    siteName?: SortOrder
    siteUrl?: SortOrder
    deployWebhookUrl?: SortOrder
    logoUrl?: SortOrder
    scripts?: SortOrder
    seoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    siteName?: SortOrder
    siteUrl?: SortOrder
    deployWebhookUrl?: SortOrder
    logoUrl?: SortOrder
    seoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingsMinOrderByAggregateInput = {
    id?: SortOrder
    siteName?: SortOrder
    siteUrl?: SortOrder
    deployWebhookUrl?: SortOrder
    logoUrl?: SortOrder
    seoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumWidgetSectionFilter<$PrismaModel = never> = {
    equals?: $Enums.WidgetSection | EnumWidgetSectionFieldRefInput<$PrismaModel>
    in?: $Enums.WidgetSection[] | ListEnumWidgetSectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.WidgetSection[] | ListEnumWidgetSectionFieldRefInput<$PrismaModel>
    not?: NestedEnumWidgetSectionFilter<$PrismaModel> | $Enums.WidgetSection
  }

  export type EnumWidgetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WidgetType | EnumWidgetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WidgetType[] | ListEnumWidgetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WidgetType[] | ListEnumWidgetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWidgetTypeFilter<$PrismaModel> | $Enums.WidgetType
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type WidgetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    section?: SortOrder
    type?: SortOrder
    sort?: SortOrder
    isEnabled?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WidgetAvgOrderByAggregateInput = {
    sort?: SortOrder
  }

  export type WidgetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    section?: SortOrder
    type?: SortOrder
    sort?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WidgetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    section?: SortOrder
    type?: SortOrder
    sort?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WidgetSumOrderByAggregateInput = {
    sort?: SortOrder
  }

  export type EnumWidgetSectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WidgetSection | EnumWidgetSectionFieldRefInput<$PrismaModel>
    in?: $Enums.WidgetSection[] | ListEnumWidgetSectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.WidgetSection[] | ListEnumWidgetSectionFieldRefInput<$PrismaModel>
    not?: NestedEnumWidgetSectionWithAggregatesFilter<$PrismaModel> | $Enums.WidgetSection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWidgetSectionFilter<$PrismaModel>
    _max?: NestedEnumWidgetSectionFilter<$PrismaModel>
  }

  export type EnumWidgetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WidgetType | EnumWidgetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WidgetType[] | ListEnumWidgetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WidgetType[] | ListEnumWidgetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWidgetTypeWithAggregatesFilter<$PrismaModel> | $Enums.WidgetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWidgetTypeFilter<$PrismaModel>
    _max?: NestedEnumWidgetTypeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type MediaNullableScalarRelationFilter = {
    is?: MediaWhereInput | null
    isNot?: MediaWhereInput | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type PostAuthorListRelationFilter = {
    every?: PostAuthorWhereInput
    some?: PostAuthorWhereInput
    none?: PostAuthorWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostAuthorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    profileImageId?: SortOrder
    bio?: SortOrder
    imageUrl?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    profileImageId?: SortOrder
    bio?: SortOrder
    imageUrl?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    profileImageId?: SortOrder
    bio?: SortOrder
    imageUrl?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    scope?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    scope?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    scope?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type VerificationTokenEmailTokenCompoundUniqueInput = {
    email: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenEmailTokenCompoundUniqueInput = {
    email: string
    token: string
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type SeoListRelationFilter = {
    every?: SeoWhereInput
    some?: SeoWhereInput
    none?: SeoWhereInput
  }

  export type ImpressionNullableScalarRelationFilter = {
    is?: ImpressionWhereInput | null
    isNot?: ImpressionWhereInput | null
  }

  export type ProductGalleryListRelationFilter = {
    every?: ProductGalleryWhereInput
    some?: ProductGalleryWhereInput
    none?: ProductGalleryWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type SeoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductGalleryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    url?: SortOrder
    size?: SortOrder
    type?: SortOrder
    altText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    url?: SortOrder
    size?: SortOrder
    type?: SortOrder
    altText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    url?: SortOrder
    size?: SortOrder
    type?: SortOrder
    altText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type SettingsListRelationFilter = {
    every?: SettingsWhereInput
    some?: SettingsWhereInput
    none?: SettingsWhereInput
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type ProductCategoryListRelationFilter = {
    every?: ProductCategoryWhereInput
    some?: ProductCategoryWhereInput
    none?: ProductCategoryWhereInput
  }

  export type SettingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeoCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    canonicalUrl?: SortOrder
    version?: SortOrder
    noIndex?: SortOrder
    noFollow?: SortOrder
    ogTwitterType?: SortOrder
    ogTwitterTitle?: SortOrder
    ogTwitterDescription?: SortOrder
    ogTwitterImageId?: SortOrder
    ogTwitterLocale?: SortOrder
    ogTwitterUrl?: SortOrder
    rootId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeoAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type SeoMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    canonicalUrl?: SortOrder
    version?: SortOrder
    noIndex?: SortOrder
    noFollow?: SortOrder
    ogTwitterType?: SortOrder
    ogTwitterTitle?: SortOrder
    ogTwitterDescription?: SortOrder
    ogTwitterImageId?: SortOrder
    ogTwitterLocale?: SortOrder
    ogTwitterUrl?: SortOrder
    rootId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeoMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    canonicalUrl?: SortOrder
    version?: SortOrder
    noIndex?: SortOrder
    noFollow?: SortOrder
    ogTwitterType?: SortOrder
    ogTwitterTitle?: SortOrder
    ogTwitterDescription?: SortOrder
    ogTwitterImageId?: SortOrder
    ogTwitterLocale?: SortOrder
    ogTwitterUrl?: SortOrder
    rootId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeoSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumContentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContentStatusFilter<$PrismaModel> | $Enums.ContentStatus
  }

  export type EnumEditorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EditorType | EnumEditorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EditorType[] | ListEnumEditorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EditorType[] | ListEnumEditorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEditorTypeFilter<$PrismaModel> | $Enums.EditorType
  }

  export type PostNullableScalarRelationFilter = {
    is?: PostWhereInput | null
    isNot?: PostWhereInput | null
  }

  export type PostCategoryListRelationFilter = {
    every?: PostCategoryWhereInput
    some?: PostCategoryWhereInput
    none?: PostCategoryWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PostCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    editorType?: SortOrder
    bodyData?: SortOrder
    tiptapBodyData?: SortOrder
    rootId?: SortOrder
    imageCoverId?: SortOrder
    seoId?: SortOrder
    userId?: SortOrder
    firstPublishedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    editorType?: SortOrder
    rootId?: SortOrder
    imageCoverId?: SortOrder
    seoId?: SortOrder
    userId?: SortOrder
    firstPublishedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    editorType?: SortOrder
    rootId?: SortOrder
    imageCoverId?: SortOrder
    seoId?: SortOrder
    userId?: SortOrder
    firstPublishedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumContentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentStatusFilter<$PrismaModel>
    _max?: NestedEnumContentStatusFilter<$PrismaModel>
  }

  export type EnumEditorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EditorType | EnumEditorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EditorType[] | ListEnumEditorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EditorType[] | ListEnumEditorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEditorTypeWithAggregatesFilter<$PrismaModel> | $Enums.EditorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEditorTypeFilter<$PrismaModel>
    _max?: NestedEnumEditorTypeFilter<$PrismaModel>
  }

  export type PostScalarRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type PostAuthorPostIdUserIdCompoundUniqueInput = {
    postId: string
    userId: string
  }

  export type PostAuthorCountOrderByAggregateInput = {
    postId?: SortOrder
    userId?: SortOrder
    sort?: SortOrder
  }

  export type PostAuthorAvgOrderByAggregateInput = {
    sort?: SortOrder
  }

  export type PostAuthorMaxOrderByAggregateInput = {
    postId?: SortOrder
    userId?: SortOrder
    sort?: SortOrder
  }

  export type PostAuthorMinOrderByAggregateInput = {
    postId?: SortOrder
    userId?: SortOrder
    sort?: SortOrder
  }

  export type PostAuthorSumOrderByAggregateInput = {
    sort?: SortOrder
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    rootId?: SortOrder
    seoId?: SortOrder
    firstPublishedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    rootId?: SortOrder
    seoId?: SortOrder
    firstPublishedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    rootId?: SortOrder
    seoId?: SortOrder
    firstPublishedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type PostCategoryPostIdCategoryIdCompoundUniqueInput = {
    postId: string
    categoryId: string
  }

  export type PostCategoryCountOrderByAggregateInput = {
    postId?: SortOrder
    categoryId?: SortOrder
    sort?: SortOrder
  }

  export type PostCategoryAvgOrderByAggregateInput = {
    sort?: SortOrder
  }

  export type PostCategoryMaxOrderByAggregateInput = {
    postId?: SortOrder
    categoryId?: SortOrder
    sort?: SortOrder
  }

  export type PostCategoryMinOrderByAggregateInput = {
    postId?: SortOrder
    categoryId?: SortOrder
    sort?: SortOrder
  }

  export type PostCategorySumOrderByAggregateInput = {
    sort?: SortOrder
  }

  export type TagNullableScalarRelationFilter = {
    is?: TagWhereInput | null
    isNot?: TagWhereInput | null
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    rootId?: SortOrder
    seoId?: SortOrder
    firstPublishedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    rootId?: SortOrder
    seoId?: SortOrder
    firstPublishedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    rootId?: SortOrder
    seoId?: SortOrder
    firstPublishedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumEmailProviderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailProvider | EnumEmailProviderFieldRefInput<$PrismaModel> | null
    in?: $Enums.EmailProvider[] | ListEnumEmailProviderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EmailProvider[] | ListEnumEmailProviderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEmailProviderNullableFilter<$PrismaModel> | $Enums.EmailProvider | null
  }

  export type EmailTemplateNullableScalarRelationFilter = {
    is?: EmailTemplateWhereInput | null
    isNot?: EmailTemplateWhereInput | null
  }

  export type EmailSettingCountOrderByAggregateInput = {
    id?: SortOrder
    emailSender?: SortOrder
    emailSenderName?: SortOrder
    emailResponse?: SortOrder
    emailProvider?: SortOrder
    emailApiKey?: SortOrder
    maxEmailsPerDay?: SortOrder
    subscriptionTemplateId?: SortOrder
    freeEbookTemplateId?: SortOrder
    webinarTemplateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailSettingAvgOrderByAggregateInput = {
    maxEmailsPerDay?: SortOrder
  }

  export type EmailSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    emailSender?: SortOrder
    emailSenderName?: SortOrder
    emailResponse?: SortOrder
    emailProvider?: SortOrder
    emailApiKey?: SortOrder
    maxEmailsPerDay?: SortOrder
    subscriptionTemplateId?: SortOrder
    freeEbookTemplateId?: SortOrder
    webinarTemplateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailSettingMinOrderByAggregateInput = {
    id?: SortOrder
    emailSender?: SortOrder
    emailSenderName?: SortOrder
    emailResponse?: SortOrder
    emailProvider?: SortOrder
    emailApiKey?: SortOrder
    maxEmailsPerDay?: SortOrder
    subscriptionTemplateId?: SortOrder
    freeEbookTemplateId?: SortOrder
    webinarTemplateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailSettingSumOrderByAggregateInput = {
    maxEmailsPerDay?: SortOrder
  }

  export type EnumEmailProviderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailProvider | EnumEmailProviderFieldRefInput<$PrismaModel> | null
    in?: $Enums.EmailProvider[] | ListEnumEmailProviderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EmailProvider[] | ListEnumEmailProviderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEmailProviderNullableWithAggregatesFilter<$PrismaModel> | $Enums.EmailProvider | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEmailProviderNullableFilter<$PrismaModel>
    _max?: NestedEnumEmailProviderNullableFilter<$PrismaModel>
  }

  export type EmailSettingListRelationFilter = {
    every?: EmailSettingWhereInput
    some?: EmailSettingWhereInput
    none?: EmailSettingWhereInput
  }

  export type EmailSettingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    designData?: SortOrder
    bodyHtml?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    bodyHtml?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    bodyHtml?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAudienceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AudienceType | EnumAudienceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AudienceType[] | ListEnumAudienceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AudienceType[] | ListEnumAudienceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAudienceTypeFilter<$PrismaModel> | $Enums.AudienceType
  }

  export type EmailContactListRelationFilter = {
    every?: EmailContactWhereInput
    some?: EmailContactWhereInput
    none?: EmailContactWhereInput
  }

  export type EmailSingleSendListRelationFilter = {
    every?: EmailSingleSendWhereInput
    some?: EmailSingleSendWhereInput
    none?: EmailSingleSendWhereInput
  }

  export type EmailContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailSingleSendOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailAudienceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailAudienceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailAudienceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAudienceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AudienceType | EnumAudienceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AudienceType[] | ListEnumAudienceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AudienceType[] | ListEnumAudienceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAudienceTypeWithAggregatesFilter<$PrismaModel> | $Enums.AudienceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAudienceTypeFilter<$PrismaModel>
    _max?: NestedEnumAudienceTypeFilter<$PrismaModel>
  }

  export type EmailAudienceListRelationFilter = {
    every?: EmailAudienceWhereInput
    some?: EmailAudienceWhereInput
    none?: EmailAudienceWhereInput
  }

  export type EmailContactInteractionListRelationFilter = {
    every?: EmailContactInteractionWhereInput
    some?: EmailContactInteractionWhereInput
    none?: EmailContactInteractionWhereInput
  }

  export type EmailSingleSendLogListRelationFilter = {
    every?: EmailSingleSendLogWhereInput
    some?: EmailSingleSendLogWhereInput
    none?: EmailSingleSendLogWhereInput
  }

  export type EmailAudienceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailContactInteractionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailSingleSendLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailContactCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    isSubscriber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailContactMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    isSubscriber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailContactMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    isSubscriber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailContactScalarRelationFilter = {
    is?: EmailContactWhereInput
    isNot?: EmailContactWhereInput
  }

  export type EmailContactInteractionContactIdInteractionTypeCompoundUniqueInput = {
    contactId: string
    interactionType: string
  }

  export type EmailContactInteractionCountOrderByAggregateInput = {
    id?: SortOrder
    interactionType?: SortOrder
    interactionDate?: SortOrder
    contactId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailContactInteractionMaxOrderByAggregateInput = {
    id?: SortOrder
    interactionType?: SortOrder
    interactionDate?: SortOrder
    contactId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailContactInteractionMinOrderByAggregateInput = {
    id?: SortOrder
    interactionType?: SortOrder
    interactionDate?: SortOrder
    contactId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailSingleSendCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    designData?: SortOrder
    bodyHtml?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailSingleSendMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    bodyHtml?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailSingleSendMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    bodyHtml?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailSubscriptionTokenEmailTokenCompoundUniqueInput = {
    email: string
    token: string
  }

  export type EmailSubscriptionTokenCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailSubscriptionTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailSubscriptionTokenMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailSendLogCountOrderByAggregateInput = {
    id?: SortOrder
    to?: SortOrder
    from?: SortOrder
    subject?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailSendLogMaxOrderByAggregateInput = {
    id?: SortOrder
    to?: SortOrder
    from?: SortOrder
    subject?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailSendLogMinOrderByAggregateInput = {
    id?: SortOrder
    to?: SortOrder
    from?: SortOrder
    subject?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailSingleSendScalarRelationFilter = {
    is?: EmailSingleSendWhereInput
    isNot?: EmailSingleSendWhereInput
  }

  export type EmailSingleSendLogContactIdSingleSendIdCompoundUniqueInput = {
    contactId: string
    singleSendId: string
  }

  export type EmailSingleSendLogCountOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
    singleSendId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailSingleSendLogMaxOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
    singleSendId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailSingleSendLogMinOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
    singleSendId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type EnumProductAcquisitionModeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductAcquisitionMode | EnumProductAcquisitionModeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductAcquisitionMode[] | ListEnumProductAcquisitionModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductAcquisitionMode[] | ListEnumProductAcquisitionModeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductAcquisitionModeFilter<$PrismaModel> | $Enums.ProductAcquisitionMode
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ProductCategoryNullableScalarRelationFilter = {
    is?: ProductCategoryWhereInput | null
    isNot?: ProductCategoryWhereInput | null
  }

  export type ProductExtraListRelationFilter = {
    every?: ProductExtraWhereInput
    some?: ProductExtraWhereInput
    none?: ProductExtraWhereInput
  }

  export type FormNullableScalarRelationFilter = {
    is?: FormWhereInput | null
    isNot?: FormWhereInput | null
  }

  export type ProductNullableScalarRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type ProductFAQListRelationFilter = {
    every?: ProductFAQWhereInput
    some?: ProductFAQWhereInput
    none?: ProductFAQWhereInput
  }

  export type PurchaseListRelationFilter = {
    every?: PurchaseWhereInput
    some?: PurchaseWhereInput
    none?: PurchaseWhereInput
  }

  export type ProductExtraOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductFAQOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    tiptapDescription?: SortOrder
    type?: SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    imageCoverId?: SortOrder
    categoryId?: SortOrder
    acquisitionMode?: SortOrder
    price?: SortOrder
    discountedPrice?: SortOrder
    isFree?: SortOrder
    metadata?: SortOrder
    formId?: SortOrder
    rootId?: SortOrder
    seoId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    version?: SortOrder
    price?: SortOrder
    discountedPrice?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    type?: SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    imageCoverId?: SortOrder
    categoryId?: SortOrder
    acquisitionMode?: SortOrder
    price?: SortOrder
    discountedPrice?: SortOrder
    isFree?: SortOrder
    formId?: SortOrder
    rootId?: SortOrder
    seoId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    type?: SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    imageCoverId?: SortOrder
    categoryId?: SortOrder
    acquisitionMode?: SortOrder
    price?: SortOrder
    discountedPrice?: SortOrder
    isFree?: SortOrder
    formId?: SortOrder
    rootId?: SortOrder
    seoId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    version?: SortOrder
    price?: SortOrder
    discountedPrice?: SortOrder
  }

  export type EnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type EnumProductAcquisitionModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductAcquisitionMode | EnumProductAcquisitionModeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductAcquisitionMode[] | ListEnumProductAcquisitionModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductAcquisitionMode[] | ListEnumProductAcquisitionModeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductAcquisitionModeWithAggregatesFilter<$PrismaModel> | $Enums.ProductAcquisitionMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductAcquisitionModeFilter<$PrismaModel>
    _max?: NestedEnumProductAcquisitionModeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ProductCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    rootId?: SortOrder
    seoId?: SortOrder
    firstPublishedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategoryAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type ProductCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    rootId?: SortOrder
    seoId?: SortOrder
    firstPublishedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    version?: SortOrder
    status?: SortOrder
    isLatest?: SortOrder
    rootId?: SortOrder
    seoId?: SortOrder
    firstPublishedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategorySumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type MediaScalarRelationFilter = {
    is?: MediaWhereInput
    isNot?: MediaWhereInput
  }

  export type ProductGalleryProductIdMediaIdCompoundUniqueInput = {
    productId: string
    mediaId: string
  }

  export type ProductGalleryCountOrderByAggregateInput = {
    id?: SortOrder
    sort?: SortOrder
    productId?: SortOrder
    mediaId?: SortOrder
  }

  export type ProductGalleryAvgOrderByAggregateInput = {
    sort?: SortOrder
  }

  export type ProductGalleryMaxOrderByAggregateInput = {
    id?: SortOrder
    sort?: SortOrder
    productId?: SortOrder
    mediaId?: SortOrder
  }

  export type ProductGalleryMinOrderByAggregateInput = {
    id?: SortOrder
    sort?: SortOrder
    productId?: SortOrder
    mediaId?: SortOrder
  }

  export type ProductGallerySumOrderByAggregateInput = {
    sort?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ProductExtraCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductExtraAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ProductExtraMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductExtraMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductExtraSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ProductFAQCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    sort?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductFAQAvgOrderByAggregateInput = {
    sort?: SortOrder
  }

  export type ProductFAQMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    sort?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductFAQMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    sort?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductFAQSumOrderByAggregateInput = {
    sort?: SortOrder
  }

  export type AdBlockListRelationFilter = {
    every?: AdBlockWhereInput
    some?: AdBlockWhereInput
    none?: AdBlockWhereInput
  }

  export type AdBlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdCampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdCampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdCampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAdLayoutTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdLayoutType | EnumAdLayoutTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdLayoutType[] | ListEnumAdLayoutTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdLayoutType[] | ListEnumAdLayoutTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdLayoutTypeFilter<$PrismaModel> | $Enums.AdLayoutType
  }

  export type EnumAdPositionPlacementFilter<$PrismaModel = never> = {
    equals?: $Enums.AdPositionPlacement | EnumAdPositionPlacementFieldRefInput<$PrismaModel>
    in?: $Enums.AdPositionPlacement[] | ListEnumAdPositionPlacementFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdPositionPlacement[] | ListEnumAdPositionPlacementFieldRefInput<$PrismaModel>
    not?: NestedEnumAdPositionPlacementFilter<$PrismaModel> | $Enums.AdPositionPlacement
  }

  export type EnumAdPositionReferenceFilter<$PrismaModel = never> = {
    equals?: $Enums.AdPositionReference | EnumAdPositionReferenceFieldRefInput<$PrismaModel>
    in?: $Enums.AdPositionReference[] | ListEnumAdPositionReferenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdPositionReference[] | ListEnumAdPositionReferenceFieldRefInput<$PrismaModel>
    not?: NestedEnumAdPositionReferenceFilter<$PrismaModel> | $Enums.AdPositionReference
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AdCampaignScalarRelationFilter = {
    is?: AdCampaignWhereInput
    isNot?: AdCampaignWhereInput
  }

  export type AdItemListRelationFilter = {
    every?: AdItemWhereInput
    some?: AdItemWhereInput
    none?: AdItemWhereInput
  }

  export type AdItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdBlockCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    layoutType?: SortOrder
    isActive?: SortOrder
    campaignId?: SortOrder
    placement?: SortOrder
    reference?: SortOrder
    referenceCount?: SortOrder
    minWords?: SortOrder
    excludedPostIds?: SortOrder
    excludedCategoryIds?: SortOrder
    excludedTagIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdBlockAvgOrderByAggregateInput = {
    referenceCount?: SortOrder
    minWords?: SortOrder
  }

  export type AdBlockMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    layoutType?: SortOrder
    isActive?: SortOrder
    campaignId?: SortOrder
    placement?: SortOrder
    reference?: SortOrder
    referenceCount?: SortOrder
    minWords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdBlockMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    layoutType?: SortOrder
    isActive?: SortOrder
    campaignId?: SortOrder
    placement?: SortOrder
    reference?: SortOrder
    referenceCount?: SortOrder
    minWords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdBlockSumOrderByAggregateInput = {
    referenceCount?: SortOrder
    minWords?: SortOrder
  }

  export type EnumAdLayoutTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdLayoutType | EnumAdLayoutTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdLayoutType[] | ListEnumAdLayoutTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdLayoutType[] | ListEnumAdLayoutTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdLayoutTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdLayoutType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdLayoutTypeFilter<$PrismaModel>
    _max?: NestedEnumAdLayoutTypeFilter<$PrismaModel>
  }

  export type EnumAdPositionPlacementWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdPositionPlacement | EnumAdPositionPlacementFieldRefInput<$PrismaModel>
    in?: $Enums.AdPositionPlacement[] | ListEnumAdPositionPlacementFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdPositionPlacement[] | ListEnumAdPositionPlacementFieldRefInput<$PrismaModel>
    not?: NestedEnumAdPositionPlacementWithAggregatesFilter<$PrismaModel> | $Enums.AdPositionPlacement
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdPositionPlacementFilter<$PrismaModel>
    _max?: NestedEnumAdPositionPlacementFilter<$PrismaModel>
  }

  export type EnumAdPositionReferenceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdPositionReference | EnumAdPositionReferenceFieldRefInput<$PrismaModel>
    in?: $Enums.AdPositionReference[] | ListEnumAdPositionReferenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdPositionReference[] | ListEnumAdPositionReferenceFieldRefInput<$PrismaModel>
    not?: NestedEnumAdPositionReferenceWithAggregatesFilter<$PrismaModel> | $Enums.AdPositionReference
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdPositionReferenceFilter<$PrismaModel>
    _max?: NestedEnumAdPositionReferenceFilter<$PrismaModel>
  }

  export type EnumAdItemSourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdItemSourceType | EnumAdItemSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdItemSourceType[] | ListEnumAdItemSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdItemSourceType[] | ListEnumAdItemSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdItemSourceTypeFilter<$PrismaModel> | $Enums.AdItemSourceType
  }

  export type AdBlockScalarRelationFilter = {
    is?: AdBlockWhereInput
    isNot?: AdBlockWhereInput
  }

  export type AdItemCountOrderByAggregateInput = {
    id?: SortOrder
    sourceType?: SortOrder
    adBlockId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    url?: SortOrder
    postRootId?: SortOrder
    productRootId?: SortOrder
    sort?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdItemAvgOrderByAggregateInput = {
    sort?: SortOrder
  }

  export type AdItemMaxOrderByAggregateInput = {
    id?: SortOrder
    sourceType?: SortOrder
    adBlockId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    url?: SortOrder
    postRootId?: SortOrder
    productRootId?: SortOrder
    sort?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdItemMinOrderByAggregateInput = {
    id?: SortOrder
    sourceType?: SortOrder
    adBlockId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    url?: SortOrder
    postRootId?: SortOrder
    productRootId?: SortOrder
    sort?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdItemSumOrderByAggregateInput = {
    sort?: SortOrder
  }

  export type EnumAdItemSourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdItemSourceType | EnumAdItemSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdItemSourceType[] | ListEnumAdItemSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdItemSourceType[] | ListEnumAdItemSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdItemSourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdItemSourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdItemSourceTypeFilter<$PrismaModel>
    _max?: NestedEnumAdItemSourceTypeFilter<$PrismaModel>
  }

  export type PurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    productId?: SortOrder
    productRootId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    productId?: SortOrder
    productRootId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    productId?: SortOrder
    productRootId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactFormCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactFormMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactFormMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormSubmissionListRelationFilter = {
    every?: FormSubmissionWhereInput
    some?: FormSubmissionWhereInput
    none?: FormSubmissionWhereInput
  }

  export type FormSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fields?: SortOrder
    submitLabel?: SortOrder
    gtmEventName?: SortOrder
    gtmCategory?: SortOrder
    gtmLabel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    submitLabel?: SortOrder
    gtmEventName?: SortOrder
    gtmCategory?: SortOrder
    gtmLabel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    submitLabel?: SortOrder
    gtmEventName?: SortOrder
    gtmCategory?: SortOrder
    gtmLabel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormScalarRelationFilter = {
    is?: FormWhereInput
    isNot?: FormWhereInput
  }

  export type FormSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    email?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImpressionListRelationFilter = {
    every?: ImpressionWhereInput
    some?: ImpressionWhereInput
    none?: ImpressionWhereInput
  }

  export type ImpressionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormatCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormatMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormatMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GenreCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GenreMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GenreMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormatNullableScalarRelationFilter = {
    is?: FormatWhereInput | null
    isNot?: FormatWhereInput | null
  }

  export type GenreNullableScalarRelationFilter = {
    is?: GenreWhereInput | null
    isNot?: GenreWhereInput | null
  }

  export type ImpressionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    pageCount?: SortOrder
    formatId?: SortOrder
    genreId?: SortOrder
    fileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImpressionAvgOrderByAggregateInput = {
    pageCount?: SortOrder
  }

  export type ImpressionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    pageCount?: SortOrder
    formatId?: SortOrder
    genreId?: SortOrder
    fileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImpressionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    pageCount?: SortOrder
    formatId?: SortOrder
    genreId?: SortOrder
    fileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImpressionSumOrderByAggregateInput = {
    pageCount?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSocialKeyFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialKey | EnumSocialKeyFieldRefInput<$PrismaModel>
    in?: $Enums.SocialKey[] | ListEnumSocialKeyFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialKey[] | ListEnumSocialKeyFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialKeyFilter<$PrismaModel> | $Enums.SocialKey
  }

  export type EnumSocialEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialEntityType | EnumSocialEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SocialEntityType[] | ListEnumSocialEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialEntityType[] | ListEnumSocialEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialEntityTypeFilter<$PrismaModel> | $Enums.SocialEntityType
  }

  export type SocialChannelKeyEntityIdEntityTypeCompoundUniqueInput = {
    key: $Enums.SocialKey
    entityId: string
    entityType: $Enums.SocialEntityType
  }

  export type SocialChannelCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    url?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    url?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialChannelMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    url?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSocialKeyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialKey | EnumSocialKeyFieldRefInput<$PrismaModel>
    in?: $Enums.SocialKey[] | ListEnumSocialKeyFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialKey[] | ListEnumSocialKeyFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialKeyWithAggregatesFilter<$PrismaModel> | $Enums.SocialKey
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSocialKeyFilter<$PrismaModel>
    _max?: NestedEnumSocialKeyFilter<$PrismaModel>
  }

  export type EnumSocialEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialEntityType | EnumSocialEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SocialEntityType[] | ListEnumSocialEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialEntityType[] | ListEnumSocialEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.SocialEntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSocialEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumSocialEntityTypeFilter<$PrismaModel>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SeoCreateNestedOneWithoutSettingsInput = {
    create?: XOR<SeoCreateWithoutSettingsInput, SeoUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: SeoCreateOrConnectWithoutSettingsInput
    connect?: SeoWhereUniqueInput
  }

  export type SeoUpdateOneWithoutSettingsNestedInput = {
    create?: XOR<SeoCreateWithoutSettingsInput, SeoUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: SeoCreateOrConnectWithoutSettingsInput
    upsert?: SeoUpsertWithoutSettingsInput
    disconnect?: SeoWhereInput | boolean
    delete?: SeoWhereInput | boolean
    connect?: SeoWhereUniqueInput
    update?: XOR<XOR<SeoUpdateToOneWithWhereWithoutSettingsInput, SeoUpdateWithoutSettingsInput>, SeoUncheckedUpdateWithoutSettingsInput>
  }

  export type EnumWidgetSectionFieldUpdateOperationsInput = {
    set?: $Enums.WidgetSection
  }

  export type EnumWidgetTypeFieldUpdateOperationsInput = {
    set?: $Enums.WidgetType
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type MediaCreateNestedOneWithoutUserInput = {
    create?: XOR<MediaCreateWithoutUserInput, MediaUncheckedCreateWithoutUserInput>
    connectOrCreate?: MediaCreateOrConnectWithoutUserInput
    connect?: MediaWhereUniqueInput
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutUserInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PostAuthorCreateNestedManyWithoutUserInput = {
    create?: XOR<PostAuthorCreateWithoutUserInput, PostAuthorUncheckedCreateWithoutUserInput> | PostAuthorCreateWithoutUserInput[] | PostAuthorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostAuthorCreateOrConnectWithoutUserInput | PostAuthorCreateOrConnectWithoutUserInput[]
    createMany?: PostAuthorCreateManyUserInputEnvelope
    connect?: PostAuthorWhereUniqueInput | PostAuthorWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput> | ProductCreateWithoutUserInput[] | ProductUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUserInput | ProductCreateOrConnectWithoutUserInput[]
    createMany?: ProductCreateManyUserInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PostAuthorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PostAuthorCreateWithoutUserInput, PostAuthorUncheckedCreateWithoutUserInput> | PostAuthorCreateWithoutUserInput[] | PostAuthorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostAuthorCreateOrConnectWithoutUserInput | PostAuthorCreateOrConnectWithoutUserInput[]
    createMany?: PostAuthorCreateManyUserInputEnvelope
    connect?: PostAuthorWhereUniqueInput | PostAuthorWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput> | ProductCreateWithoutUserInput[] | ProductUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUserInput | ProductCreateOrConnectWithoutUserInput[]
    createMany?: ProductCreateManyUserInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type MediaUpdateOneWithoutUserNestedInput = {
    create?: XOR<MediaCreateWithoutUserInput, MediaUncheckedCreateWithoutUserInput>
    connectOrCreate?: MediaCreateOrConnectWithoutUserInput
    upsert?: MediaUpsertWithoutUserInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutUserInput, MediaUpdateWithoutUserInput>, MediaUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type PostUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutUserInput | PostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutUserInput | PostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostUpdateManyWithWhereWithoutUserInput | PostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type PostAuthorUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostAuthorCreateWithoutUserInput, PostAuthorUncheckedCreateWithoutUserInput> | PostAuthorCreateWithoutUserInput[] | PostAuthorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostAuthorCreateOrConnectWithoutUserInput | PostAuthorCreateOrConnectWithoutUserInput[]
    upsert?: PostAuthorUpsertWithWhereUniqueWithoutUserInput | PostAuthorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostAuthorCreateManyUserInputEnvelope
    set?: PostAuthorWhereUniqueInput | PostAuthorWhereUniqueInput[]
    disconnect?: PostAuthorWhereUniqueInput | PostAuthorWhereUniqueInput[]
    delete?: PostAuthorWhereUniqueInput | PostAuthorWhereUniqueInput[]
    connect?: PostAuthorWhereUniqueInput | PostAuthorWhereUniqueInput[]
    update?: PostAuthorUpdateWithWhereUniqueWithoutUserInput | PostAuthorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostAuthorUpdateManyWithWhereWithoutUserInput | PostAuthorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostAuthorScalarWhereInput | PostAuthorScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput> | ProductCreateWithoutUserInput[] | ProductUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUserInput | ProductCreateOrConnectWithoutUserInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUserInput | ProductUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductCreateManyUserInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUserInput | ProductUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUserInput | ProductUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutUserInput | PostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutUserInput | PostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostUpdateManyWithWhereWithoutUserInput | PostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type PostAuthorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostAuthorCreateWithoutUserInput, PostAuthorUncheckedCreateWithoutUserInput> | PostAuthorCreateWithoutUserInput[] | PostAuthorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostAuthorCreateOrConnectWithoutUserInput | PostAuthorCreateOrConnectWithoutUserInput[]
    upsert?: PostAuthorUpsertWithWhereUniqueWithoutUserInput | PostAuthorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostAuthorCreateManyUserInputEnvelope
    set?: PostAuthorWhereUniqueInput | PostAuthorWhereUniqueInput[]
    disconnect?: PostAuthorWhereUniqueInput | PostAuthorWhereUniqueInput[]
    delete?: PostAuthorWhereUniqueInput | PostAuthorWhereUniqueInput[]
    connect?: PostAuthorWhereUniqueInput | PostAuthorWhereUniqueInput[]
    update?: PostAuthorUpdateWithWhereUniqueWithoutUserInput | PostAuthorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostAuthorUpdateManyWithWhereWithoutUserInput | PostAuthorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostAuthorScalarWhereInput | PostAuthorScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput> | ProductCreateWithoutUserInput[] | ProductUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUserInput | ProductCreateOrConnectWithoutUserInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUserInput | ProductUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductCreateManyUserInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUserInput | ProductUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUserInput | ProductUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type PostCreateNestedManyWithoutImageCoverInput = {
    create?: XOR<PostCreateWithoutImageCoverInput, PostUncheckedCreateWithoutImageCoverInput> | PostCreateWithoutImageCoverInput[] | PostUncheckedCreateWithoutImageCoverInput[]
    connectOrCreate?: PostCreateOrConnectWithoutImageCoverInput | PostCreateOrConnectWithoutImageCoverInput[]
    createMany?: PostCreateManyImageCoverInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type SeoCreateNestedManyWithoutOgTwitterImageInput = {
    create?: XOR<SeoCreateWithoutOgTwitterImageInput, SeoUncheckedCreateWithoutOgTwitterImageInput> | SeoCreateWithoutOgTwitterImageInput[] | SeoUncheckedCreateWithoutOgTwitterImageInput[]
    connectOrCreate?: SeoCreateOrConnectWithoutOgTwitterImageInput | SeoCreateOrConnectWithoutOgTwitterImageInput[]
    createMany?: SeoCreateManyOgTwitterImageInputEnvelope
    connect?: SeoWhereUniqueInput | SeoWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutImageCoverInput = {
    create?: XOR<ProductCreateWithoutImageCoverInput, ProductUncheckedCreateWithoutImageCoverInput> | ProductCreateWithoutImageCoverInput[] | ProductUncheckedCreateWithoutImageCoverInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutImageCoverInput | ProductCreateOrConnectWithoutImageCoverInput[]
    createMany?: ProductCreateManyImageCoverInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ImpressionCreateNestedOneWithoutFileInput = {
    create?: XOR<ImpressionCreateWithoutFileInput, ImpressionUncheckedCreateWithoutFileInput>
    connectOrCreate?: ImpressionCreateOrConnectWithoutFileInput
    connect?: ImpressionWhereUniqueInput
  }

  export type ProductGalleryCreateNestedManyWithoutMediaInput = {
    create?: XOR<ProductGalleryCreateWithoutMediaInput, ProductGalleryUncheckedCreateWithoutMediaInput> | ProductGalleryCreateWithoutMediaInput[] | ProductGalleryUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: ProductGalleryCreateOrConnectWithoutMediaInput | ProductGalleryCreateOrConnectWithoutMediaInput[]
    createMany?: ProductGalleryCreateManyMediaInputEnvelope
    connect?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutProfileImageInput = {
    create?: XOR<UserCreateWithoutProfileImageInput, UserUncheckedCreateWithoutProfileImageInput> | UserCreateWithoutProfileImageInput[] | UserUncheckedCreateWithoutProfileImageInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProfileImageInput | UserCreateOrConnectWithoutProfileImageInput[]
    createMany?: UserCreateManyProfileImageInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutImageCoverInput = {
    create?: XOR<PostCreateWithoutImageCoverInput, PostUncheckedCreateWithoutImageCoverInput> | PostCreateWithoutImageCoverInput[] | PostUncheckedCreateWithoutImageCoverInput[]
    connectOrCreate?: PostCreateOrConnectWithoutImageCoverInput | PostCreateOrConnectWithoutImageCoverInput[]
    createMany?: PostCreateManyImageCoverInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type SeoUncheckedCreateNestedManyWithoutOgTwitterImageInput = {
    create?: XOR<SeoCreateWithoutOgTwitterImageInput, SeoUncheckedCreateWithoutOgTwitterImageInput> | SeoCreateWithoutOgTwitterImageInput[] | SeoUncheckedCreateWithoutOgTwitterImageInput[]
    connectOrCreate?: SeoCreateOrConnectWithoutOgTwitterImageInput | SeoCreateOrConnectWithoutOgTwitterImageInput[]
    createMany?: SeoCreateManyOgTwitterImageInputEnvelope
    connect?: SeoWhereUniqueInput | SeoWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutImageCoverInput = {
    create?: XOR<ProductCreateWithoutImageCoverInput, ProductUncheckedCreateWithoutImageCoverInput> | ProductCreateWithoutImageCoverInput[] | ProductUncheckedCreateWithoutImageCoverInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutImageCoverInput | ProductCreateOrConnectWithoutImageCoverInput[]
    createMany?: ProductCreateManyImageCoverInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ImpressionUncheckedCreateNestedOneWithoutFileInput = {
    create?: XOR<ImpressionCreateWithoutFileInput, ImpressionUncheckedCreateWithoutFileInput>
    connectOrCreate?: ImpressionCreateOrConnectWithoutFileInput
    connect?: ImpressionWhereUniqueInput
  }

  export type ProductGalleryUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<ProductGalleryCreateWithoutMediaInput, ProductGalleryUncheckedCreateWithoutMediaInput> | ProductGalleryCreateWithoutMediaInput[] | ProductGalleryUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: ProductGalleryCreateOrConnectWithoutMediaInput | ProductGalleryCreateOrConnectWithoutMediaInput[]
    createMany?: ProductGalleryCreateManyMediaInputEnvelope
    connect?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutProfileImageInput = {
    create?: XOR<UserCreateWithoutProfileImageInput, UserUncheckedCreateWithoutProfileImageInput> | UserCreateWithoutProfileImageInput[] | UserUncheckedCreateWithoutProfileImageInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProfileImageInput | UserCreateOrConnectWithoutProfileImageInput[]
    createMany?: UserCreateManyProfileImageInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType
  }

  export type PostUpdateManyWithoutImageCoverNestedInput = {
    create?: XOR<PostCreateWithoutImageCoverInput, PostUncheckedCreateWithoutImageCoverInput> | PostCreateWithoutImageCoverInput[] | PostUncheckedCreateWithoutImageCoverInput[]
    connectOrCreate?: PostCreateOrConnectWithoutImageCoverInput | PostCreateOrConnectWithoutImageCoverInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutImageCoverInput | PostUpsertWithWhereUniqueWithoutImageCoverInput[]
    createMany?: PostCreateManyImageCoverInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutImageCoverInput | PostUpdateWithWhereUniqueWithoutImageCoverInput[]
    updateMany?: PostUpdateManyWithWhereWithoutImageCoverInput | PostUpdateManyWithWhereWithoutImageCoverInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type SeoUpdateManyWithoutOgTwitterImageNestedInput = {
    create?: XOR<SeoCreateWithoutOgTwitterImageInput, SeoUncheckedCreateWithoutOgTwitterImageInput> | SeoCreateWithoutOgTwitterImageInput[] | SeoUncheckedCreateWithoutOgTwitterImageInput[]
    connectOrCreate?: SeoCreateOrConnectWithoutOgTwitterImageInput | SeoCreateOrConnectWithoutOgTwitterImageInput[]
    upsert?: SeoUpsertWithWhereUniqueWithoutOgTwitterImageInput | SeoUpsertWithWhereUniqueWithoutOgTwitterImageInput[]
    createMany?: SeoCreateManyOgTwitterImageInputEnvelope
    set?: SeoWhereUniqueInput | SeoWhereUniqueInput[]
    disconnect?: SeoWhereUniqueInput | SeoWhereUniqueInput[]
    delete?: SeoWhereUniqueInput | SeoWhereUniqueInput[]
    connect?: SeoWhereUniqueInput | SeoWhereUniqueInput[]
    update?: SeoUpdateWithWhereUniqueWithoutOgTwitterImageInput | SeoUpdateWithWhereUniqueWithoutOgTwitterImageInput[]
    updateMany?: SeoUpdateManyWithWhereWithoutOgTwitterImageInput | SeoUpdateManyWithWhereWithoutOgTwitterImageInput[]
    deleteMany?: SeoScalarWhereInput | SeoScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutImageCoverNestedInput = {
    create?: XOR<ProductCreateWithoutImageCoverInput, ProductUncheckedCreateWithoutImageCoverInput> | ProductCreateWithoutImageCoverInput[] | ProductUncheckedCreateWithoutImageCoverInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutImageCoverInput | ProductCreateOrConnectWithoutImageCoverInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutImageCoverInput | ProductUpsertWithWhereUniqueWithoutImageCoverInput[]
    createMany?: ProductCreateManyImageCoverInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutImageCoverInput | ProductUpdateWithWhereUniqueWithoutImageCoverInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutImageCoverInput | ProductUpdateManyWithWhereWithoutImageCoverInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ImpressionUpdateOneWithoutFileNestedInput = {
    create?: XOR<ImpressionCreateWithoutFileInput, ImpressionUncheckedCreateWithoutFileInput>
    connectOrCreate?: ImpressionCreateOrConnectWithoutFileInput
    upsert?: ImpressionUpsertWithoutFileInput
    disconnect?: ImpressionWhereInput | boolean
    delete?: ImpressionWhereInput | boolean
    connect?: ImpressionWhereUniqueInput
    update?: XOR<XOR<ImpressionUpdateToOneWithWhereWithoutFileInput, ImpressionUpdateWithoutFileInput>, ImpressionUncheckedUpdateWithoutFileInput>
  }

  export type ProductGalleryUpdateManyWithoutMediaNestedInput = {
    create?: XOR<ProductGalleryCreateWithoutMediaInput, ProductGalleryUncheckedCreateWithoutMediaInput> | ProductGalleryCreateWithoutMediaInput[] | ProductGalleryUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: ProductGalleryCreateOrConnectWithoutMediaInput | ProductGalleryCreateOrConnectWithoutMediaInput[]
    upsert?: ProductGalleryUpsertWithWhereUniqueWithoutMediaInput | ProductGalleryUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: ProductGalleryCreateManyMediaInputEnvelope
    set?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
    disconnect?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
    delete?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
    connect?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
    update?: ProductGalleryUpdateWithWhereUniqueWithoutMediaInput | ProductGalleryUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: ProductGalleryUpdateManyWithWhereWithoutMediaInput | ProductGalleryUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: ProductGalleryScalarWhereInput | ProductGalleryScalarWhereInput[]
  }

  export type UserUpdateManyWithoutProfileImageNestedInput = {
    create?: XOR<UserCreateWithoutProfileImageInput, UserUncheckedCreateWithoutProfileImageInput> | UserCreateWithoutProfileImageInput[] | UserUncheckedCreateWithoutProfileImageInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProfileImageInput | UserCreateOrConnectWithoutProfileImageInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutProfileImageInput | UserUpsertWithWhereUniqueWithoutProfileImageInput[]
    createMany?: UserCreateManyProfileImageInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutProfileImageInput | UserUpdateWithWhereUniqueWithoutProfileImageInput[]
    updateMany?: UserUpdateManyWithWhereWithoutProfileImageInput | UserUpdateManyWithWhereWithoutProfileImageInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutImageCoverNestedInput = {
    create?: XOR<PostCreateWithoutImageCoverInput, PostUncheckedCreateWithoutImageCoverInput> | PostCreateWithoutImageCoverInput[] | PostUncheckedCreateWithoutImageCoverInput[]
    connectOrCreate?: PostCreateOrConnectWithoutImageCoverInput | PostCreateOrConnectWithoutImageCoverInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutImageCoverInput | PostUpsertWithWhereUniqueWithoutImageCoverInput[]
    createMany?: PostCreateManyImageCoverInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutImageCoverInput | PostUpdateWithWhereUniqueWithoutImageCoverInput[]
    updateMany?: PostUpdateManyWithWhereWithoutImageCoverInput | PostUpdateManyWithWhereWithoutImageCoverInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type SeoUncheckedUpdateManyWithoutOgTwitterImageNestedInput = {
    create?: XOR<SeoCreateWithoutOgTwitterImageInput, SeoUncheckedCreateWithoutOgTwitterImageInput> | SeoCreateWithoutOgTwitterImageInput[] | SeoUncheckedCreateWithoutOgTwitterImageInput[]
    connectOrCreate?: SeoCreateOrConnectWithoutOgTwitterImageInput | SeoCreateOrConnectWithoutOgTwitterImageInput[]
    upsert?: SeoUpsertWithWhereUniqueWithoutOgTwitterImageInput | SeoUpsertWithWhereUniqueWithoutOgTwitterImageInput[]
    createMany?: SeoCreateManyOgTwitterImageInputEnvelope
    set?: SeoWhereUniqueInput | SeoWhereUniqueInput[]
    disconnect?: SeoWhereUniqueInput | SeoWhereUniqueInput[]
    delete?: SeoWhereUniqueInput | SeoWhereUniqueInput[]
    connect?: SeoWhereUniqueInput | SeoWhereUniqueInput[]
    update?: SeoUpdateWithWhereUniqueWithoutOgTwitterImageInput | SeoUpdateWithWhereUniqueWithoutOgTwitterImageInput[]
    updateMany?: SeoUpdateManyWithWhereWithoutOgTwitterImageInput | SeoUpdateManyWithWhereWithoutOgTwitterImageInput[]
    deleteMany?: SeoScalarWhereInput | SeoScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutImageCoverNestedInput = {
    create?: XOR<ProductCreateWithoutImageCoverInput, ProductUncheckedCreateWithoutImageCoverInput> | ProductCreateWithoutImageCoverInput[] | ProductUncheckedCreateWithoutImageCoverInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutImageCoverInput | ProductCreateOrConnectWithoutImageCoverInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutImageCoverInput | ProductUpsertWithWhereUniqueWithoutImageCoverInput[]
    createMany?: ProductCreateManyImageCoverInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutImageCoverInput | ProductUpdateWithWhereUniqueWithoutImageCoverInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutImageCoverInput | ProductUpdateManyWithWhereWithoutImageCoverInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ImpressionUncheckedUpdateOneWithoutFileNestedInput = {
    create?: XOR<ImpressionCreateWithoutFileInput, ImpressionUncheckedCreateWithoutFileInput>
    connectOrCreate?: ImpressionCreateOrConnectWithoutFileInput
    upsert?: ImpressionUpsertWithoutFileInput
    disconnect?: ImpressionWhereInput | boolean
    delete?: ImpressionWhereInput | boolean
    connect?: ImpressionWhereUniqueInput
    update?: XOR<XOR<ImpressionUpdateToOneWithWhereWithoutFileInput, ImpressionUpdateWithoutFileInput>, ImpressionUncheckedUpdateWithoutFileInput>
  }

  export type ProductGalleryUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<ProductGalleryCreateWithoutMediaInput, ProductGalleryUncheckedCreateWithoutMediaInput> | ProductGalleryCreateWithoutMediaInput[] | ProductGalleryUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: ProductGalleryCreateOrConnectWithoutMediaInput | ProductGalleryCreateOrConnectWithoutMediaInput[]
    upsert?: ProductGalleryUpsertWithWhereUniqueWithoutMediaInput | ProductGalleryUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: ProductGalleryCreateManyMediaInputEnvelope
    set?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
    disconnect?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
    delete?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
    connect?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
    update?: ProductGalleryUpdateWithWhereUniqueWithoutMediaInput | ProductGalleryUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: ProductGalleryUpdateManyWithWhereWithoutMediaInput | ProductGalleryUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: ProductGalleryScalarWhereInput | ProductGalleryScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutProfileImageNestedInput = {
    create?: XOR<UserCreateWithoutProfileImageInput, UserUncheckedCreateWithoutProfileImageInput> | UserCreateWithoutProfileImageInput[] | UserUncheckedCreateWithoutProfileImageInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProfileImageInput | UserCreateOrConnectWithoutProfileImageInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutProfileImageInput | UserUpsertWithWhereUniqueWithoutProfileImageInput[]
    createMany?: UserCreateManyProfileImageInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutProfileImageInput | UserUpdateWithWhereUniqueWithoutProfileImageInput[]
    updateMany?: UserUpdateManyWithWhereWithoutProfileImageInput | UserUpdateManyWithWhereWithoutProfileImageInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type MediaCreateNestedOneWithoutSeoInput = {
    create?: XOR<MediaCreateWithoutSeoInput, MediaUncheckedCreateWithoutSeoInput>
    connectOrCreate?: MediaCreateOrConnectWithoutSeoInput
    connect?: MediaWhereUniqueInput
  }

  export type SeoCreateNestedOneWithoutRootChildrenInput = {
    create?: XOR<SeoCreateWithoutRootChildrenInput, SeoUncheckedCreateWithoutRootChildrenInput>
    connectOrCreate?: SeoCreateOrConnectWithoutRootChildrenInput
    connect?: SeoWhereUniqueInput
  }

  export type SeoCreateNestedManyWithoutRootInput = {
    create?: XOR<SeoCreateWithoutRootInput, SeoUncheckedCreateWithoutRootInput> | SeoCreateWithoutRootInput[] | SeoUncheckedCreateWithoutRootInput[]
    connectOrCreate?: SeoCreateOrConnectWithoutRootInput | SeoCreateOrConnectWithoutRootInput[]
    createMany?: SeoCreateManyRootInputEnvelope
    connect?: SeoWhereUniqueInput | SeoWhereUniqueInput[]
  }

  export type SettingsCreateNestedManyWithoutSeoInput = {
    create?: XOR<SettingsCreateWithoutSeoInput, SettingsUncheckedCreateWithoutSeoInput> | SettingsCreateWithoutSeoInput[] | SettingsUncheckedCreateWithoutSeoInput[]
    connectOrCreate?: SettingsCreateOrConnectWithoutSeoInput | SettingsCreateOrConnectWithoutSeoInput[]
    createMany?: SettingsCreateManySeoInputEnvelope
    connect?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutSeoInput = {
    create?: XOR<PostCreateWithoutSeoInput, PostUncheckedCreateWithoutSeoInput> | PostCreateWithoutSeoInput[] | PostUncheckedCreateWithoutSeoInput[]
    connectOrCreate?: PostCreateOrConnectWithoutSeoInput | PostCreateOrConnectWithoutSeoInput[]
    createMany?: PostCreateManySeoInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CategoryCreateNestedManyWithoutSeoInput = {
    create?: XOR<CategoryCreateWithoutSeoInput, CategoryUncheckedCreateWithoutSeoInput> | CategoryCreateWithoutSeoInput[] | CategoryUncheckedCreateWithoutSeoInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutSeoInput | CategoryCreateOrConnectWithoutSeoInput[]
    createMany?: CategoryCreateManySeoInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutSeoInput = {
    create?: XOR<TagCreateWithoutSeoInput, TagUncheckedCreateWithoutSeoInput> | TagCreateWithoutSeoInput[] | TagUncheckedCreateWithoutSeoInput[]
    connectOrCreate?: TagCreateOrConnectWithoutSeoInput | TagCreateOrConnectWithoutSeoInput[]
    createMany?: TagCreateManySeoInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutSeoInput = {
    create?: XOR<ProductCreateWithoutSeoInput, ProductUncheckedCreateWithoutSeoInput> | ProductCreateWithoutSeoInput[] | ProductUncheckedCreateWithoutSeoInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSeoInput | ProductCreateOrConnectWithoutSeoInput[]
    createMany?: ProductCreateManySeoInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductCategoryCreateNestedManyWithoutSeoInput = {
    create?: XOR<ProductCategoryCreateWithoutSeoInput, ProductCategoryUncheckedCreateWithoutSeoInput> | ProductCategoryCreateWithoutSeoInput[] | ProductCategoryUncheckedCreateWithoutSeoInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutSeoInput | ProductCategoryCreateOrConnectWithoutSeoInput[]
    createMany?: ProductCategoryCreateManySeoInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type SeoUncheckedCreateNestedManyWithoutRootInput = {
    create?: XOR<SeoCreateWithoutRootInput, SeoUncheckedCreateWithoutRootInput> | SeoCreateWithoutRootInput[] | SeoUncheckedCreateWithoutRootInput[]
    connectOrCreate?: SeoCreateOrConnectWithoutRootInput | SeoCreateOrConnectWithoutRootInput[]
    createMany?: SeoCreateManyRootInputEnvelope
    connect?: SeoWhereUniqueInput | SeoWhereUniqueInput[]
  }

  export type SettingsUncheckedCreateNestedManyWithoutSeoInput = {
    create?: XOR<SettingsCreateWithoutSeoInput, SettingsUncheckedCreateWithoutSeoInput> | SettingsCreateWithoutSeoInput[] | SettingsUncheckedCreateWithoutSeoInput[]
    connectOrCreate?: SettingsCreateOrConnectWithoutSeoInput | SettingsCreateOrConnectWithoutSeoInput[]
    createMany?: SettingsCreateManySeoInputEnvelope
    connect?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutSeoInput = {
    create?: XOR<PostCreateWithoutSeoInput, PostUncheckedCreateWithoutSeoInput> | PostCreateWithoutSeoInput[] | PostUncheckedCreateWithoutSeoInput[]
    connectOrCreate?: PostCreateOrConnectWithoutSeoInput | PostCreateOrConnectWithoutSeoInput[]
    createMany?: PostCreateManySeoInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutSeoInput = {
    create?: XOR<CategoryCreateWithoutSeoInput, CategoryUncheckedCreateWithoutSeoInput> | CategoryCreateWithoutSeoInput[] | CategoryUncheckedCreateWithoutSeoInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutSeoInput | CategoryCreateOrConnectWithoutSeoInput[]
    createMany?: CategoryCreateManySeoInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutSeoInput = {
    create?: XOR<TagCreateWithoutSeoInput, TagUncheckedCreateWithoutSeoInput> | TagCreateWithoutSeoInput[] | TagUncheckedCreateWithoutSeoInput[]
    connectOrCreate?: TagCreateOrConnectWithoutSeoInput | TagCreateOrConnectWithoutSeoInput[]
    createMany?: TagCreateManySeoInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutSeoInput = {
    create?: XOR<ProductCreateWithoutSeoInput, ProductUncheckedCreateWithoutSeoInput> | ProductCreateWithoutSeoInput[] | ProductUncheckedCreateWithoutSeoInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSeoInput | ProductCreateOrConnectWithoutSeoInput[]
    createMany?: ProductCreateManySeoInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutSeoInput = {
    create?: XOR<ProductCategoryCreateWithoutSeoInput, ProductCategoryUncheckedCreateWithoutSeoInput> | ProductCategoryCreateWithoutSeoInput[] | ProductCategoryUncheckedCreateWithoutSeoInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutSeoInput | ProductCategoryCreateOrConnectWithoutSeoInput[]
    createMany?: ProductCategoryCreateManySeoInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type MediaUpdateOneWithoutSeoNestedInput = {
    create?: XOR<MediaCreateWithoutSeoInput, MediaUncheckedCreateWithoutSeoInput>
    connectOrCreate?: MediaCreateOrConnectWithoutSeoInput
    upsert?: MediaUpsertWithoutSeoInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutSeoInput, MediaUpdateWithoutSeoInput>, MediaUncheckedUpdateWithoutSeoInput>
  }

  export type SeoUpdateOneWithoutRootChildrenNestedInput = {
    create?: XOR<SeoCreateWithoutRootChildrenInput, SeoUncheckedCreateWithoutRootChildrenInput>
    connectOrCreate?: SeoCreateOrConnectWithoutRootChildrenInput
    upsert?: SeoUpsertWithoutRootChildrenInput
    disconnect?: SeoWhereInput | boolean
    delete?: SeoWhereInput | boolean
    connect?: SeoWhereUniqueInput
    update?: XOR<XOR<SeoUpdateToOneWithWhereWithoutRootChildrenInput, SeoUpdateWithoutRootChildrenInput>, SeoUncheckedUpdateWithoutRootChildrenInput>
  }

  export type SeoUpdateManyWithoutRootNestedInput = {
    create?: XOR<SeoCreateWithoutRootInput, SeoUncheckedCreateWithoutRootInput> | SeoCreateWithoutRootInput[] | SeoUncheckedCreateWithoutRootInput[]
    connectOrCreate?: SeoCreateOrConnectWithoutRootInput | SeoCreateOrConnectWithoutRootInput[]
    upsert?: SeoUpsertWithWhereUniqueWithoutRootInput | SeoUpsertWithWhereUniqueWithoutRootInput[]
    createMany?: SeoCreateManyRootInputEnvelope
    set?: SeoWhereUniqueInput | SeoWhereUniqueInput[]
    disconnect?: SeoWhereUniqueInput | SeoWhereUniqueInput[]
    delete?: SeoWhereUniqueInput | SeoWhereUniqueInput[]
    connect?: SeoWhereUniqueInput | SeoWhereUniqueInput[]
    update?: SeoUpdateWithWhereUniqueWithoutRootInput | SeoUpdateWithWhereUniqueWithoutRootInput[]
    updateMany?: SeoUpdateManyWithWhereWithoutRootInput | SeoUpdateManyWithWhereWithoutRootInput[]
    deleteMany?: SeoScalarWhereInput | SeoScalarWhereInput[]
  }

  export type SettingsUpdateManyWithoutSeoNestedInput = {
    create?: XOR<SettingsCreateWithoutSeoInput, SettingsUncheckedCreateWithoutSeoInput> | SettingsCreateWithoutSeoInput[] | SettingsUncheckedCreateWithoutSeoInput[]
    connectOrCreate?: SettingsCreateOrConnectWithoutSeoInput | SettingsCreateOrConnectWithoutSeoInput[]
    upsert?: SettingsUpsertWithWhereUniqueWithoutSeoInput | SettingsUpsertWithWhereUniqueWithoutSeoInput[]
    createMany?: SettingsCreateManySeoInputEnvelope
    set?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    disconnect?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    delete?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    connect?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    update?: SettingsUpdateWithWhereUniqueWithoutSeoInput | SettingsUpdateWithWhereUniqueWithoutSeoInput[]
    updateMany?: SettingsUpdateManyWithWhereWithoutSeoInput | SettingsUpdateManyWithWhereWithoutSeoInput[]
    deleteMany?: SettingsScalarWhereInput | SettingsScalarWhereInput[]
  }

  export type PostUpdateManyWithoutSeoNestedInput = {
    create?: XOR<PostCreateWithoutSeoInput, PostUncheckedCreateWithoutSeoInput> | PostCreateWithoutSeoInput[] | PostUncheckedCreateWithoutSeoInput[]
    connectOrCreate?: PostCreateOrConnectWithoutSeoInput | PostCreateOrConnectWithoutSeoInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutSeoInput | PostUpsertWithWhereUniqueWithoutSeoInput[]
    createMany?: PostCreateManySeoInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutSeoInput | PostUpdateWithWhereUniqueWithoutSeoInput[]
    updateMany?: PostUpdateManyWithWhereWithoutSeoInput | PostUpdateManyWithWhereWithoutSeoInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CategoryUpdateManyWithoutSeoNestedInput = {
    create?: XOR<CategoryCreateWithoutSeoInput, CategoryUncheckedCreateWithoutSeoInput> | CategoryCreateWithoutSeoInput[] | CategoryUncheckedCreateWithoutSeoInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutSeoInput | CategoryCreateOrConnectWithoutSeoInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutSeoInput | CategoryUpsertWithWhereUniqueWithoutSeoInput[]
    createMany?: CategoryCreateManySeoInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutSeoInput | CategoryUpdateWithWhereUniqueWithoutSeoInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutSeoInput | CategoryUpdateManyWithWhereWithoutSeoInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type TagUpdateManyWithoutSeoNestedInput = {
    create?: XOR<TagCreateWithoutSeoInput, TagUncheckedCreateWithoutSeoInput> | TagCreateWithoutSeoInput[] | TagUncheckedCreateWithoutSeoInput[]
    connectOrCreate?: TagCreateOrConnectWithoutSeoInput | TagCreateOrConnectWithoutSeoInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutSeoInput | TagUpsertWithWhereUniqueWithoutSeoInput[]
    createMany?: TagCreateManySeoInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutSeoInput | TagUpdateWithWhereUniqueWithoutSeoInput[]
    updateMany?: TagUpdateManyWithWhereWithoutSeoInput | TagUpdateManyWithWhereWithoutSeoInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutSeoNestedInput = {
    create?: XOR<ProductCreateWithoutSeoInput, ProductUncheckedCreateWithoutSeoInput> | ProductCreateWithoutSeoInput[] | ProductUncheckedCreateWithoutSeoInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSeoInput | ProductCreateOrConnectWithoutSeoInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSeoInput | ProductUpsertWithWhereUniqueWithoutSeoInput[]
    createMany?: ProductCreateManySeoInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSeoInput | ProductUpdateWithWhereUniqueWithoutSeoInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSeoInput | ProductUpdateManyWithWhereWithoutSeoInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCategoryUpdateManyWithoutSeoNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutSeoInput, ProductCategoryUncheckedCreateWithoutSeoInput> | ProductCategoryCreateWithoutSeoInput[] | ProductCategoryUncheckedCreateWithoutSeoInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutSeoInput | ProductCategoryCreateOrConnectWithoutSeoInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutSeoInput | ProductCategoryUpsertWithWhereUniqueWithoutSeoInput[]
    createMany?: ProductCategoryCreateManySeoInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutSeoInput | ProductCategoryUpdateWithWhereUniqueWithoutSeoInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutSeoInput | ProductCategoryUpdateManyWithWhereWithoutSeoInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type SeoUncheckedUpdateManyWithoutRootNestedInput = {
    create?: XOR<SeoCreateWithoutRootInput, SeoUncheckedCreateWithoutRootInput> | SeoCreateWithoutRootInput[] | SeoUncheckedCreateWithoutRootInput[]
    connectOrCreate?: SeoCreateOrConnectWithoutRootInput | SeoCreateOrConnectWithoutRootInput[]
    upsert?: SeoUpsertWithWhereUniqueWithoutRootInput | SeoUpsertWithWhereUniqueWithoutRootInput[]
    createMany?: SeoCreateManyRootInputEnvelope
    set?: SeoWhereUniqueInput | SeoWhereUniqueInput[]
    disconnect?: SeoWhereUniqueInput | SeoWhereUniqueInput[]
    delete?: SeoWhereUniqueInput | SeoWhereUniqueInput[]
    connect?: SeoWhereUniqueInput | SeoWhereUniqueInput[]
    update?: SeoUpdateWithWhereUniqueWithoutRootInput | SeoUpdateWithWhereUniqueWithoutRootInput[]
    updateMany?: SeoUpdateManyWithWhereWithoutRootInput | SeoUpdateManyWithWhereWithoutRootInput[]
    deleteMany?: SeoScalarWhereInput | SeoScalarWhereInput[]
  }

  export type SettingsUncheckedUpdateManyWithoutSeoNestedInput = {
    create?: XOR<SettingsCreateWithoutSeoInput, SettingsUncheckedCreateWithoutSeoInput> | SettingsCreateWithoutSeoInput[] | SettingsUncheckedCreateWithoutSeoInput[]
    connectOrCreate?: SettingsCreateOrConnectWithoutSeoInput | SettingsCreateOrConnectWithoutSeoInput[]
    upsert?: SettingsUpsertWithWhereUniqueWithoutSeoInput | SettingsUpsertWithWhereUniqueWithoutSeoInput[]
    createMany?: SettingsCreateManySeoInputEnvelope
    set?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    disconnect?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    delete?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    connect?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    update?: SettingsUpdateWithWhereUniqueWithoutSeoInput | SettingsUpdateWithWhereUniqueWithoutSeoInput[]
    updateMany?: SettingsUpdateManyWithWhereWithoutSeoInput | SettingsUpdateManyWithWhereWithoutSeoInput[]
    deleteMany?: SettingsScalarWhereInput | SettingsScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutSeoNestedInput = {
    create?: XOR<PostCreateWithoutSeoInput, PostUncheckedCreateWithoutSeoInput> | PostCreateWithoutSeoInput[] | PostUncheckedCreateWithoutSeoInput[]
    connectOrCreate?: PostCreateOrConnectWithoutSeoInput | PostCreateOrConnectWithoutSeoInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutSeoInput | PostUpsertWithWhereUniqueWithoutSeoInput[]
    createMany?: PostCreateManySeoInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutSeoInput | PostUpdateWithWhereUniqueWithoutSeoInput[]
    updateMany?: PostUpdateManyWithWhereWithoutSeoInput | PostUpdateManyWithWhereWithoutSeoInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutSeoNestedInput = {
    create?: XOR<CategoryCreateWithoutSeoInput, CategoryUncheckedCreateWithoutSeoInput> | CategoryCreateWithoutSeoInput[] | CategoryUncheckedCreateWithoutSeoInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutSeoInput | CategoryCreateOrConnectWithoutSeoInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutSeoInput | CategoryUpsertWithWhereUniqueWithoutSeoInput[]
    createMany?: CategoryCreateManySeoInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutSeoInput | CategoryUpdateWithWhereUniqueWithoutSeoInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutSeoInput | CategoryUpdateManyWithWhereWithoutSeoInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutSeoNestedInput = {
    create?: XOR<TagCreateWithoutSeoInput, TagUncheckedCreateWithoutSeoInput> | TagCreateWithoutSeoInput[] | TagUncheckedCreateWithoutSeoInput[]
    connectOrCreate?: TagCreateOrConnectWithoutSeoInput | TagCreateOrConnectWithoutSeoInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutSeoInput | TagUpsertWithWhereUniqueWithoutSeoInput[]
    createMany?: TagCreateManySeoInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutSeoInput | TagUpdateWithWhereUniqueWithoutSeoInput[]
    updateMany?: TagUpdateManyWithWhereWithoutSeoInput | TagUpdateManyWithWhereWithoutSeoInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutSeoNestedInput = {
    create?: XOR<ProductCreateWithoutSeoInput, ProductUncheckedCreateWithoutSeoInput> | ProductCreateWithoutSeoInput[] | ProductUncheckedCreateWithoutSeoInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSeoInput | ProductCreateOrConnectWithoutSeoInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSeoInput | ProductUpsertWithWhereUniqueWithoutSeoInput[]
    createMany?: ProductCreateManySeoInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSeoInput | ProductUpdateWithWhereUniqueWithoutSeoInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSeoInput | ProductUpdateManyWithWhereWithoutSeoInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCategoryUncheckedUpdateManyWithoutSeoNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutSeoInput, ProductCategoryUncheckedCreateWithoutSeoInput> | ProductCategoryCreateWithoutSeoInput[] | ProductCategoryUncheckedCreateWithoutSeoInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutSeoInput | ProductCategoryCreateOrConnectWithoutSeoInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutSeoInput | ProductCategoryUpsertWithWhereUniqueWithoutSeoInput[]
    createMany?: ProductCategoryCreateManySeoInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutSeoInput | ProductCategoryUpdateWithWhereUniqueWithoutSeoInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutSeoInput | ProductCategoryUpdateManyWithWhereWithoutSeoInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutRootChildrenInput = {
    create?: XOR<PostCreateWithoutRootChildrenInput, PostUncheckedCreateWithoutRootChildrenInput>
    connectOrCreate?: PostCreateOrConnectWithoutRootChildrenInput
    connect?: PostWhereUniqueInput
  }

  export type PostCreateNestedManyWithoutRootInput = {
    create?: XOR<PostCreateWithoutRootInput, PostUncheckedCreateWithoutRootInput> | PostCreateWithoutRootInput[] | PostUncheckedCreateWithoutRootInput[]
    connectOrCreate?: PostCreateOrConnectWithoutRootInput | PostCreateOrConnectWithoutRootInput[]
    createMany?: PostCreateManyRootInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type MediaCreateNestedOneWithoutPostInput = {
    create?: XOR<MediaCreateWithoutPostInput, MediaUncheckedCreateWithoutPostInput>
    connectOrCreate?: MediaCreateOrConnectWithoutPostInput
    connect?: MediaWhereUniqueInput
  }

  export type PostCategoryCreateNestedManyWithoutPostInput = {
    create?: XOR<PostCategoryCreateWithoutPostInput, PostCategoryUncheckedCreateWithoutPostInput> | PostCategoryCreateWithoutPostInput[] | PostCategoryUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostCategoryCreateOrConnectWithoutPostInput | PostCategoryCreateOrConnectWithoutPostInput[]
    createMany?: PostCategoryCreateManyPostInputEnvelope
    connect?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutPostsInput = {
    create?: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput> | TagCreateWithoutPostsInput[] | TagUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutPostsInput | TagCreateOrConnectWithoutPostsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type SeoCreateNestedOneWithoutPostsInput = {
    create?: XOR<SeoCreateWithoutPostsInput, SeoUncheckedCreateWithoutPostsInput>
    connectOrCreate?: SeoCreateOrConnectWithoutPostsInput
    connect?: SeoWhereUniqueInput
  }

  export type PostAuthorCreateNestedManyWithoutPostInput = {
    create?: XOR<PostAuthorCreateWithoutPostInput, PostAuthorUncheckedCreateWithoutPostInput> | PostAuthorCreateWithoutPostInput[] | PostAuthorUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostAuthorCreateOrConnectWithoutPostInput | PostAuthorCreateOrConnectWithoutPostInput[]
    createMany?: PostAuthorCreateManyPostInputEnvelope
    connect?: PostAuthorWhereUniqueInput | PostAuthorWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type PostUncheckedCreateNestedManyWithoutRootInput = {
    create?: XOR<PostCreateWithoutRootInput, PostUncheckedCreateWithoutRootInput> | PostCreateWithoutRootInput[] | PostUncheckedCreateWithoutRootInput[]
    connectOrCreate?: PostCreateOrConnectWithoutRootInput | PostCreateOrConnectWithoutRootInput[]
    createMany?: PostCreateManyRootInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PostCategoryUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostCategoryCreateWithoutPostInput, PostCategoryUncheckedCreateWithoutPostInput> | PostCategoryCreateWithoutPostInput[] | PostCategoryUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostCategoryCreateOrConnectWithoutPostInput | PostCategoryCreateOrConnectWithoutPostInput[]
    createMany?: PostCategoryCreateManyPostInputEnvelope
    connect?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput> | TagCreateWithoutPostsInput[] | TagUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutPostsInput | TagCreateOrConnectWithoutPostsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type PostAuthorUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostAuthorCreateWithoutPostInput, PostAuthorUncheckedCreateWithoutPostInput> | PostAuthorCreateWithoutPostInput[] | PostAuthorUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostAuthorCreateOrConnectWithoutPostInput | PostAuthorCreateOrConnectWithoutPostInput[]
    createMany?: PostAuthorCreateManyPostInputEnvelope
    connect?: PostAuthorWhereUniqueInput | PostAuthorWhereUniqueInput[]
  }

  export type EnumContentStatusFieldUpdateOperationsInput = {
    set?: $Enums.ContentStatus
  }

  export type EnumEditorTypeFieldUpdateOperationsInput = {
    set?: $Enums.EditorType
  }

  export type PostUpdateOneWithoutRootChildrenNestedInput = {
    create?: XOR<PostCreateWithoutRootChildrenInput, PostUncheckedCreateWithoutRootChildrenInput>
    connectOrCreate?: PostCreateOrConnectWithoutRootChildrenInput
    upsert?: PostUpsertWithoutRootChildrenInput
    disconnect?: PostWhereInput | boolean
    delete?: PostWhereInput | boolean
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutRootChildrenInput, PostUpdateWithoutRootChildrenInput>, PostUncheckedUpdateWithoutRootChildrenInput>
  }

  export type PostUpdateManyWithoutRootNestedInput = {
    create?: XOR<PostCreateWithoutRootInput, PostUncheckedCreateWithoutRootInput> | PostCreateWithoutRootInput[] | PostUncheckedCreateWithoutRootInput[]
    connectOrCreate?: PostCreateOrConnectWithoutRootInput | PostCreateOrConnectWithoutRootInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutRootInput | PostUpsertWithWhereUniqueWithoutRootInput[]
    createMany?: PostCreateManyRootInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutRootInput | PostUpdateWithWhereUniqueWithoutRootInput[]
    updateMany?: PostUpdateManyWithWhereWithoutRootInput | PostUpdateManyWithWhereWithoutRootInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type MediaUpdateOneWithoutPostNestedInput = {
    create?: XOR<MediaCreateWithoutPostInput, MediaUncheckedCreateWithoutPostInput>
    connectOrCreate?: MediaCreateOrConnectWithoutPostInput
    upsert?: MediaUpsertWithoutPostInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutPostInput, MediaUpdateWithoutPostInput>, MediaUncheckedUpdateWithoutPostInput>
  }

  export type PostCategoryUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostCategoryCreateWithoutPostInput, PostCategoryUncheckedCreateWithoutPostInput> | PostCategoryCreateWithoutPostInput[] | PostCategoryUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostCategoryCreateOrConnectWithoutPostInput | PostCategoryCreateOrConnectWithoutPostInput[]
    upsert?: PostCategoryUpsertWithWhereUniqueWithoutPostInput | PostCategoryUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostCategoryCreateManyPostInputEnvelope
    set?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    disconnect?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    delete?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    connect?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    update?: PostCategoryUpdateWithWhereUniqueWithoutPostInput | PostCategoryUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostCategoryUpdateManyWithWhereWithoutPostInput | PostCategoryUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostCategoryScalarWhereInput | PostCategoryScalarWhereInput[]
  }

  export type TagUpdateManyWithoutPostsNestedInput = {
    create?: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput> | TagCreateWithoutPostsInput[] | TagUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutPostsInput | TagCreateOrConnectWithoutPostsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutPostsInput | TagUpsertWithWhereUniqueWithoutPostsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutPostsInput | TagUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutPostsInput | TagUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type SeoUpdateOneWithoutPostsNestedInput = {
    create?: XOR<SeoCreateWithoutPostsInput, SeoUncheckedCreateWithoutPostsInput>
    connectOrCreate?: SeoCreateOrConnectWithoutPostsInput
    upsert?: SeoUpsertWithoutPostsInput
    disconnect?: SeoWhereInput | boolean
    delete?: SeoWhereInput | boolean
    connect?: SeoWhereUniqueInput
    update?: XOR<XOR<SeoUpdateToOneWithWhereWithoutPostsInput, SeoUpdateWithoutPostsInput>, SeoUncheckedUpdateWithoutPostsInput>
  }

  export type PostAuthorUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostAuthorCreateWithoutPostInput, PostAuthorUncheckedCreateWithoutPostInput> | PostAuthorCreateWithoutPostInput[] | PostAuthorUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostAuthorCreateOrConnectWithoutPostInput | PostAuthorCreateOrConnectWithoutPostInput[]
    upsert?: PostAuthorUpsertWithWhereUniqueWithoutPostInput | PostAuthorUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostAuthorCreateManyPostInputEnvelope
    set?: PostAuthorWhereUniqueInput | PostAuthorWhereUniqueInput[]
    disconnect?: PostAuthorWhereUniqueInput | PostAuthorWhereUniqueInput[]
    delete?: PostAuthorWhereUniqueInput | PostAuthorWhereUniqueInput[]
    connect?: PostAuthorWhereUniqueInput | PostAuthorWhereUniqueInput[]
    update?: PostAuthorUpdateWithWhereUniqueWithoutPostInput | PostAuthorUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostAuthorUpdateManyWithWhereWithoutPostInput | PostAuthorUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostAuthorScalarWhereInput | PostAuthorScalarWhereInput[]
  }

  export type UserUpdateOneWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostsInput, UserUpdateWithoutPostsInput>, UserUncheckedUpdateWithoutPostsInput>
  }

  export type PostUncheckedUpdateManyWithoutRootNestedInput = {
    create?: XOR<PostCreateWithoutRootInput, PostUncheckedCreateWithoutRootInput> | PostCreateWithoutRootInput[] | PostUncheckedCreateWithoutRootInput[]
    connectOrCreate?: PostCreateOrConnectWithoutRootInput | PostCreateOrConnectWithoutRootInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutRootInput | PostUpsertWithWhereUniqueWithoutRootInput[]
    createMany?: PostCreateManyRootInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutRootInput | PostUpdateWithWhereUniqueWithoutRootInput[]
    updateMany?: PostUpdateManyWithWhereWithoutRootInput | PostUpdateManyWithWhereWithoutRootInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type PostCategoryUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostCategoryCreateWithoutPostInput, PostCategoryUncheckedCreateWithoutPostInput> | PostCategoryCreateWithoutPostInput[] | PostCategoryUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostCategoryCreateOrConnectWithoutPostInput | PostCategoryCreateOrConnectWithoutPostInput[]
    upsert?: PostCategoryUpsertWithWhereUniqueWithoutPostInput | PostCategoryUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostCategoryCreateManyPostInputEnvelope
    set?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    disconnect?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    delete?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    connect?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    update?: PostCategoryUpdateWithWhereUniqueWithoutPostInput | PostCategoryUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostCategoryUpdateManyWithWhereWithoutPostInput | PostCategoryUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostCategoryScalarWhereInput | PostCategoryScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput> | TagCreateWithoutPostsInput[] | TagUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutPostsInput | TagCreateOrConnectWithoutPostsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutPostsInput | TagUpsertWithWhereUniqueWithoutPostsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutPostsInput | TagUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutPostsInput | TagUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type PostAuthorUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostAuthorCreateWithoutPostInput, PostAuthorUncheckedCreateWithoutPostInput> | PostAuthorCreateWithoutPostInput[] | PostAuthorUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostAuthorCreateOrConnectWithoutPostInput | PostAuthorCreateOrConnectWithoutPostInput[]
    upsert?: PostAuthorUpsertWithWhereUniqueWithoutPostInput | PostAuthorUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostAuthorCreateManyPostInputEnvelope
    set?: PostAuthorWhereUniqueInput | PostAuthorWhereUniqueInput[]
    disconnect?: PostAuthorWhereUniqueInput | PostAuthorWhereUniqueInput[]
    delete?: PostAuthorWhereUniqueInput | PostAuthorWhereUniqueInput[]
    connect?: PostAuthorWhereUniqueInput | PostAuthorWhereUniqueInput[]
    update?: PostAuthorUpdateWithWhereUniqueWithoutPostInput | PostAuthorUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostAuthorUpdateManyWithWhereWithoutPostInput | PostAuthorUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostAuthorScalarWhereInput | PostAuthorScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutPostAuthorsInput = {
    create?: XOR<PostCreateWithoutPostAuthorsInput, PostUncheckedCreateWithoutPostAuthorsInput>
    connectOrCreate?: PostCreateOrConnectWithoutPostAuthorsInput
    connect?: PostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPostAuthorsInput = {
    create?: XOR<UserCreateWithoutPostAuthorsInput, UserUncheckedCreateWithoutPostAuthorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostAuthorsInput
    connect?: UserWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutPostAuthorsNestedInput = {
    create?: XOR<PostCreateWithoutPostAuthorsInput, PostUncheckedCreateWithoutPostAuthorsInput>
    connectOrCreate?: PostCreateOrConnectWithoutPostAuthorsInput
    upsert?: PostUpsertWithoutPostAuthorsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutPostAuthorsInput, PostUpdateWithoutPostAuthorsInput>, PostUncheckedUpdateWithoutPostAuthorsInput>
  }

  export type UserUpdateOneRequiredWithoutPostAuthorsNestedInput = {
    create?: XOR<UserCreateWithoutPostAuthorsInput, UserUncheckedCreateWithoutPostAuthorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostAuthorsInput
    upsert?: UserUpsertWithoutPostAuthorsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostAuthorsInput, UserUpdateWithoutPostAuthorsInput>, UserUncheckedUpdateWithoutPostAuthorsInput>
  }

  export type CategoryCreateNestedOneWithoutRootChildrenInput = {
    create?: XOR<CategoryCreateWithoutRootChildrenInput, CategoryUncheckedCreateWithoutRootChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutRootChildrenInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutRootInput = {
    create?: XOR<CategoryCreateWithoutRootInput, CategoryUncheckedCreateWithoutRootInput> | CategoryCreateWithoutRootInput[] | CategoryUncheckedCreateWithoutRootInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutRootInput | CategoryCreateOrConnectWithoutRootInput[]
    createMany?: CategoryCreateManyRootInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type PostCategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PostCategoryCreateWithoutCategoryInput, PostCategoryUncheckedCreateWithoutCategoryInput> | PostCategoryCreateWithoutCategoryInput[] | PostCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PostCategoryCreateOrConnectWithoutCategoryInput | PostCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: PostCategoryCreateManyCategoryInputEnvelope
    connect?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
  }

  export type SeoCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<SeoCreateWithoutCategoriesInput, SeoUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: SeoCreateOrConnectWithoutCategoriesInput
    connect?: SeoWhereUniqueInput
  }

  export type CategoryUncheckedCreateNestedManyWithoutRootInput = {
    create?: XOR<CategoryCreateWithoutRootInput, CategoryUncheckedCreateWithoutRootInput> | CategoryCreateWithoutRootInput[] | CategoryUncheckedCreateWithoutRootInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutRootInput | CategoryCreateOrConnectWithoutRootInput[]
    createMany?: CategoryCreateManyRootInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type PostCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PostCategoryCreateWithoutCategoryInput, PostCategoryUncheckedCreateWithoutCategoryInput> | PostCategoryCreateWithoutCategoryInput[] | PostCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PostCategoryCreateOrConnectWithoutCategoryInput | PostCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: PostCategoryCreateManyCategoryInputEnvelope
    connect?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
  }

  export type CategoryUpdateOneWithoutRootChildrenNestedInput = {
    create?: XOR<CategoryCreateWithoutRootChildrenInput, CategoryUncheckedCreateWithoutRootChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutRootChildrenInput
    upsert?: CategoryUpsertWithoutRootChildrenInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutRootChildrenInput, CategoryUpdateWithoutRootChildrenInput>, CategoryUncheckedUpdateWithoutRootChildrenInput>
  }

  export type CategoryUpdateManyWithoutRootNestedInput = {
    create?: XOR<CategoryCreateWithoutRootInput, CategoryUncheckedCreateWithoutRootInput> | CategoryCreateWithoutRootInput[] | CategoryUncheckedCreateWithoutRootInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutRootInput | CategoryCreateOrConnectWithoutRootInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutRootInput | CategoryUpsertWithWhereUniqueWithoutRootInput[]
    createMany?: CategoryCreateManyRootInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutRootInput | CategoryUpdateWithWhereUniqueWithoutRootInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutRootInput | CategoryUpdateManyWithWhereWithoutRootInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type PostCategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PostCategoryCreateWithoutCategoryInput, PostCategoryUncheckedCreateWithoutCategoryInput> | PostCategoryCreateWithoutCategoryInput[] | PostCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PostCategoryCreateOrConnectWithoutCategoryInput | PostCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: PostCategoryUpsertWithWhereUniqueWithoutCategoryInput | PostCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PostCategoryCreateManyCategoryInputEnvelope
    set?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    disconnect?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    delete?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    connect?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    update?: PostCategoryUpdateWithWhereUniqueWithoutCategoryInput | PostCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PostCategoryUpdateManyWithWhereWithoutCategoryInput | PostCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PostCategoryScalarWhereInput | PostCategoryScalarWhereInput[]
  }

  export type SeoUpdateOneWithoutCategoriesNestedInput = {
    create?: XOR<SeoCreateWithoutCategoriesInput, SeoUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: SeoCreateOrConnectWithoutCategoriesInput
    upsert?: SeoUpsertWithoutCategoriesInput
    disconnect?: SeoWhereInput | boolean
    delete?: SeoWhereInput | boolean
    connect?: SeoWhereUniqueInput
    update?: XOR<XOR<SeoUpdateToOneWithWhereWithoutCategoriesInput, SeoUpdateWithoutCategoriesInput>, SeoUncheckedUpdateWithoutCategoriesInput>
  }

  export type CategoryUncheckedUpdateManyWithoutRootNestedInput = {
    create?: XOR<CategoryCreateWithoutRootInput, CategoryUncheckedCreateWithoutRootInput> | CategoryCreateWithoutRootInput[] | CategoryUncheckedCreateWithoutRootInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutRootInput | CategoryCreateOrConnectWithoutRootInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutRootInput | CategoryUpsertWithWhereUniqueWithoutRootInput[]
    createMany?: CategoryCreateManyRootInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutRootInput | CategoryUpdateWithWhereUniqueWithoutRootInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutRootInput | CategoryUpdateManyWithWhereWithoutRootInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type PostCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PostCategoryCreateWithoutCategoryInput, PostCategoryUncheckedCreateWithoutCategoryInput> | PostCategoryCreateWithoutCategoryInput[] | PostCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PostCategoryCreateOrConnectWithoutCategoryInput | PostCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: PostCategoryUpsertWithWhereUniqueWithoutCategoryInput | PostCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PostCategoryCreateManyCategoryInputEnvelope
    set?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    disconnect?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    delete?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    connect?: PostCategoryWhereUniqueInput | PostCategoryWhereUniqueInput[]
    update?: PostCategoryUpdateWithWhereUniqueWithoutCategoryInput | PostCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PostCategoryUpdateManyWithWhereWithoutCategoryInput | PostCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PostCategoryScalarWhereInput | PostCategoryScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutPostCategoriesInput = {
    create?: XOR<PostCreateWithoutPostCategoriesInput, PostUncheckedCreateWithoutPostCategoriesInput>
    connectOrCreate?: PostCreateOrConnectWithoutPostCategoriesInput
    connect?: PostWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutPostCategoriesInput = {
    create?: XOR<CategoryCreateWithoutPostCategoriesInput, CategoryUncheckedCreateWithoutPostCategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPostCategoriesInput
    connect?: CategoryWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutPostCategoriesNestedInput = {
    create?: XOR<PostCreateWithoutPostCategoriesInput, PostUncheckedCreateWithoutPostCategoriesInput>
    connectOrCreate?: PostCreateOrConnectWithoutPostCategoriesInput
    upsert?: PostUpsertWithoutPostCategoriesInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutPostCategoriesInput, PostUpdateWithoutPostCategoriesInput>, PostUncheckedUpdateWithoutPostCategoriesInput>
  }

  export type CategoryUpdateOneRequiredWithoutPostCategoriesNestedInput = {
    create?: XOR<CategoryCreateWithoutPostCategoriesInput, CategoryUncheckedCreateWithoutPostCategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPostCategoriesInput
    upsert?: CategoryUpsertWithoutPostCategoriesInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutPostCategoriesInput, CategoryUpdateWithoutPostCategoriesInput>, CategoryUncheckedUpdateWithoutPostCategoriesInput>
  }

  export type TagCreateNestedOneWithoutRootChildrenInput = {
    create?: XOR<TagCreateWithoutRootChildrenInput, TagUncheckedCreateWithoutRootChildrenInput>
    connectOrCreate?: TagCreateOrConnectWithoutRootChildrenInput
    connect?: TagWhereUniqueInput
  }

  export type TagCreateNestedManyWithoutRootInput = {
    create?: XOR<TagCreateWithoutRootInput, TagUncheckedCreateWithoutRootInput> | TagCreateWithoutRootInput[] | TagUncheckedCreateWithoutRootInput[]
    connectOrCreate?: TagCreateOrConnectWithoutRootInput | TagCreateOrConnectWithoutRootInput[]
    createMany?: TagCreateManyRootInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutTagsInput = {
    create?: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput> | PostCreateWithoutTagsInput[] | PostUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: PostCreateOrConnectWithoutTagsInput | PostCreateOrConnectWithoutTagsInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type SeoCreateNestedOneWithoutTagsInput = {
    create?: XOR<SeoCreateWithoutTagsInput, SeoUncheckedCreateWithoutTagsInput>
    connectOrCreate?: SeoCreateOrConnectWithoutTagsInput
    connect?: SeoWhereUniqueInput
  }

  export type TagUncheckedCreateNestedManyWithoutRootInput = {
    create?: XOR<TagCreateWithoutRootInput, TagUncheckedCreateWithoutRootInput> | TagCreateWithoutRootInput[] | TagUncheckedCreateWithoutRootInput[]
    connectOrCreate?: TagCreateOrConnectWithoutRootInput | TagCreateOrConnectWithoutRootInput[]
    createMany?: TagCreateManyRootInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput> | PostCreateWithoutTagsInput[] | PostUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: PostCreateOrConnectWithoutTagsInput | PostCreateOrConnectWithoutTagsInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type TagUpdateOneWithoutRootChildrenNestedInput = {
    create?: XOR<TagCreateWithoutRootChildrenInput, TagUncheckedCreateWithoutRootChildrenInput>
    connectOrCreate?: TagCreateOrConnectWithoutRootChildrenInput
    upsert?: TagUpsertWithoutRootChildrenInput
    disconnect?: TagWhereInput | boolean
    delete?: TagWhereInput | boolean
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutRootChildrenInput, TagUpdateWithoutRootChildrenInput>, TagUncheckedUpdateWithoutRootChildrenInput>
  }

  export type TagUpdateManyWithoutRootNestedInput = {
    create?: XOR<TagCreateWithoutRootInput, TagUncheckedCreateWithoutRootInput> | TagCreateWithoutRootInput[] | TagUncheckedCreateWithoutRootInput[]
    connectOrCreate?: TagCreateOrConnectWithoutRootInput | TagCreateOrConnectWithoutRootInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutRootInput | TagUpsertWithWhereUniqueWithoutRootInput[]
    createMany?: TagCreateManyRootInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutRootInput | TagUpdateWithWhereUniqueWithoutRootInput[]
    updateMany?: TagUpdateManyWithWhereWithoutRootInput | TagUpdateManyWithWhereWithoutRootInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type PostUpdateManyWithoutTagsNestedInput = {
    create?: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput> | PostCreateWithoutTagsInput[] | PostUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: PostCreateOrConnectWithoutTagsInput | PostCreateOrConnectWithoutTagsInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutTagsInput | PostUpsertWithWhereUniqueWithoutTagsInput[]
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutTagsInput | PostUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: PostUpdateManyWithWhereWithoutTagsInput | PostUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type SeoUpdateOneWithoutTagsNestedInput = {
    create?: XOR<SeoCreateWithoutTagsInput, SeoUncheckedCreateWithoutTagsInput>
    connectOrCreate?: SeoCreateOrConnectWithoutTagsInput
    upsert?: SeoUpsertWithoutTagsInput
    disconnect?: SeoWhereInput | boolean
    delete?: SeoWhereInput | boolean
    connect?: SeoWhereUniqueInput
    update?: XOR<XOR<SeoUpdateToOneWithWhereWithoutTagsInput, SeoUpdateWithoutTagsInput>, SeoUncheckedUpdateWithoutTagsInput>
  }

  export type TagUncheckedUpdateManyWithoutRootNestedInput = {
    create?: XOR<TagCreateWithoutRootInput, TagUncheckedCreateWithoutRootInput> | TagCreateWithoutRootInput[] | TagUncheckedCreateWithoutRootInput[]
    connectOrCreate?: TagCreateOrConnectWithoutRootInput | TagCreateOrConnectWithoutRootInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutRootInput | TagUpsertWithWhereUniqueWithoutRootInput[]
    createMany?: TagCreateManyRootInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutRootInput | TagUpdateWithWhereUniqueWithoutRootInput[]
    updateMany?: TagUpdateManyWithWhereWithoutRootInput | TagUpdateManyWithWhereWithoutRootInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput> | PostCreateWithoutTagsInput[] | PostUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: PostCreateOrConnectWithoutTagsInput | PostCreateOrConnectWithoutTagsInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutTagsInput | PostUpsertWithWhereUniqueWithoutTagsInput[]
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutTagsInput | PostUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: PostUpdateManyWithWhereWithoutTagsInput | PostUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type EmailTemplateCreateNestedOneWithoutEmailSettingSubscriptionInput = {
    create?: XOR<EmailTemplateCreateWithoutEmailSettingSubscriptionInput, EmailTemplateUncheckedCreateWithoutEmailSettingSubscriptionInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutEmailSettingSubscriptionInput
    connect?: EmailTemplateWhereUniqueInput
  }

  export type EmailTemplateCreateNestedOneWithoutEmailSettingFreeEbookInput = {
    create?: XOR<EmailTemplateCreateWithoutEmailSettingFreeEbookInput, EmailTemplateUncheckedCreateWithoutEmailSettingFreeEbookInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutEmailSettingFreeEbookInput
    connect?: EmailTemplateWhereUniqueInput
  }

  export type EmailTemplateCreateNestedOneWithoutEmailSettingWebinarInput = {
    create?: XOR<EmailTemplateCreateWithoutEmailSettingWebinarInput, EmailTemplateUncheckedCreateWithoutEmailSettingWebinarInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutEmailSettingWebinarInput
    connect?: EmailTemplateWhereUniqueInput
  }

  export type NullableEnumEmailProviderFieldUpdateOperationsInput = {
    set?: $Enums.EmailProvider | null
  }

  export type EmailTemplateUpdateOneWithoutEmailSettingSubscriptionNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutEmailSettingSubscriptionInput, EmailTemplateUncheckedCreateWithoutEmailSettingSubscriptionInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutEmailSettingSubscriptionInput
    upsert?: EmailTemplateUpsertWithoutEmailSettingSubscriptionInput
    disconnect?: EmailTemplateWhereInput | boolean
    delete?: EmailTemplateWhereInput | boolean
    connect?: EmailTemplateWhereUniqueInput
    update?: XOR<XOR<EmailTemplateUpdateToOneWithWhereWithoutEmailSettingSubscriptionInput, EmailTemplateUpdateWithoutEmailSettingSubscriptionInput>, EmailTemplateUncheckedUpdateWithoutEmailSettingSubscriptionInput>
  }

  export type EmailTemplateUpdateOneWithoutEmailSettingFreeEbookNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutEmailSettingFreeEbookInput, EmailTemplateUncheckedCreateWithoutEmailSettingFreeEbookInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutEmailSettingFreeEbookInput
    upsert?: EmailTemplateUpsertWithoutEmailSettingFreeEbookInput
    disconnect?: EmailTemplateWhereInput | boolean
    delete?: EmailTemplateWhereInput | boolean
    connect?: EmailTemplateWhereUniqueInput
    update?: XOR<XOR<EmailTemplateUpdateToOneWithWhereWithoutEmailSettingFreeEbookInput, EmailTemplateUpdateWithoutEmailSettingFreeEbookInput>, EmailTemplateUncheckedUpdateWithoutEmailSettingFreeEbookInput>
  }

  export type EmailTemplateUpdateOneWithoutEmailSettingWebinarNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutEmailSettingWebinarInput, EmailTemplateUncheckedCreateWithoutEmailSettingWebinarInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutEmailSettingWebinarInput
    upsert?: EmailTemplateUpsertWithoutEmailSettingWebinarInput
    disconnect?: EmailTemplateWhereInput | boolean
    delete?: EmailTemplateWhereInput | boolean
    connect?: EmailTemplateWhereUniqueInput
    update?: XOR<XOR<EmailTemplateUpdateToOneWithWhereWithoutEmailSettingWebinarInput, EmailTemplateUpdateWithoutEmailSettingWebinarInput>, EmailTemplateUncheckedUpdateWithoutEmailSettingWebinarInput>
  }

  export type EmailSettingCreateNestedManyWithoutSubscriptionTemplateInput = {
    create?: XOR<EmailSettingCreateWithoutSubscriptionTemplateInput, EmailSettingUncheckedCreateWithoutSubscriptionTemplateInput> | EmailSettingCreateWithoutSubscriptionTemplateInput[] | EmailSettingUncheckedCreateWithoutSubscriptionTemplateInput[]
    connectOrCreate?: EmailSettingCreateOrConnectWithoutSubscriptionTemplateInput | EmailSettingCreateOrConnectWithoutSubscriptionTemplateInput[]
    createMany?: EmailSettingCreateManySubscriptionTemplateInputEnvelope
    connect?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
  }

  export type EmailSettingCreateNestedManyWithoutFreeEbookTemplateInput = {
    create?: XOR<EmailSettingCreateWithoutFreeEbookTemplateInput, EmailSettingUncheckedCreateWithoutFreeEbookTemplateInput> | EmailSettingCreateWithoutFreeEbookTemplateInput[] | EmailSettingUncheckedCreateWithoutFreeEbookTemplateInput[]
    connectOrCreate?: EmailSettingCreateOrConnectWithoutFreeEbookTemplateInput | EmailSettingCreateOrConnectWithoutFreeEbookTemplateInput[]
    createMany?: EmailSettingCreateManyFreeEbookTemplateInputEnvelope
    connect?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
  }

  export type EmailSettingCreateNestedManyWithoutWebinarTemplateInput = {
    create?: XOR<EmailSettingCreateWithoutWebinarTemplateInput, EmailSettingUncheckedCreateWithoutWebinarTemplateInput> | EmailSettingCreateWithoutWebinarTemplateInput[] | EmailSettingUncheckedCreateWithoutWebinarTemplateInput[]
    connectOrCreate?: EmailSettingCreateOrConnectWithoutWebinarTemplateInput | EmailSettingCreateOrConnectWithoutWebinarTemplateInput[]
    createMany?: EmailSettingCreateManyWebinarTemplateInputEnvelope
    connect?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
  }

  export type EmailSettingUncheckedCreateNestedManyWithoutSubscriptionTemplateInput = {
    create?: XOR<EmailSettingCreateWithoutSubscriptionTemplateInput, EmailSettingUncheckedCreateWithoutSubscriptionTemplateInput> | EmailSettingCreateWithoutSubscriptionTemplateInput[] | EmailSettingUncheckedCreateWithoutSubscriptionTemplateInput[]
    connectOrCreate?: EmailSettingCreateOrConnectWithoutSubscriptionTemplateInput | EmailSettingCreateOrConnectWithoutSubscriptionTemplateInput[]
    createMany?: EmailSettingCreateManySubscriptionTemplateInputEnvelope
    connect?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
  }

  export type EmailSettingUncheckedCreateNestedManyWithoutFreeEbookTemplateInput = {
    create?: XOR<EmailSettingCreateWithoutFreeEbookTemplateInput, EmailSettingUncheckedCreateWithoutFreeEbookTemplateInput> | EmailSettingCreateWithoutFreeEbookTemplateInput[] | EmailSettingUncheckedCreateWithoutFreeEbookTemplateInput[]
    connectOrCreate?: EmailSettingCreateOrConnectWithoutFreeEbookTemplateInput | EmailSettingCreateOrConnectWithoutFreeEbookTemplateInput[]
    createMany?: EmailSettingCreateManyFreeEbookTemplateInputEnvelope
    connect?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
  }

  export type EmailSettingUncheckedCreateNestedManyWithoutWebinarTemplateInput = {
    create?: XOR<EmailSettingCreateWithoutWebinarTemplateInput, EmailSettingUncheckedCreateWithoutWebinarTemplateInput> | EmailSettingCreateWithoutWebinarTemplateInput[] | EmailSettingUncheckedCreateWithoutWebinarTemplateInput[]
    connectOrCreate?: EmailSettingCreateOrConnectWithoutWebinarTemplateInput | EmailSettingCreateOrConnectWithoutWebinarTemplateInput[]
    createMany?: EmailSettingCreateManyWebinarTemplateInputEnvelope
    connect?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
  }

  export type EmailSettingUpdateManyWithoutSubscriptionTemplateNestedInput = {
    create?: XOR<EmailSettingCreateWithoutSubscriptionTemplateInput, EmailSettingUncheckedCreateWithoutSubscriptionTemplateInput> | EmailSettingCreateWithoutSubscriptionTemplateInput[] | EmailSettingUncheckedCreateWithoutSubscriptionTemplateInput[]
    connectOrCreate?: EmailSettingCreateOrConnectWithoutSubscriptionTemplateInput | EmailSettingCreateOrConnectWithoutSubscriptionTemplateInput[]
    upsert?: EmailSettingUpsertWithWhereUniqueWithoutSubscriptionTemplateInput | EmailSettingUpsertWithWhereUniqueWithoutSubscriptionTemplateInput[]
    createMany?: EmailSettingCreateManySubscriptionTemplateInputEnvelope
    set?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
    disconnect?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
    delete?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
    connect?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
    update?: EmailSettingUpdateWithWhereUniqueWithoutSubscriptionTemplateInput | EmailSettingUpdateWithWhereUniqueWithoutSubscriptionTemplateInput[]
    updateMany?: EmailSettingUpdateManyWithWhereWithoutSubscriptionTemplateInput | EmailSettingUpdateManyWithWhereWithoutSubscriptionTemplateInput[]
    deleteMany?: EmailSettingScalarWhereInput | EmailSettingScalarWhereInput[]
  }

  export type EmailSettingUpdateManyWithoutFreeEbookTemplateNestedInput = {
    create?: XOR<EmailSettingCreateWithoutFreeEbookTemplateInput, EmailSettingUncheckedCreateWithoutFreeEbookTemplateInput> | EmailSettingCreateWithoutFreeEbookTemplateInput[] | EmailSettingUncheckedCreateWithoutFreeEbookTemplateInput[]
    connectOrCreate?: EmailSettingCreateOrConnectWithoutFreeEbookTemplateInput | EmailSettingCreateOrConnectWithoutFreeEbookTemplateInput[]
    upsert?: EmailSettingUpsertWithWhereUniqueWithoutFreeEbookTemplateInput | EmailSettingUpsertWithWhereUniqueWithoutFreeEbookTemplateInput[]
    createMany?: EmailSettingCreateManyFreeEbookTemplateInputEnvelope
    set?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
    disconnect?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
    delete?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
    connect?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
    update?: EmailSettingUpdateWithWhereUniqueWithoutFreeEbookTemplateInput | EmailSettingUpdateWithWhereUniqueWithoutFreeEbookTemplateInput[]
    updateMany?: EmailSettingUpdateManyWithWhereWithoutFreeEbookTemplateInput | EmailSettingUpdateManyWithWhereWithoutFreeEbookTemplateInput[]
    deleteMany?: EmailSettingScalarWhereInput | EmailSettingScalarWhereInput[]
  }

  export type EmailSettingUpdateManyWithoutWebinarTemplateNestedInput = {
    create?: XOR<EmailSettingCreateWithoutWebinarTemplateInput, EmailSettingUncheckedCreateWithoutWebinarTemplateInput> | EmailSettingCreateWithoutWebinarTemplateInput[] | EmailSettingUncheckedCreateWithoutWebinarTemplateInput[]
    connectOrCreate?: EmailSettingCreateOrConnectWithoutWebinarTemplateInput | EmailSettingCreateOrConnectWithoutWebinarTemplateInput[]
    upsert?: EmailSettingUpsertWithWhereUniqueWithoutWebinarTemplateInput | EmailSettingUpsertWithWhereUniqueWithoutWebinarTemplateInput[]
    createMany?: EmailSettingCreateManyWebinarTemplateInputEnvelope
    set?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
    disconnect?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
    delete?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
    connect?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
    update?: EmailSettingUpdateWithWhereUniqueWithoutWebinarTemplateInput | EmailSettingUpdateWithWhereUniqueWithoutWebinarTemplateInput[]
    updateMany?: EmailSettingUpdateManyWithWhereWithoutWebinarTemplateInput | EmailSettingUpdateManyWithWhereWithoutWebinarTemplateInput[]
    deleteMany?: EmailSettingScalarWhereInput | EmailSettingScalarWhereInput[]
  }

  export type EmailSettingUncheckedUpdateManyWithoutSubscriptionTemplateNestedInput = {
    create?: XOR<EmailSettingCreateWithoutSubscriptionTemplateInput, EmailSettingUncheckedCreateWithoutSubscriptionTemplateInput> | EmailSettingCreateWithoutSubscriptionTemplateInput[] | EmailSettingUncheckedCreateWithoutSubscriptionTemplateInput[]
    connectOrCreate?: EmailSettingCreateOrConnectWithoutSubscriptionTemplateInput | EmailSettingCreateOrConnectWithoutSubscriptionTemplateInput[]
    upsert?: EmailSettingUpsertWithWhereUniqueWithoutSubscriptionTemplateInput | EmailSettingUpsertWithWhereUniqueWithoutSubscriptionTemplateInput[]
    createMany?: EmailSettingCreateManySubscriptionTemplateInputEnvelope
    set?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
    disconnect?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
    delete?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
    connect?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
    update?: EmailSettingUpdateWithWhereUniqueWithoutSubscriptionTemplateInput | EmailSettingUpdateWithWhereUniqueWithoutSubscriptionTemplateInput[]
    updateMany?: EmailSettingUpdateManyWithWhereWithoutSubscriptionTemplateInput | EmailSettingUpdateManyWithWhereWithoutSubscriptionTemplateInput[]
    deleteMany?: EmailSettingScalarWhereInput | EmailSettingScalarWhereInput[]
  }

  export type EmailSettingUncheckedUpdateManyWithoutFreeEbookTemplateNestedInput = {
    create?: XOR<EmailSettingCreateWithoutFreeEbookTemplateInput, EmailSettingUncheckedCreateWithoutFreeEbookTemplateInput> | EmailSettingCreateWithoutFreeEbookTemplateInput[] | EmailSettingUncheckedCreateWithoutFreeEbookTemplateInput[]
    connectOrCreate?: EmailSettingCreateOrConnectWithoutFreeEbookTemplateInput | EmailSettingCreateOrConnectWithoutFreeEbookTemplateInput[]
    upsert?: EmailSettingUpsertWithWhereUniqueWithoutFreeEbookTemplateInput | EmailSettingUpsertWithWhereUniqueWithoutFreeEbookTemplateInput[]
    createMany?: EmailSettingCreateManyFreeEbookTemplateInputEnvelope
    set?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
    disconnect?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
    delete?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
    connect?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
    update?: EmailSettingUpdateWithWhereUniqueWithoutFreeEbookTemplateInput | EmailSettingUpdateWithWhereUniqueWithoutFreeEbookTemplateInput[]
    updateMany?: EmailSettingUpdateManyWithWhereWithoutFreeEbookTemplateInput | EmailSettingUpdateManyWithWhereWithoutFreeEbookTemplateInput[]
    deleteMany?: EmailSettingScalarWhereInput | EmailSettingScalarWhereInput[]
  }

  export type EmailSettingUncheckedUpdateManyWithoutWebinarTemplateNestedInput = {
    create?: XOR<EmailSettingCreateWithoutWebinarTemplateInput, EmailSettingUncheckedCreateWithoutWebinarTemplateInput> | EmailSettingCreateWithoutWebinarTemplateInput[] | EmailSettingUncheckedCreateWithoutWebinarTemplateInput[]
    connectOrCreate?: EmailSettingCreateOrConnectWithoutWebinarTemplateInput | EmailSettingCreateOrConnectWithoutWebinarTemplateInput[]
    upsert?: EmailSettingUpsertWithWhereUniqueWithoutWebinarTemplateInput | EmailSettingUpsertWithWhereUniqueWithoutWebinarTemplateInput[]
    createMany?: EmailSettingCreateManyWebinarTemplateInputEnvelope
    set?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
    disconnect?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
    delete?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
    connect?: EmailSettingWhereUniqueInput | EmailSettingWhereUniqueInput[]
    update?: EmailSettingUpdateWithWhereUniqueWithoutWebinarTemplateInput | EmailSettingUpdateWithWhereUniqueWithoutWebinarTemplateInput[]
    updateMany?: EmailSettingUpdateManyWithWhereWithoutWebinarTemplateInput | EmailSettingUpdateManyWithWhereWithoutWebinarTemplateInput[]
    deleteMany?: EmailSettingScalarWhereInput | EmailSettingScalarWhereInput[]
  }

  export type EmailContactCreateNestedManyWithoutAudiencesInput = {
    create?: XOR<EmailContactCreateWithoutAudiencesInput, EmailContactUncheckedCreateWithoutAudiencesInput> | EmailContactCreateWithoutAudiencesInput[] | EmailContactUncheckedCreateWithoutAudiencesInput[]
    connectOrCreate?: EmailContactCreateOrConnectWithoutAudiencesInput | EmailContactCreateOrConnectWithoutAudiencesInput[]
    connect?: EmailContactWhereUniqueInput | EmailContactWhereUniqueInput[]
  }

  export type EmailSingleSendCreateNestedManyWithoutAudiencesInput = {
    create?: XOR<EmailSingleSendCreateWithoutAudiencesInput, EmailSingleSendUncheckedCreateWithoutAudiencesInput> | EmailSingleSendCreateWithoutAudiencesInput[] | EmailSingleSendUncheckedCreateWithoutAudiencesInput[]
    connectOrCreate?: EmailSingleSendCreateOrConnectWithoutAudiencesInput | EmailSingleSendCreateOrConnectWithoutAudiencesInput[]
    connect?: EmailSingleSendWhereUniqueInput | EmailSingleSendWhereUniqueInput[]
  }

  export type EmailContactUncheckedCreateNestedManyWithoutAudiencesInput = {
    create?: XOR<EmailContactCreateWithoutAudiencesInput, EmailContactUncheckedCreateWithoutAudiencesInput> | EmailContactCreateWithoutAudiencesInput[] | EmailContactUncheckedCreateWithoutAudiencesInput[]
    connectOrCreate?: EmailContactCreateOrConnectWithoutAudiencesInput | EmailContactCreateOrConnectWithoutAudiencesInput[]
    connect?: EmailContactWhereUniqueInput | EmailContactWhereUniqueInput[]
  }

  export type EmailSingleSendUncheckedCreateNestedManyWithoutAudiencesInput = {
    create?: XOR<EmailSingleSendCreateWithoutAudiencesInput, EmailSingleSendUncheckedCreateWithoutAudiencesInput> | EmailSingleSendCreateWithoutAudiencesInput[] | EmailSingleSendUncheckedCreateWithoutAudiencesInput[]
    connectOrCreate?: EmailSingleSendCreateOrConnectWithoutAudiencesInput | EmailSingleSendCreateOrConnectWithoutAudiencesInput[]
    connect?: EmailSingleSendWhereUniqueInput | EmailSingleSendWhereUniqueInput[]
  }

  export type EnumAudienceTypeFieldUpdateOperationsInput = {
    set?: $Enums.AudienceType
  }

  export type EmailContactUpdateManyWithoutAudiencesNestedInput = {
    create?: XOR<EmailContactCreateWithoutAudiencesInput, EmailContactUncheckedCreateWithoutAudiencesInput> | EmailContactCreateWithoutAudiencesInput[] | EmailContactUncheckedCreateWithoutAudiencesInput[]
    connectOrCreate?: EmailContactCreateOrConnectWithoutAudiencesInput | EmailContactCreateOrConnectWithoutAudiencesInput[]
    upsert?: EmailContactUpsertWithWhereUniqueWithoutAudiencesInput | EmailContactUpsertWithWhereUniqueWithoutAudiencesInput[]
    set?: EmailContactWhereUniqueInput | EmailContactWhereUniqueInput[]
    disconnect?: EmailContactWhereUniqueInput | EmailContactWhereUniqueInput[]
    delete?: EmailContactWhereUniqueInput | EmailContactWhereUniqueInput[]
    connect?: EmailContactWhereUniqueInput | EmailContactWhereUniqueInput[]
    update?: EmailContactUpdateWithWhereUniqueWithoutAudiencesInput | EmailContactUpdateWithWhereUniqueWithoutAudiencesInput[]
    updateMany?: EmailContactUpdateManyWithWhereWithoutAudiencesInput | EmailContactUpdateManyWithWhereWithoutAudiencesInput[]
    deleteMany?: EmailContactScalarWhereInput | EmailContactScalarWhereInput[]
  }

  export type EmailSingleSendUpdateManyWithoutAudiencesNestedInput = {
    create?: XOR<EmailSingleSendCreateWithoutAudiencesInput, EmailSingleSendUncheckedCreateWithoutAudiencesInput> | EmailSingleSendCreateWithoutAudiencesInput[] | EmailSingleSendUncheckedCreateWithoutAudiencesInput[]
    connectOrCreate?: EmailSingleSendCreateOrConnectWithoutAudiencesInput | EmailSingleSendCreateOrConnectWithoutAudiencesInput[]
    upsert?: EmailSingleSendUpsertWithWhereUniqueWithoutAudiencesInput | EmailSingleSendUpsertWithWhereUniqueWithoutAudiencesInput[]
    set?: EmailSingleSendWhereUniqueInput | EmailSingleSendWhereUniqueInput[]
    disconnect?: EmailSingleSendWhereUniqueInput | EmailSingleSendWhereUniqueInput[]
    delete?: EmailSingleSendWhereUniqueInput | EmailSingleSendWhereUniqueInput[]
    connect?: EmailSingleSendWhereUniqueInput | EmailSingleSendWhereUniqueInput[]
    update?: EmailSingleSendUpdateWithWhereUniqueWithoutAudiencesInput | EmailSingleSendUpdateWithWhereUniqueWithoutAudiencesInput[]
    updateMany?: EmailSingleSendUpdateManyWithWhereWithoutAudiencesInput | EmailSingleSendUpdateManyWithWhereWithoutAudiencesInput[]
    deleteMany?: EmailSingleSendScalarWhereInput | EmailSingleSendScalarWhereInput[]
  }

  export type EmailContactUncheckedUpdateManyWithoutAudiencesNestedInput = {
    create?: XOR<EmailContactCreateWithoutAudiencesInput, EmailContactUncheckedCreateWithoutAudiencesInput> | EmailContactCreateWithoutAudiencesInput[] | EmailContactUncheckedCreateWithoutAudiencesInput[]
    connectOrCreate?: EmailContactCreateOrConnectWithoutAudiencesInput | EmailContactCreateOrConnectWithoutAudiencesInput[]
    upsert?: EmailContactUpsertWithWhereUniqueWithoutAudiencesInput | EmailContactUpsertWithWhereUniqueWithoutAudiencesInput[]
    set?: EmailContactWhereUniqueInput | EmailContactWhereUniqueInput[]
    disconnect?: EmailContactWhereUniqueInput | EmailContactWhereUniqueInput[]
    delete?: EmailContactWhereUniqueInput | EmailContactWhereUniqueInput[]
    connect?: EmailContactWhereUniqueInput | EmailContactWhereUniqueInput[]
    update?: EmailContactUpdateWithWhereUniqueWithoutAudiencesInput | EmailContactUpdateWithWhereUniqueWithoutAudiencesInput[]
    updateMany?: EmailContactUpdateManyWithWhereWithoutAudiencesInput | EmailContactUpdateManyWithWhereWithoutAudiencesInput[]
    deleteMany?: EmailContactScalarWhereInput | EmailContactScalarWhereInput[]
  }

  export type EmailSingleSendUncheckedUpdateManyWithoutAudiencesNestedInput = {
    create?: XOR<EmailSingleSendCreateWithoutAudiencesInput, EmailSingleSendUncheckedCreateWithoutAudiencesInput> | EmailSingleSendCreateWithoutAudiencesInput[] | EmailSingleSendUncheckedCreateWithoutAudiencesInput[]
    connectOrCreate?: EmailSingleSendCreateOrConnectWithoutAudiencesInput | EmailSingleSendCreateOrConnectWithoutAudiencesInput[]
    upsert?: EmailSingleSendUpsertWithWhereUniqueWithoutAudiencesInput | EmailSingleSendUpsertWithWhereUniqueWithoutAudiencesInput[]
    set?: EmailSingleSendWhereUniqueInput | EmailSingleSendWhereUniqueInput[]
    disconnect?: EmailSingleSendWhereUniqueInput | EmailSingleSendWhereUniqueInput[]
    delete?: EmailSingleSendWhereUniqueInput | EmailSingleSendWhereUniqueInput[]
    connect?: EmailSingleSendWhereUniqueInput | EmailSingleSendWhereUniqueInput[]
    update?: EmailSingleSendUpdateWithWhereUniqueWithoutAudiencesInput | EmailSingleSendUpdateWithWhereUniqueWithoutAudiencesInput[]
    updateMany?: EmailSingleSendUpdateManyWithWhereWithoutAudiencesInput | EmailSingleSendUpdateManyWithWhereWithoutAudiencesInput[]
    deleteMany?: EmailSingleSendScalarWhereInput | EmailSingleSendScalarWhereInput[]
  }

  export type EmailAudienceCreateNestedManyWithoutContactsInput = {
    create?: XOR<EmailAudienceCreateWithoutContactsInput, EmailAudienceUncheckedCreateWithoutContactsInput> | EmailAudienceCreateWithoutContactsInput[] | EmailAudienceUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: EmailAudienceCreateOrConnectWithoutContactsInput | EmailAudienceCreateOrConnectWithoutContactsInput[]
    connect?: EmailAudienceWhereUniqueInput | EmailAudienceWhereUniqueInput[]
  }

  export type EmailContactInteractionCreateNestedManyWithoutContactInput = {
    create?: XOR<EmailContactInteractionCreateWithoutContactInput, EmailContactInteractionUncheckedCreateWithoutContactInput> | EmailContactInteractionCreateWithoutContactInput[] | EmailContactInteractionUncheckedCreateWithoutContactInput[]
    connectOrCreate?: EmailContactInteractionCreateOrConnectWithoutContactInput | EmailContactInteractionCreateOrConnectWithoutContactInput[]
    createMany?: EmailContactInteractionCreateManyContactInputEnvelope
    connect?: EmailContactInteractionWhereUniqueInput | EmailContactInteractionWhereUniqueInput[]
  }

  export type EmailSingleSendLogCreateNestedManyWithoutContactInput = {
    create?: XOR<EmailSingleSendLogCreateWithoutContactInput, EmailSingleSendLogUncheckedCreateWithoutContactInput> | EmailSingleSendLogCreateWithoutContactInput[] | EmailSingleSendLogUncheckedCreateWithoutContactInput[]
    connectOrCreate?: EmailSingleSendLogCreateOrConnectWithoutContactInput | EmailSingleSendLogCreateOrConnectWithoutContactInput[]
    createMany?: EmailSingleSendLogCreateManyContactInputEnvelope
    connect?: EmailSingleSendLogWhereUniqueInput | EmailSingleSendLogWhereUniqueInput[]
  }

  export type EmailAudienceUncheckedCreateNestedManyWithoutContactsInput = {
    create?: XOR<EmailAudienceCreateWithoutContactsInput, EmailAudienceUncheckedCreateWithoutContactsInput> | EmailAudienceCreateWithoutContactsInput[] | EmailAudienceUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: EmailAudienceCreateOrConnectWithoutContactsInput | EmailAudienceCreateOrConnectWithoutContactsInput[]
    connect?: EmailAudienceWhereUniqueInput | EmailAudienceWhereUniqueInput[]
  }

  export type EmailContactInteractionUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<EmailContactInteractionCreateWithoutContactInput, EmailContactInteractionUncheckedCreateWithoutContactInput> | EmailContactInteractionCreateWithoutContactInput[] | EmailContactInteractionUncheckedCreateWithoutContactInput[]
    connectOrCreate?: EmailContactInteractionCreateOrConnectWithoutContactInput | EmailContactInteractionCreateOrConnectWithoutContactInput[]
    createMany?: EmailContactInteractionCreateManyContactInputEnvelope
    connect?: EmailContactInteractionWhereUniqueInput | EmailContactInteractionWhereUniqueInput[]
  }

  export type EmailSingleSendLogUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<EmailSingleSendLogCreateWithoutContactInput, EmailSingleSendLogUncheckedCreateWithoutContactInput> | EmailSingleSendLogCreateWithoutContactInput[] | EmailSingleSendLogUncheckedCreateWithoutContactInput[]
    connectOrCreate?: EmailSingleSendLogCreateOrConnectWithoutContactInput | EmailSingleSendLogCreateOrConnectWithoutContactInput[]
    createMany?: EmailSingleSendLogCreateManyContactInputEnvelope
    connect?: EmailSingleSendLogWhereUniqueInput | EmailSingleSendLogWhereUniqueInput[]
  }

  export type EmailAudienceUpdateManyWithoutContactsNestedInput = {
    create?: XOR<EmailAudienceCreateWithoutContactsInput, EmailAudienceUncheckedCreateWithoutContactsInput> | EmailAudienceCreateWithoutContactsInput[] | EmailAudienceUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: EmailAudienceCreateOrConnectWithoutContactsInput | EmailAudienceCreateOrConnectWithoutContactsInput[]
    upsert?: EmailAudienceUpsertWithWhereUniqueWithoutContactsInput | EmailAudienceUpsertWithWhereUniqueWithoutContactsInput[]
    set?: EmailAudienceWhereUniqueInput | EmailAudienceWhereUniqueInput[]
    disconnect?: EmailAudienceWhereUniqueInput | EmailAudienceWhereUniqueInput[]
    delete?: EmailAudienceWhereUniqueInput | EmailAudienceWhereUniqueInput[]
    connect?: EmailAudienceWhereUniqueInput | EmailAudienceWhereUniqueInput[]
    update?: EmailAudienceUpdateWithWhereUniqueWithoutContactsInput | EmailAudienceUpdateWithWhereUniqueWithoutContactsInput[]
    updateMany?: EmailAudienceUpdateManyWithWhereWithoutContactsInput | EmailAudienceUpdateManyWithWhereWithoutContactsInput[]
    deleteMany?: EmailAudienceScalarWhereInput | EmailAudienceScalarWhereInput[]
  }

  export type EmailContactInteractionUpdateManyWithoutContactNestedInput = {
    create?: XOR<EmailContactInteractionCreateWithoutContactInput, EmailContactInteractionUncheckedCreateWithoutContactInput> | EmailContactInteractionCreateWithoutContactInput[] | EmailContactInteractionUncheckedCreateWithoutContactInput[]
    connectOrCreate?: EmailContactInteractionCreateOrConnectWithoutContactInput | EmailContactInteractionCreateOrConnectWithoutContactInput[]
    upsert?: EmailContactInteractionUpsertWithWhereUniqueWithoutContactInput | EmailContactInteractionUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: EmailContactInteractionCreateManyContactInputEnvelope
    set?: EmailContactInteractionWhereUniqueInput | EmailContactInteractionWhereUniqueInput[]
    disconnect?: EmailContactInteractionWhereUniqueInput | EmailContactInteractionWhereUniqueInput[]
    delete?: EmailContactInteractionWhereUniqueInput | EmailContactInteractionWhereUniqueInput[]
    connect?: EmailContactInteractionWhereUniqueInput | EmailContactInteractionWhereUniqueInput[]
    update?: EmailContactInteractionUpdateWithWhereUniqueWithoutContactInput | EmailContactInteractionUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: EmailContactInteractionUpdateManyWithWhereWithoutContactInput | EmailContactInteractionUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: EmailContactInteractionScalarWhereInput | EmailContactInteractionScalarWhereInput[]
  }

  export type EmailSingleSendLogUpdateManyWithoutContactNestedInput = {
    create?: XOR<EmailSingleSendLogCreateWithoutContactInput, EmailSingleSendLogUncheckedCreateWithoutContactInput> | EmailSingleSendLogCreateWithoutContactInput[] | EmailSingleSendLogUncheckedCreateWithoutContactInput[]
    connectOrCreate?: EmailSingleSendLogCreateOrConnectWithoutContactInput | EmailSingleSendLogCreateOrConnectWithoutContactInput[]
    upsert?: EmailSingleSendLogUpsertWithWhereUniqueWithoutContactInput | EmailSingleSendLogUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: EmailSingleSendLogCreateManyContactInputEnvelope
    set?: EmailSingleSendLogWhereUniqueInput | EmailSingleSendLogWhereUniqueInput[]
    disconnect?: EmailSingleSendLogWhereUniqueInput | EmailSingleSendLogWhereUniqueInput[]
    delete?: EmailSingleSendLogWhereUniqueInput | EmailSingleSendLogWhereUniqueInput[]
    connect?: EmailSingleSendLogWhereUniqueInput | EmailSingleSendLogWhereUniqueInput[]
    update?: EmailSingleSendLogUpdateWithWhereUniqueWithoutContactInput | EmailSingleSendLogUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: EmailSingleSendLogUpdateManyWithWhereWithoutContactInput | EmailSingleSendLogUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: EmailSingleSendLogScalarWhereInput | EmailSingleSendLogScalarWhereInput[]
  }

  export type EmailAudienceUncheckedUpdateManyWithoutContactsNestedInput = {
    create?: XOR<EmailAudienceCreateWithoutContactsInput, EmailAudienceUncheckedCreateWithoutContactsInput> | EmailAudienceCreateWithoutContactsInput[] | EmailAudienceUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: EmailAudienceCreateOrConnectWithoutContactsInput | EmailAudienceCreateOrConnectWithoutContactsInput[]
    upsert?: EmailAudienceUpsertWithWhereUniqueWithoutContactsInput | EmailAudienceUpsertWithWhereUniqueWithoutContactsInput[]
    set?: EmailAudienceWhereUniqueInput | EmailAudienceWhereUniqueInput[]
    disconnect?: EmailAudienceWhereUniqueInput | EmailAudienceWhereUniqueInput[]
    delete?: EmailAudienceWhereUniqueInput | EmailAudienceWhereUniqueInput[]
    connect?: EmailAudienceWhereUniqueInput | EmailAudienceWhereUniqueInput[]
    update?: EmailAudienceUpdateWithWhereUniqueWithoutContactsInput | EmailAudienceUpdateWithWhereUniqueWithoutContactsInput[]
    updateMany?: EmailAudienceUpdateManyWithWhereWithoutContactsInput | EmailAudienceUpdateManyWithWhereWithoutContactsInput[]
    deleteMany?: EmailAudienceScalarWhereInput | EmailAudienceScalarWhereInput[]
  }

  export type EmailContactInteractionUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<EmailContactInteractionCreateWithoutContactInput, EmailContactInteractionUncheckedCreateWithoutContactInput> | EmailContactInteractionCreateWithoutContactInput[] | EmailContactInteractionUncheckedCreateWithoutContactInput[]
    connectOrCreate?: EmailContactInteractionCreateOrConnectWithoutContactInput | EmailContactInteractionCreateOrConnectWithoutContactInput[]
    upsert?: EmailContactInteractionUpsertWithWhereUniqueWithoutContactInput | EmailContactInteractionUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: EmailContactInteractionCreateManyContactInputEnvelope
    set?: EmailContactInteractionWhereUniqueInput | EmailContactInteractionWhereUniqueInput[]
    disconnect?: EmailContactInteractionWhereUniqueInput | EmailContactInteractionWhereUniqueInput[]
    delete?: EmailContactInteractionWhereUniqueInput | EmailContactInteractionWhereUniqueInput[]
    connect?: EmailContactInteractionWhereUniqueInput | EmailContactInteractionWhereUniqueInput[]
    update?: EmailContactInteractionUpdateWithWhereUniqueWithoutContactInput | EmailContactInteractionUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: EmailContactInteractionUpdateManyWithWhereWithoutContactInput | EmailContactInteractionUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: EmailContactInteractionScalarWhereInput | EmailContactInteractionScalarWhereInput[]
  }

  export type EmailSingleSendLogUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<EmailSingleSendLogCreateWithoutContactInput, EmailSingleSendLogUncheckedCreateWithoutContactInput> | EmailSingleSendLogCreateWithoutContactInput[] | EmailSingleSendLogUncheckedCreateWithoutContactInput[]
    connectOrCreate?: EmailSingleSendLogCreateOrConnectWithoutContactInput | EmailSingleSendLogCreateOrConnectWithoutContactInput[]
    upsert?: EmailSingleSendLogUpsertWithWhereUniqueWithoutContactInput | EmailSingleSendLogUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: EmailSingleSendLogCreateManyContactInputEnvelope
    set?: EmailSingleSendLogWhereUniqueInput | EmailSingleSendLogWhereUniqueInput[]
    disconnect?: EmailSingleSendLogWhereUniqueInput | EmailSingleSendLogWhereUniqueInput[]
    delete?: EmailSingleSendLogWhereUniqueInput | EmailSingleSendLogWhereUniqueInput[]
    connect?: EmailSingleSendLogWhereUniqueInput | EmailSingleSendLogWhereUniqueInput[]
    update?: EmailSingleSendLogUpdateWithWhereUniqueWithoutContactInput | EmailSingleSendLogUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: EmailSingleSendLogUpdateManyWithWhereWithoutContactInput | EmailSingleSendLogUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: EmailSingleSendLogScalarWhereInput | EmailSingleSendLogScalarWhereInput[]
  }

  export type EmailContactCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<EmailContactCreateWithoutInteractionsInput, EmailContactUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: EmailContactCreateOrConnectWithoutInteractionsInput
    connect?: EmailContactWhereUniqueInput
  }

  export type EmailContactUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<EmailContactCreateWithoutInteractionsInput, EmailContactUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: EmailContactCreateOrConnectWithoutInteractionsInput
    upsert?: EmailContactUpsertWithoutInteractionsInput
    connect?: EmailContactWhereUniqueInput
    update?: XOR<XOR<EmailContactUpdateToOneWithWhereWithoutInteractionsInput, EmailContactUpdateWithoutInteractionsInput>, EmailContactUncheckedUpdateWithoutInteractionsInput>
  }

  export type EmailAudienceCreateNestedManyWithoutEmailSingleSendsInput = {
    create?: XOR<EmailAudienceCreateWithoutEmailSingleSendsInput, EmailAudienceUncheckedCreateWithoutEmailSingleSendsInput> | EmailAudienceCreateWithoutEmailSingleSendsInput[] | EmailAudienceUncheckedCreateWithoutEmailSingleSendsInput[]
    connectOrCreate?: EmailAudienceCreateOrConnectWithoutEmailSingleSendsInput | EmailAudienceCreateOrConnectWithoutEmailSingleSendsInput[]
    connect?: EmailAudienceWhereUniqueInput | EmailAudienceWhereUniqueInput[]
  }

  export type EmailSingleSendLogCreateNestedManyWithoutSingleSendInput = {
    create?: XOR<EmailSingleSendLogCreateWithoutSingleSendInput, EmailSingleSendLogUncheckedCreateWithoutSingleSendInput> | EmailSingleSendLogCreateWithoutSingleSendInput[] | EmailSingleSendLogUncheckedCreateWithoutSingleSendInput[]
    connectOrCreate?: EmailSingleSendLogCreateOrConnectWithoutSingleSendInput | EmailSingleSendLogCreateOrConnectWithoutSingleSendInput[]
    createMany?: EmailSingleSendLogCreateManySingleSendInputEnvelope
    connect?: EmailSingleSendLogWhereUniqueInput | EmailSingleSendLogWhereUniqueInput[]
  }

  export type EmailAudienceUncheckedCreateNestedManyWithoutEmailSingleSendsInput = {
    create?: XOR<EmailAudienceCreateWithoutEmailSingleSendsInput, EmailAudienceUncheckedCreateWithoutEmailSingleSendsInput> | EmailAudienceCreateWithoutEmailSingleSendsInput[] | EmailAudienceUncheckedCreateWithoutEmailSingleSendsInput[]
    connectOrCreate?: EmailAudienceCreateOrConnectWithoutEmailSingleSendsInput | EmailAudienceCreateOrConnectWithoutEmailSingleSendsInput[]
    connect?: EmailAudienceWhereUniqueInput | EmailAudienceWhereUniqueInput[]
  }

  export type EmailSingleSendLogUncheckedCreateNestedManyWithoutSingleSendInput = {
    create?: XOR<EmailSingleSendLogCreateWithoutSingleSendInput, EmailSingleSendLogUncheckedCreateWithoutSingleSendInput> | EmailSingleSendLogCreateWithoutSingleSendInput[] | EmailSingleSendLogUncheckedCreateWithoutSingleSendInput[]
    connectOrCreate?: EmailSingleSendLogCreateOrConnectWithoutSingleSendInput | EmailSingleSendLogCreateOrConnectWithoutSingleSendInput[]
    createMany?: EmailSingleSendLogCreateManySingleSendInputEnvelope
    connect?: EmailSingleSendLogWhereUniqueInput | EmailSingleSendLogWhereUniqueInput[]
  }

  export type EmailAudienceUpdateManyWithoutEmailSingleSendsNestedInput = {
    create?: XOR<EmailAudienceCreateWithoutEmailSingleSendsInput, EmailAudienceUncheckedCreateWithoutEmailSingleSendsInput> | EmailAudienceCreateWithoutEmailSingleSendsInput[] | EmailAudienceUncheckedCreateWithoutEmailSingleSendsInput[]
    connectOrCreate?: EmailAudienceCreateOrConnectWithoutEmailSingleSendsInput | EmailAudienceCreateOrConnectWithoutEmailSingleSendsInput[]
    upsert?: EmailAudienceUpsertWithWhereUniqueWithoutEmailSingleSendsInput | EmailAudienceUpsertWithWhereUniqueWithoutEmailSingleSendsInput[]
    set?: EmailAudienceWhereUniqueInput | EmailAudienceWhereUniqueInput[]
    disconnect?: EmailAudienceWhereUniqueInput | EmailAudienceWhereUniqueInput[]
    delete?: EmailAudienceWhereUniqueInput | EmailAudienceWhereUniqueInput[]
    connect?: EmailAudienceWhereUniqueInput | EmailAudienceWhereUniqueInput[]
    update?: EmailAudienceUpdateWithWhereUniqueWithoutEmailSingleSendsInput | EmailAudienceUpdateWithWhereUniqueWithoutEmailSingleSendsInput[]
    updateMany?: EmailAudienceUpdateManyWithWhereWithoutEmailSingleSendsInput | EmailAudienceUpdateManyWithWhereWithoutEmailSingleSendsInput[]
    deleteMany?: EmailAudienceScalarWhereInput | EmailAudienceScalarWhereInput[]
  }

  export type EmailSingleSendLogUpdateManyWithoutSingleSendNestedInput = {
    create?: XOR<EmailSingleSendLogCreateWithoutSingleSendInput, EmailSingleSendLogUncheckedCreateWithoutSingleSendInput> | EmailSingleSendLogCreateWithoutSingleSendInput[] | EmailSingleSendLogUncheckedCreateWithoutSingleSendInput[]
    connectOrCreate?: EmailSingleSendLogCreateOrConnectWithoutSingleSendInput | EmailSingleSendLogCreateOrConnectWithoutSingleSendInput[]
    upsert?: EmailSingleSendLogUpsertWithWhereUniqueWithoutSingleSendInput | EmailSingleSendLogUpsertWithWhereUniqueWithoutSingleSendInput[]
    createMany?: EmailSingleSendLogCreateManySingleSendInputEnvelope
    set?: EmailSingleSendLogWhereUniqueInput | EmailSingleSendLogWhereUniqueInput[]
    disconnect?: EmailSingleSendLogWhereUniqueInput | EmailSingleSendLogWhereUniqueInput[]
    delete?: EmailSingleSendLogWhereUniqueInput | EmailSingleSendLogWhereUniqueInput[]
    connect?: EmailSingleSendLogWhereUniqueInput | EmailSingleSendLogWhereUniqueInput[]
    update?: EmailSingleSendLogUpdateWithWhereUniqueWithoutSingleSendInput | EmailSingleSendLogUpdateWithWhereUniqueWithoutSingleSendInput[]
    updateMany?: EmailSingleSendLogUpdateManyWithWhereWithoutSingleSendInput | EmailSingleSendLogUpdateManyWithWhereWithoutSingleSendInput[]
    deleteMany?: EmailSingleSendLogScalarWhereInput | EmailSingleSendLogScalarWhereInput[]
  }

  export type EmailAudienceUncheckedUpdateManyWithoutEmailSingleSendsNestedInput = {
    create?: XOR<EmailAudienceCreateWithoutEmailSingleSendsInput, EmailAudienceUncheckedCreateWithoutEmailSingleSendsInput> | EmailAudienceCreateWithoutEmailSingleSendsInput[] | EmailAudienceUncheckedCreateWithoutEmailSingleSendsInput[]
    connectOrCreate?: EmailAudienceCreateOrConnectWithoutEmailSingleSendsInput | EmailAudienceCreateOrConnectWithoutEmailSingleSendsInput[]
    upsert?: EmailAudienceUpsertWithWhereUniqueWithoutEmailSingleSendsInput | EmailAudienceUpsertWithWhereUniqueWithoutEmailSingleSendsInput[]
    set?: EmailAudienceWhereUniqueInput | EmailAudienceWhereUniqueInput[]
    disconnect?: EmailAudienceWhereUniqueInput | EmailAudienceWhereUniqueInput[]
    delete?: EmailAudienceWhereUniqueInput | EmailAudienceWhereUniqueInput[]
    connect?: EmailAudienceWhereUniqueInput | EmailAudienceWhereUniqueInput[]
    update?: EmailAudienceUpdateWithWhereUniqueWithoutEmailSingleSendsInput | EmailAudienceUpdateWithWhereUniqueWithoutEmailSingleSendsInput[]
    updateMany?: EmailAudienceUpdateManyWithWhereWithoutEmailSingleSendsInput | EmailAudienceUpdateManyWithWhereWithoutEmailSingleSendsInput[]
    deleteMany?: EmailAudienceScalarWhereInput | EmailAudienceScalarWhereInput[]
  }

  export type EmailSingleSendLogUncheckedUpdateManyWithoutSingleSendNestedInput = {
    create?: XOR<EmailSingleSendLogCreateWithoutSingleSendInput, EmailSingleSendLogUncheckedCreateWithoutSingleSendInput> | EmailSingleSendLogCreateWithoutSingleSendInput[] | EmailSingleSendLogUncheckedCreateWithoutSingleSendInput[]
    connectOrCreate?: EmailSingleSendLogCreateOrConnectWithoutSingleSendInput | EmailSingleSendLogCreateOrConnectWithoutSingleSendInput[]
    upsert?: EmailSingleSendLogUpsertWithWhereUniqueWithoutSingleSendInput | EmailSingleSendLogUpsertWithWhereUniqueWithoutSingleSendInput[]
    createMany?: EmailSingleSendLogCreateManySingleSendInputEnvelope
    set?: EmailSingleSendLogWhereUniqueInput | EmailSingleSendLogWhereUniqueInput[]
    disconnect?: EmailSingleSendLogWhereUniqueInput | EmailSingleSendLogWhereUniqueInput[]
    delete?: EmailSingleSendLogWhereUniqueInput | EmailSingleSendLogWhereUniqueInput[]
    connect?: EmailSingleSendLogWhereUniqueInput | EmailSingleSendLogWhereUniqueInput[]
    update?: EmailSingleSendLogUpdateWithWhereUniqueWithoutSingleSendInput | EmailSingleSendLogUpdateWithWhereUniqueWithoutSingleSendInput[]
    updateMany?: EmailSingleSendLogUpdateManyWithWhereWithoutSingleSendInput | EmailSingleSendLogUpdateManyWithWhereWithoutSingleSendInput[]
    deleteMany?: EmailSingleSendLogScalarWhereInput | EmailSingleSendLogScalarWhereInput[]
  }

  export type EmailContactCreateNestedOneWithoutEmailSingleSendLogsInput = {
    create?: XOR<EmailContactCreateWithoutEmailSingleSendLogsInput, EmailContactUncheckedCreateWithoutEmailSingleSendLogsInput>
    connectOrCreate?: EmailContactCreateOrConnectWithoutEmailSingleSendLogsInput
    connect?: EmailContactWhereUniqueInput
  }

  export type EmailSingleSendCreateNestedOneWithoutEmailSingleSendLogsInput = {
    create?: XOR<EmailSingleSendCreateWithoutEmailSingleSendLogsInput, EmailSingleSendUncheckedCreateWithoutEmailSingleSendLogsInput>
    connectOrCreate?: EmailSingleSendCreateOrConnectWithoutEmailSingleSendLogsInput
    connect?: EmailSingleSendWhereUniqueInput
  }

  export type EmailContactUpdateOneRequiredWithoutEmailSingleSendLogsNestedInput = {
    create?: XOR<EmailContactCreateWithoutEmailSingleSendLogsInput, EmailContactUncheckedCreateWithoutEmailSingleSendLogsInput>
    connectOrCreate?: EmailContactCreateOrConnectWithoutEmailSingleSendLogsInput
    upsert?: EmailContactUpsertWithoutEmailSingleSendLogsInput
    connect?: EmailContactWhereUniqueInput
    update?: XOR<XOR<EmailContactUpdateToOneWithWhereWithoutEmailSingleSendLogsInput, EmailContactUpdateWithoutEmailSingleSendLogsInput>, EmailContactUncheckedUpdateWithoutEmailSingleSendLogsInput>
  }

  export type EmailSingleSendUpdateOneRequiredWithoutEmailSingleSendLogsNestedInput = {
    create?: XOR<EmailSingleSendCreateWithoutEmailSingleSendLogsInput, EmailSingleSendUncheckedCreateWithoutEmailSingleSendLogsInput>
    connectOrCreate?: EmailSingleSendCreateOrConnectWithoutEmailSingleSendLogsInput
    upsert?: EmailSingleSendUpsertWithoutEmailSingleSendLogsInput
    connect?: EmailSingleSendWhereUniqueInput
    update?: XOR<XOR<EmailSingleSendUpdateToOneWithWhereWithoutEmailSingleSendLogsInput, EmailSingleSendUpdateWithoutEmailSingleSendLogsInput>, EmailSingleSendUncheckedUpdateWithoutEmailSingleSendLogsInput>
  }

  export type MediaCreateNestedOneWithoutProductInput = {
    create?: XOR<MediaCreateWithoutProductInput, MediaUncheckedCreateWithoutProductInput>
    connectOrCreate?: MediaCreateOrConnectWithoutProductInput
    connect?: MediaWhereUniqueInput
  }

  export type ProductCategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type ProductExtraCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductExtraCreateWithoutProductInput, ProductExtraUncheckedCreateWithoutProductInput> | ProductExtraCreateWithoutProductInput[] | ProductExtraUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductExtraCreateOrConnectWithoutProductInput | ProductExtraCreateOrConnectWithoutProductInput[]
    createMany?: ProductExtraCreateManyProductInputEnvelope
    connect?: ProductExtraWhereUniqueInput | ProductExtraWhereUniqueInput[]
  }

  export type FormCreateNestedOneWithoutProductsInput = {
    create?: XOR<FormCreateWithoutProductsInput, FormUncheckedCreateWithoutProductsInput>
    connectOrCreate?: FormCreateOrConnectWithoutProductsInput
    connect?: FormWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutRootChildrenInput = {
    create?: XOR<ProductCreateWithoutRootChildrenInput, ProductUncheckedCreateWithoutRootChildrenInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRootChildrenInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutRootInput = {
    create?: XOR<ProductCreateWithoutRootInput, ProductUncheckedCreateWithoutRootInput> | ProductCreateWithoutRootInput[] | ProductUncheckedCreateWithoutRootInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutRootInput | ProductCreateOrConnectWithoutRootInput[]
    createMany?: ProductCreateManyRootInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductGalleryCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductGalleryCreateWithoutProductInput, ProductGalleryUncheckedCreateWithoutProductInput> | ProductGalleryCreateWithoutProductInput[] | ProductGalleryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductGalleryCreateOrConnectWithoutProductInput | ProductGalleryCreateOrConnectWithoutProductInput[]
    createMany?: ProductGalleryCreateManyProductInputEnvelope
    connect?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
  }

  export type ProductFAQCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductFAQCreateWithoutProductInput, ProductFAQUncheckedCreateWithoutProductInput> | ProductFAQCreateWithoutProductInput[] | ProductFAQUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductFAQCreateOrConnectWithoutProductInput | ProductFAQCreateOrConnectWithoutProductInput[]
    createMany?: ProductFAQCreateManyProductInputEnvelope
    connect?: ProductFAQWhereUniqueInput | ProductFAQWhereUniqueInput[]
  }

  export type PurchaseCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseCreateWithoutProductInput, PurchaseUncheckedCreateWithoutProductInput> | PurchaseCreateWithoutProductInput[] | PurchaseUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutProductInput | PurchaseCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseCreateManyProductInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type SeoCreateNestedOneWithoutProductsInput = {
    create?: XOR<SeoCreateWithoutProductsInput, SeoUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SeoCreateOrConnectWithoutProductsInput
    connect?: SeoWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProductsInput = {
    create?: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductExtraUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductExtraCreateWithoutProductInput, ProductExtraUncheckedCreateWithoutProductInput> | ProductExtraCreateWithoutProductInput[] | ProductExtraUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductExtraCreateOrConnectWithoutProductInput | ProductExtraCreateOrConnectWithoutProductInput[]
    createMany?: ProductExtraCreateManyProductInputEnvelope
    connect?: ProductExtraWhereUniqueInput | ProductExtraWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutRootInput = {
    create?: XOR<ProductCreateWithoutRootInput, ProductUncheckedCreateWithoutRootInput> | ProductCreateWithoutRootInput[] | ProductUncheckedCreateWithoutRootInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutRootInput | ProductCreateOrConnectWithoutRootInput[]
    createMany?: ProductCreateManyRootInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductGalleryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductGalleryCreateWithoutProductInput, ProductGalleryUncheckedCreateWithoutProductInput> | ProductGalleryCreateWithoutProductInput[] | ProductGalleryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductGalleryCreateOrConnectWithoutProductInput | ProductGalleryCreateOrConnectWithoutProductInput[]
    createMany?: ProductGalleryCreateManyProductInputEnvelope
    connect?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
  }

  export type ProductFAQUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductFAQCreateWithoutProductInput, ProductFAQUncheckedCreateWithoutProductInput> | ProductFAQCreateWithoutProductInput[] | ProductFAQUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductFAQCreateOrConnectWithoutProductInput | ProductFAQCreateOrConnectWithoutProductInput[]
    createMany?: ProductFAQCreateManyProductInputEnvelope
    connect?: ProductFAQWhereUniqueInput | ProductFAQWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseCreateWithoutProductInput, PurchaseUncheckedCreateWithoutProductInput> | PurchaseCreateWithoutProductInput[] | PurchaseUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutProductInput | PurchaseCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseCreateManyProductInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type EnumProductTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProductType
  }

  export type EnumProductAcquisitionModeFieldUpdateOperationsInput = {
    set?: $Enums.ProductAcquisitionMode
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MediaUpdateOneWithoutProductNestedInput = {
    create?: XOR<MediaCreateWithoutProductInput, MediaUncheckedCreateWithoutProductInput>
    connectOrCreate?: MediaCreateOrConnectWithoutProductInput
    upsert?: MediaUpsertWithoutProductInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutProductInput, MediaUpdateWithoutProductInput>, MediaUncheckedUpdateWithoutProductInput>
  }

  export type ProductCategoryUpdateOneWithoutProductsNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    upsert?: ProductCategoryUpsertWithoutProductsInput
    disconnect?: ProductCategoryWhereInput | boolean
    delete?: ProductCategoryWhereInput | boolean
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutProductsInput, ProductCategoryUpdateWithoutProductsInput>, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ProductExtraUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductExtraCreateWithoutProductInput, ProductExtraUncheckedCreateWithoutProductInput> | ProductExtraCreateWithoutProductInput[] | ProductExtraUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductExtraCreateOrConnectWithoutProductInput | ProductExtraCreateOrConnectWithoutProductInput[]
    upsert?: ProductExtraUpsertWithWhereUniqueWithoutProductInput | ProductExtraUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductExtraCreateManyProductInputEnvelope
    set?: ProductExtraWhereUniqueInput | ProductExtraWhereUniqueInput[]
    disconnect?: ProductExtraWhereUniqueInput | ProductExtraWhereUniqueInput[]
    delete?: ProductExtraWhereUniqueInput | ProductExtraWhereUniqueInput[]
    connect?: ProductExtraWhereUniqueInput | ProductExtraWhereUniqueInput[]
    update?: ProductExtraUpdateWithWhereUniqueWithoutProductInput | ProductExtraUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductExtraUpdateManyWithWhereWithoutProductInput | ProductExtraUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductExtraScalarWhereInput | ProductExtraScalarWhereInput[]
  }

  export type FormUpdateOneWithoutProductsNestedInput = {
    create?: XOR<FormCreateWithoutProductsInput, FormUncheckedCreateWithoutProductsInput>
    connectOrCreate?: FormCreateOrConnectWithoutProductsInput
    upsert?: FormUpsertWithoutProductsInput
    disconnect?: FormWhereInput | boolean
    delete?: FormWhereInput | boolean
    connect?: FormWhereUniqueInput
    update?: XOR<XOR<FormUpdateToOneWithWhereWithoutProductsInput, FormUpdateWithoutProductsInput>, FormUncheckedUpdateWithoutProductsInput>
  }

  export type ProductUpdateOneWithoutRootChildrenNestedInput = {
    create?: XOR<ProductCreateWithoutRootChildrenInput, ProductUncheckedCreateWithoutRootChildrenInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRootChildrenInput
    upsert?: ProductUpsertWithoutRootChildrenInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutRootChildrenInput, ProductUpdateWithoutRootChildrenInput>, ProductUncheckedUpdateWithoutRootChildrenInput>
  }

  export type ProductUpdateManyWithoutRootNestedInput = {
    create?: XOR<ProductCreateWithoutRootInput, ProductUncheckedCreateWithoutRootInput> | ProductCreateWithoutRootInput[] | ProductUncheckedCreateWithoutRootInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutRootInput | ProductCreateOrConnectWithoutRootInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutRootInput | ProductUpsertWithWhereUniqueWithoutRootInput[]
    createMany?: ProductCreateManyRootInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutRootInput | ProductUpdateWithWhereUniqueWithoutRootInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutRootInput | ProductUpdateManyWithWhereWithoutRootInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductGalleryUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductGalleryCreateWithoutProductInput, ProductGalleryUncheckedCreateWithoutProductInput> | ProductGalleryCreateWithoutProductInput[] | ProductGalleryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductGalleryCreateOrConnectWithoutProductInput | ProductGalleryCreateOrConnectWithoutProductInput[]
    upsert?: ProductGalleryUpsertWithWhereUniqueWithoutProductInput | ProductGalleryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductGalleryCreateManyProductInputEnvelope
    set?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
    disconnect?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
    delete?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
    connect?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
    update?: ProductGalleryUpdateWithWhereUniqueWithoutProductInput | ProductGalleryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductGalleryUpdateManyWithWhereWithoutProductInput | ProductGalleryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductGalleryScalarWhereInput | ProductGalleryScalarWhereInput[]
  }

  export type ProductFAQUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductFAQCreateWithoutProductInput, ProductFAQUncheckedCreateWithoutProductInput> | ProductFAQCreateWithoutProductInput[] | ProductFAQUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductFAQCreateOrConnectWithoutProductInput | ProductFAQCreateOrConnectWithoutProductInput[]
    upsert?: ProductFAQUpsertWithWhereUniqueWithoutProductInput | ProductFAQUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductFAQCreateManyProductInputEnvelope
    set?: ProductFAQWhereUniqueInput | ProductFAQWhereUniqueInput[]
    disconnect?: ProductFAQWhereUniqueInput | ProductFAQWhereUniqueInput[]
    delete?: ProductFAQWhereUniqueInput | ProductFAQWhereUniqueInput[]
    connect?: ProductFAQWhereUniqueInput | ProductFAQWhereUniqueInput[]
    update?: ProductFAQUpdateWithWhereUniqueWithoutProductInput | ProductFAQUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductFAQUpdateManyWithWhereWithoutProductInput | ProductFAQUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductFAQScalarWhereInput | ProductFAQScalarWhereInput[]
  }

  export type PurchaseUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseCreateWithoutProductInput, PurchaseUncheckedCreateWithoutProductInput> | PurchaseCreateWithoutProductInput[] | PurchaseUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutProductInput | PurchaseCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutProductInput | PurchaseUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseCreateManyProductInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutProductInput | PurchaseUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutProductInput | PurchaseUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type SeoUpdateOneWithoutProductsNestedInput = {
    create?: XOR<SeoCreateWithoutProductsInput, SeoUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SeoCreateOrConnectWithoutProductsInput
    upsert?: SeoUpsertWithoutProductsInput
    disconnect?: SeoWhereInput | boolean
    delete?: SeoWhereInput | boolean
    connect?: SeoWhereUniqueInput
    update?: XOR<XOR<SeoUpdateToOneWithWhereWithoutProductsInput, SeoUpdateWithoutProductsInput>, SeoUncheckedUpdateWithoutProductsInput>
  }

  export type UserUpdateOneWithoutProductsNestedInput = {
    create?: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductsInput
    upsert?: UserUpsertWithoutProductsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductsInput, UserUpdateWithoutProductsInput>, UserUncheckedUpdateWithoutProductsInput>
  }

  export type ProductExtraUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductExtraCreateWithoutProductInput, ProductExtraUncheckedCreateWithoutProductInput> | ProductExtraCreateWithoutProductInput[] | ProductExtraUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductExtraCreateOrConnectWithoutProductInput | ProductExtraCreateOrConnectWithoutProductInput[]
    upsert?: ProductExtraUpsertWithWhereUniqueWithoutProductInput | ProductExtraUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductExtraCreateManyProductInputEnvelope
    set?: ProductExtraWhereUniqueInput | ProductExtraWhereUniqueInput[]
    disconnect?: ProductExtraWhereUniqueInput | ProductExtraWhereUniqueInput[]
    delete?: ProductExtraWhereUniqueInput | ProductExtraWhereUniqueInput[]
    connect?: ProductExtraWhereUniqueInput | ProductExtraWhereUniqueInput[]
    update?: ProductExtraUpdateWithWhereUniqueWithoutProductInput | ProductExtraUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductExtraUpdateManyWithWhereWithoutProductInput | ProductExtraUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductExtraScalarWhereInput | ProductExtraScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutRootNestedInput = {
    create?: XOR<ProductCreateWithoutRootInput, ProductUncheckedCreateWithoutRootInput> | ProductCreateWithoutRootInput[] | ProductUncheckedCreateWithoutRootInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutRootInput | ProductCreateOrConnectWithoutRootInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutRootInput | ProductUpsertWithWhereUniqueWithoutRootInput[]
    createMany?: ProductCreateManyRootInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutRootInput | ProductUpdateWithWhereUniqueWithoutRootInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutRootInput | ProductUpdateManyWithWhereWithoutRootInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductGalleryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductGalleryCreateWithoutProductInput, ProductGalleryUncheckedCreateWithoutProductInput> | ProductGalleryCreateWithoutProductInput[] | ProductGalleryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductGalleryCreateOrConnectWithoutProductInput | ProductGalleryCreateOrConnectWithoutProductInput[]
    upsert?: ProductGalleryUpsertWithWhereUniqueWithoutProductInput | ProductGalleryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductGalleryCreateManyProductInputEnvelope
    set?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
    disconnect?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
    delete?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
    connect?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
    update?: ProductGalleryUpdateWithWhereUniqueWithoutProductInput | ProductGalleryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductGalleryUpdateManyWithWhereWithoutProductInput | ProductGalleryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductGalleryScalarWhereInput | ProductGalleryScalarWhereInput[]
  }

  export type ProductFAQUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductFAQCreateWithoutProductInput, ProductFAQUncheckedCreateWithoutProductInput> | ProductFAQCreateWithoutProductInput[] | ProductFAQUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductFAQCreateOrConnectWithoutProductInput | ProductFAQCreateOrConnectWithoutProductInput[]
    upsert?: ProductFAQUpsertWithWhereUniqueWithoutProductInput | ProductFAQUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductFAQCreateManyProductInputEnvelope
    set?: ProductFAQWhereUniqueInput | ProductFAQWhereUniqueInput[]
    disconnect?: ProductFAQWhereUniqueInput | ProductFAQWhereUniqueInput[]
    delete?: ProductFAQWhereUniqueInput | ProductFAQWhereUniqueInput[]
    connect?: ProductFAQWhereUniqueInput | ProductFAQWhereUniqueInput[]
    update?: ProductFAQUpdateWithWhereUniqueWithoutProductInput | ProductFAQUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductFAQUpdateManyWithWhereWithoutProductInput | ProductFAQUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductFAQScalarWhereInput | ProductFAQScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseCreateWithoutProductInput, PurchaseUncheckedCreateWithoutProductInput> | PurchaseCreateWithoutProductInput[] | PurchaseUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutProductInput | PurchaseCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutProductInput | PurchaseUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseCreateManyProductInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutProductInput | PurchaseUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutProductInput | PurchaseUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type ProductCategoryCreateNestedOneWithoutRootChildrenInput = {
    create?: XOR<ProductCategoryCreateWithoutRootChildrenInput, ProductCategoryUncheckedCreateWithoutRootChildrenInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutRootChildrenInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type ProductCategoryCreateNestedManyWithoutRootInput = {
    create?: XOR<ProductCategoryCreateWithoutRootInput, ProductCategoryUncheckedCreateWithoutRootInput> | ProductCategoryCreateWithoutRootInput[] | ProductCategoryUncheckedCreateWithoutRootInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutRootInput | ProductCategoryCreateOrConnectWithoutRootInput[]
    createMany?: ProductCategoryCreateManyRootInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SeoCreateNestedOneWithoutProductCategoriesInput = {
    create?: XOR<SeoCreateWithoutProductCategoriesInput, SeoUncheckedCreateWithoutProductCategoriesInput>
    connectOrCreate?: SeoCreateOrConnectWithoutProductCategoriesInput
    connect?: SeoWhereUniqueInput
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutRootInput = {
    create?: XOR<ProductCategoryCreateWithoutRootInput, ProductCategoryUncheckedCreateWithoutRootInput> | ProductCategoryCreateWithoutRootInput[] | ProductCategoryUncheckedCreateWithoutRootInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutRootInput | ProductCategoryCreateOrConnectWithoutRootInput[]
    createMany?: ProductCategoryCreateManyRootInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductCategoryUpdateOneWithoutRootChildrenNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutRootChildrenInput, ProductCategoryUncheckedCreateWithoutRootChildrenInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutRootChildrenInput
    upsert?: ProductCategoryUpsertWithoutRootChildrenInput
    disconnect?: ProductCategoryWhereInput | boolean
    delete?: ProductCategoryWhereInput | boolean
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutRootChildrenInput, ProductCategoryUpdateWithoutRootChildrenInput>, ProductCategoryUncheckedUpdateWithoutRootChildrenInput>
  }

  export type ProductCategoryUpdateManyWithoutRootNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutRootInput, ProductCategoryUncheckedCreateWithoutRootInput> | ProductCategoryCreateWithoutRootInput[] | ProductCategoryUncheckedCreateWithoutRootInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutRootInput | ProductCategoryCreateOrConnectWithoutRootInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutRootInput | ProductCategoryUpsertWithWhereUniqueWithoutRootInput[]
    createMany?: ProductCategoryCreateManyRootInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutRootInput | ProductCategoryUpdateWithWhereUniqueWithoutRootInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutRootInput | ProductCategoryUpdateManyWithWhereWithoutRootInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SeoUpdateOneWithoutProductCategoriesNestedInput = {
    create?: XOR<SeoCreateWithoutProductCategoriesInput, SeoUncheckedCreateWithoutProductCategoriesInput>
    connectOrCreate?: SeoCreateOrConnectWithoutProductCategoriesInput
    upsert?: SeoUpsertWithoutProductCategoriesInput
    disconnect?: SeoWhereInput | boolean
    delete?: SeoWhereInput | boolean
    connect?: SeoWhereUniqueInput
    update?: XOR<XOR<SeoUpdateToOneWithWhereWithoutProductCategoriesInput, SeoUpdateWithoutProductCategoriesInput>, SeoUncheckedUpdateWithoutProductCategoriesInput>
  }

  export type ProductCategoryUncheckedUpdateManyWithoutRootNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutRootInput, ProductCategoryUncheckedCreateWithoutRootInput> | ProductCategoryCreateWithoutRootInput[] | ProductCategoryUncheckedCreateWithoutRootInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutRootInput | ProductCategoryCreateOrConnectWithoutRootInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutRootInput | ProductCategoryUpsertWithWhereUniqueWithoutRootInput[]
    createMany?: ProductCategoryCreateManyRootInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutRootInput | ProductCategoryUpdateWithWhereUniqueWithoutRootInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutRootInput | ProductCategoryUpdateManyWithWhereWithoutRootInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutGalleryInput = {
    create?: XOR<ProductCreateWithoutGalleryInput, ProductUncheckedCreateWithoutGalleryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutGalleryInput
    connect?: ProductWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutProductsInput = {
    create?: XOR<MediaCreateWithoutProductsInput, MediaUncheckedCreateWithoutProductsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutProductsInput
    connect?: MediaWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutGalleryNestedInput = {
    create?: XOR<ProductCreateWithoutGalleryInput, ProductUncheckedCreateWithoutGalleryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutGalleryInput
    upsert?: ProductUpsertWithoutGalleryInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutGalleryInput, ProductUpdateWithoutGalleryInput>, ProductUncheckedUpdateWithoutGalleryInput>
  }

  export type MediaUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<MediaCreateWithoutProductsInput, MediaUncheckedCreateWithoutProductsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutProductsInput
    upsert?: MediaUpsertWithoutProductsInput
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutProductsInput, MediaUpdateWithoutProductsInput>, MediaUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCreateNestedOneWithoutExtrasInput = {
    create?: XOR<ProductCreateWithoutExtrasInput, ProductUncheckedCreateWithoutExtrasInput>
    connectOrCreate?: ProductCreateOrConnectWithoutExtrasInput
    connect?: ProductWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductUpdateOneRequiredWithoutExtrasNestedInput = {
    create?: XOR<ProductCreateWithoutExtrasInput, ProductUncheckedCreateWithoutExtrasInput>
    connectOrCreate?: ProductCreateOrConnectWithoutExtrasInput
    upsert?: ProductUpsertWithoutExtrasInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutExtrasInput, ProductUpdateWithoutExtrasInput>, ProductUncheckedUpdateWithoutExtrasInput>
  }

  export type ProductCreateNestedOneWithoutFaqsInput = {
    create?: XOR<ProductCreateWithoutFaqsInput, ProductUncheckedCreateWithoutFaqsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutFaqsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutFaqsNestedInput = {
    create?: XOR<ProductCreateWithoutFaqsInput, ProductUncheckedCreateWithoutFaqsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutFaqsInput
    upsert?: ProductUpsertWithoutFaqsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutFaqsInput, ProductUpdateWithoutFaqsInput>, ProductUncheckedUpdateWithoutFaqsInput>
  }

  export type AdBlockCreateNestedManyWithoutCampaignInput = {
    create?: XOR<AdBlockCreateWithoutCampaignInput, AdBlockUncheckedCreateWithoutCampaignInput> | AdBlockCreateWithoutCampaignInput[] | AdBlockUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: AdBlockCreateOrConnectWithoutCampaignInput | AdBlockCreateOrConnectWithoutCampaignInput[]
    createMany?: AdBlockCreateManyCampaignInputEnvelope
    connect?: AdBlockWhereUniqueInput | AdBlockWhereUniqueInput[]
  }

  export type AdBlockUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<AdBlockCreateWithoutCampaignInput, AdBlockUncheckedCreateWithoutCampaignInput> | AdBlockCreateWithoutCampaignInput[] | AdBlockUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: AdBlockCreateOrConnectWithoutCampaignInput | AdBlockCreateOrConnectWithoutCampaignInput[]
    createMany?: AdBlockCreateManyCampaignInputEnvelope
    connect?: AdBlockWhereUniqueInput | AdBlockWhereUniqueInput[]
  }

  export type AdBlockUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<AdBlockCreateWithoutCampaignInput, AdBlockUncheckedCreateWithoutCampaignInput> | AdBlockCreateWithoutCampaignInput[] | AdBlockUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: AdBlockCreateOrConnectWithoutCampaignInput | AdBlockCreateOrConnectWithoutCampaignInput[]
    upsert?: AdBlockUpsertWithWhereUniqueWithoutCampaignInput | AdBlockUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: AdBlockCreateManyCampaignInputEnvelope
    set?: AdBlockWhereUniqueInput | AdBlockWhereUniqueInput[]
    disconnect?: AdBlockWhereUniqueInput | AdBlockWhereUniqueInput[]
    delete?: AdBlockWhereUniqueInput | AdBlockWhereUniqueInput[]
    connect?: AdBlockWhereUniqueInput | AdBlockWhereUniqueInput[]
    update?: AdBlockUpdateWithWhereUniqueWithoutCampaignInput | AdBlockUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: AdBlockUpdateManyWithWhereWithoutCampaignInput | AdBlockUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: AdBlockScalarWhereInput | AdBlockScalarWhereInput[]
  }

  export type AdBlockUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<AdBlockCreateWithoutCampaignInput, AdBlockUncheckedCreateWithoutCampaignInput> | AdBlockCreateWithoutCampaignInput[] | AdBlockUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: AdBlockCreateOrConnectWithoutCampaignInput | AdBlockCreateOrConnectWithoutCampaignInput[]
    upsert?: AdBlockUpsertWithWhereUniqueWithoutCampaignInput | AdBlockUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: AdBlockCreateManyCampaignInputEnvelope
    set?: AdBlockWhereUniqueInput | AdBlockWhereUniqueInput[]
    disconnect?: AdBlockWhereUniqueInput | AdBlockWhereUniqueInput[]
    delete?: AdBlockWhereUniqueInput | AdBlockWhereUniqueInput[]
    connect?: AdBlockWhereUniqueInput | AdBlockWhereUniqueInput[]
    update?: AdBlockUpdateWithWhereUniqueWithoutCampaignInput | AdBlockUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: AdBlockUpdateManyWithWhereWithoutCampaignInput | AdBlockUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: AdBlockScalarWhereInput | AdBlockScalarWhereInput[]
  }

  export type AdBlockCreateexcludedPostIdsInput = {
    set: string[]
  }

  export type AdBlockCreateexcludedCategoryIdsInput = {
    set: string[]
  }

  export type AdBlockCreateexcludedTagIdsInput = {
    set: string[]
  }

  export type AdCampaignCreateNestedOneWithoutBlocksInput = {
    create?: XOR<AdCampaignCreateWithoutBlocksInput, AdCampaignUncheckedCreateWithoutBlocksInput>
    connectOrCreate?: AdCampaignCreateOrConnectWithoutBlocksInput
    connect?: AdCampaignWhereUniqueInput
  }

  export type AdItemCreateNestedManyWithoutAdBlockInput = {
    create?: XOR<AdItemCreateWithoutAdBlockInput, AdItemUncheckedCreateWithoutAdBlockInput> | AdItemCreateWithoutAdBlockInput[] | AdItemUncheckedCreateWithoutAdBlockInput[]
    connectOrCreate?: AdItemCreateOrConnectWithoutAdBlockInput | AdItemCreateOrConnectWithoutAdBlockInput[]
    createMany?: AdItemCreateManyAdBlockInputEnvelope
    connect?: AdItemWhereUniqueInput | AdItemWhereUniqueInput[]
  }

  export type AdItemUncheckedCreateNestedManyWithoutAdBlockInput = {
    create?: XOR<AdItemCreateWithoutAdBlockInput, AdItemUncheckedCreateWithoutAdBlockInput> | AdItemCreateWithoutAdBlockInput[] | AdItemUncheckedCreateWithoutAdBlockInput[]
    connectOrCreate?: AdItemCreateOrConnectWithoutAdBlockInput | AdItemCreateOrConnectWithoutAdBlockInput[]
    createMany?: AdItemCreateManyAdBlockInputEnvelope
    connect?: AdItemWhereUniqueInput | AdItemWhereUniqueInput[]
  }

  export type EnumAdLayoutTypeFieldUpdateOperationsInput = {
    set?: $Enums.AdLayoutType
  }

  export type EnumAdPositionPlacementFieldUpdateOperationsInput = {
    set?: $Enums.AdPositionPlacement
  }

  export type EnumAdPositionReferenceFieldUpdateOperationsInput = {
    set?: $Enums.AdPositionReference
  }

  export type AdBlockUpdateexcludedPostIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AdBlockUpdateexcludedCategoryIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AdBlockUpdateexcludedTagIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AdCampaignUpdateOneRequiredWithoutBlocksNestedInput = {
    create?: XOR<AdCampaignCreateWithoutBlocksInput, AdCampaignUncheckedCreateWithoutBlocksInput>
    connectOrCreate?: AdCampaignCreateOrConnectWithoutBlocksInput
    upsert?: AdCampaignUpsertWithoutBlocksInput
    connect?: AdCampaignWhereUniqueInput
    update?: XOR<XOR<AdCampaignUpdateToOneWithWhereWithoutBlocksInput, AdCampaignUpdateWithoutBlocksInput>, AdCampaignUncheckedUpdateWithoutBlocksInput>
  }

  export type AdItemUpdateManyWithoutAdBlockNestedInput = {
    create?: XOR<AdItemCreateWithoutAdBlockInput, AdItemUncheckedCreateWithoutAdBlockInput> | AdItemCreateWithoutAdBlockInput[] | AdItemUncheckedCreateWithoutAdBlockInput[]
    connectOrCreate?: AdItemCreateOrConnectWithoutAdBlockInput | AdItemCreateOrConnectWithoutAdBlockInput[]
    upsert?: AdItemUpsertWithWhereUniqueWithoutAdBlockInput | AdItemUpsertWithWhereUniqueWithoutAdBlockInput[]
    createMany?: AdItemCreateManyAdBlockInputEnvelope
    set?: AdItemWhereUniqueInput | AdItemWhereUniqueInput[]
    disconnect?: AdItemWhereUniqueInput | AdItemWhereUniqueInput[]
    delete?: AdItemWhereUniqueInput | AdItemWhereUniqueInput[]
    connect?: AdItemWhereUniqueInput | AdItemWhereUniqueInput[]
    update?: AdItemUpdateWithWhereUniqueWithoutAdBlockInput | AdItemUpdateWithWhereUniqueWithoutAdBlockInput[]
    updateMany?: AdItemUpdateManyWithWhereWithoutAdBlockInput | AdItemUpdateManyWithWhereWithoutAdBlockInput[]
    deleteMany?: AdItemScalarWhereInput | AdItemScalarWhereInput[]
  }

  export type AdItemUncheckedUpdateManyWithoutAdBlockNestedInput = {
    create?: XOR<AdItemCreateWithoutAdBlockInput, AdItemUncheckedCreateWithoutAdBlockInput> | AdItemCreateWithoutAdBlockInput[] | AdItemUncheckedCreateWithoutAdBlockInput[]
    connectOrCreate?: AdItemCreateOrConnectWithoutAdBlockInput | AdItemCreateOrConnectWithoutAdBlockInput[]
    upsert?: AdItemUpsertWithWhereUniqueWithoutAdBlockInput | AdItemUpsertWithWhereUniqueWithoutAdBlockInput[]
    createMany?: AdItemCreateManyAdBlockInputEnvelope
    set?: AdItemWhereUniqueInput | AdItemWhereUniqueInput[]
    disconnect?: AdItemWhereUniqueInput | AdItemWhereUniqueInput[]
    delete?: AdItemWhereUniqueInput | AdItemWhereUniqueInput[]
    connect?: AdItemWhereUniqueInput | AdItemWhereUniqueInput[]
    update?: AdItemUpdateWithWhereUniqueWithoutAdBlockInput | AdItemUpdateWithWhereUniqueWithoutAdBlockInput[]
    updateMany?: AdItemUpdateManyWithWhereWithoutAdBlockInput | AdItemUpdateManyWithWhereWithoutAdBlockInput[]
    deleteMany?: AdItemScalarWhereInput | AdItemScalarWhereInput[]
  }

  export type AdBlockCreateNestedOneWithoutItemsInput = {
    create?: XOR<AdBlockCreateWithoutItemsInput, AdBlockUncheckedCreateWithoutItemsInput>
    connectOrCreate?: AdBlockCreateOrConnectWithoutItemsInput
    connect?: AdBlockWhereUniqueInput
  }

  export type EnumAdItemSourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.AdItemSourceType
  }

  export type AdBlockUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<AdBlockCreateWithoutItemsInput, AdBlockUncheckedCreateWithoutItemsInput>
    connectOrCreate?: AdBlockCreateOrConnectWithoutItemsInput
    upsert?: AdBlockUpsertWithoutItemsInput
    connect?: AdBlockWhereUniqueInput
    update?: XOR<XOR<AdBlockUpdateToOneWithWhereWithoutItemsInput, AdBlockUpdateWithoutItemsInput>, AdBlockUncheckedUpdateWithoutItemsInput>
  }

  export type ProductCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<ProductCreateWithoutPurchasesInput, ProductUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchasesInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<ProductCreateWithoutPurchasesInput, ProductUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchasesInput
    upsert?: ProductUpsertWithoutPurchasesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPurchasesInput, ProductUpdateWithoutPurchasesInput>, ProductUncheckedUpdateWithoutPurchasesInput>
  }

  export type ProductCreateNestedManyWithoutFormInput = {
    create?: XOR<ProductCreateWithoutFormInput, ProductUncheckedCreateWithoutFormInput> | ProductCreateWithoutFormInput[] | ProductUncheckedCreateWithoutFormInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutFormInput | ProductCreateOrConnectWithoutFormInput[]
    createMany?: ProductCreateManyFormInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type FormSubmissionCreateNestedManyWithoutFormInput = {
    create?: XOR<FormSubmissionCreateWithoutFormInput, FormSubmissionUncheckedCreateWithoutFormInput> | FormSubmissionCreateWithoutFormInput[] | FormSubmissionUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutFormInput | FormSubmissionCreateOrConnectWithoutFormInput[]
    createMany?: FormSubmissionCreateManyFormInputEnvelope
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutFormInput = {
    create?: XOR<ProductCreateWithoutFormInput, ProductUncheckedCreateWithoutFormInput> | ProductCreateWithoutFormInput[] | ProductUncheckedCreateWithoutFormInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutFormInput | ProductCreateOrConnectWithoutFormInput[]
    createMany?: ProductCreateManyFormInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type FormSubmissionUncheckedCreateNestedManyWithoutFormInput = {
    create?: XOR<FormSubmissionCreateWithoutFormInput, FormSubmissionUncheckedCreateWithoutFormInput> | FormSubmissionCreateWithoutFormInput[] | FormSubmissionUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutFormInput | FormSubmissionCreateOrConnectWithoutFormInput[]
    createMany?: FormSubmissionCreateManyFormInputEnvelope
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutFormNestedInput = {
    create?: XOR<ProductCreateWithoutFormInput, ProductUncheckedCreateWithoutFormInput> | ProductCreateWithoutFormInput[] | ProductUncheckedCreateWithoutFormInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutFormInput | ProductCreateOrConnectWithoutFormInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutFormInput | ProductUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: ProductCreateManyFormInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutFormInput | ProductUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutFormInput | ProductUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type FormSubmissionUpdateManyWithoutFormNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutFormInput, FormSubmissionUncheckedCreateWithoutFormInput> | FormSubmissionCreateWithoutFormInput[] | FormSubmissionUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutFormInput | FormSubmissionCreateOrConnectWithoutFormInput[]
    upsert?: FormSubmissionUpsertWithWhereUniqueWithoutFormInput | FormSubmissionUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: FormSubmissionCreateManyFormInputEnvelope
    set?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    disconnect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    delete?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    update?: FormSubmissionUpdateWithWhereUniqueWithoutFormInput | FormSubmissionUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: FormSubmissionUpdateManyWithWhereWithoutFormInput | FormSubmissionUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutFormNestedInput = {
    create?: XOR<ProductCreateWithoutFormInput, ProductUncheckedCreateWithoutFormInput> | ProductCreateWithoutFormInput[] | ProductUncheckedCreateWithoutFormInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutFormInput | ProductCreateOrConnectWithoutFormInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutFormInput | ProductUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: ProductCreateManyFormInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutFormInput | ProductUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutFormInput | ProductUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type FormSubmissionUncheckedUpdateManyWithoutFormNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutFormInput, FormSubmissionUncheckedCreateWithoutFormInput> | FormSubmissionCreateWithoutFormInput[] | FormSubmissionUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutFormInput | FormSubmissionCreateOrConnectWithoutFormInput[]
    upsert?: FormSubmissionUpsertWithWhereUniqueWithoutFormInput | FormSubmissionUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: FormSubmissionCreateManyFormInputEnvelope
    set?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    disconnect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    delete?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    update?: FormSubmissionUpdateWithWhereUniqueWithoutFormInput | FormSubmissionUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: FormSubmissionUpdateManyWithWhereWithoutFormInput | FormSubmissionUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
  }

  export type FormCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<FormCreateWithoutSubmissionsInput, FormUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: FormCreateOrConnectWithoutSubmissionsInput
    connect?: FormWhereUniqueInput
  }

  export type FormUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<FormCreateWithoutSubmissionsInput, FormUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: FormCreateOrConnectWithoutSubmissionsInput
    upsert?: FormUpsertWithoutSubmissionsInput
    connect?: FormWhereUniqueInput
    update?: XOR<XOR<FormUpdateToOneWithWhereWithoutSubmissionsInput, FormUpdateWithoutSubmissionsInput>, FormUncheckedUpdateWithoutSubmissionsInput>
  }

  export type ImpressionCreateNestedManyWithoutFormatInput = {
    create?: XOR<ImpressionCreateWithoutFormatInput, ImpressionUncheckedCreateWithoutFormatInput> | ImpressionCreateWithoutFormatInput[] | ImpressionUncheckedCreateWithoutFormatInput[]
    connectOrCreate?: ImpressionCreateOrConnectWithoutFormatInput | ImpressionCreateOrConnectWithoutFormatInput[]
    createMany?: ImpressionCreateManyFormatInputEnvelope
    connect?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
  }

  export type ImpressionUncheckedCreateNestedManyWithoutFormatInput = {
    create?: XOR<ImpressionCreateWithoutFormatInput, ImpressionUncheckedCreateWithoutFormatInput> | ImpressionCreateWithoutFormatInput[] | ImpressionUncheckedCreateWithoutFormatInput[]
    connectOrCreate?: ImpressionCreateOrConnectWithoutFormatInput | ImpressionCreateOrConnectWithoutFormatInput[]
    createMany?: ImpressionCreateManyFormatInputEnvelope
    connect?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
  }

  export type ImpressionUpdateManyWithoutFormatNestedInput = {
    create?: XOR<ImpressionCreateWithoutFormatInput, ImpressionUncheckedCreateWithoutFormatInput> | ImpressionCreateWithoutFormatInput[] | ImpressionUncheckedCreateWithoutFormatInput[]
    connectOrCreate?: ImpressionCreateOrConnectWithoutFormatInput | ImpressionCreateOrConnectWithoutFormatInput[]
    upsert?: ImpressionUpsertWithWhereUniqueWithoutFormatInput | ImpressionUpsertWithWhereUniqueWithoutFormatInput[]
    createMany?: ImpressionCreateManyFormatInputEnvelope
    set?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
    disconnect?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
    delete?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
    connect?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
    update?: ImpressionUpdateWithWhereUniqueWithoutFormatInput | ImpressionUpdateWithWhereUniqueWithoutFormatInput[]
    updateMany?: ImpressionUpdateManyWithWhereWithoutFormatInput | ImpressionUpdateManyWithWhereWithoutFormatInput[]
    deleteMany?: ImpressionScalarWhereInput | ImpressionScalarWhereInput[]
  }

  export type ImpressionUncheckedUpdateManyWithoutFormatNestedInput = {
    create?: XOR<ImpressionCreateWithoutFormatInput, ImpressionUncheckedCreateWithoutFormatInput> | ImpressionCreateWithoutFormatInput[] | ImpressionUncheckedCreateWithoutFormatInput[]
    connectOrCreate?: ImpressionCreateOrConnectWithoutFormatInput | ImpressionCreateOrConnectWithoutFormatInput[]
    upsert?: ImpressionUpsertWithWhereUniqueWithoutFormatInput | ImpressionUpsertWithWhereUniqueWithoutFormatInput[]
    createMany?: ImpressionCreateManyFormatInputEnvelope
    set?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
    disconnect?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
    delete?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
    connect?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
    update?: ImpressionUpdateWithWhereUniqueWithoutFormatInput | ImpressionUpdateWithWhereUniqueWithoutFormatInput[]
    updateMany?: ImpressionUpdateManyWithWhereWithoutFormatInput | ImpressionUpdateManyWithWhereWithoutFormatInput[]
    deleteMany?: ImpressionScalarWhereInput | ImpressionScalarWhereInput[]
  }

  export type ImpressionCreateNestedManyWithoutGenreInput = {
    create?: XOR<ImpressionCreateWithoutGenreInput, ImpressionUncheckedCreateWithoutGenreInput> | ImpressionCreateWithoutGenreInput[] | ImpressionUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: ImpressionCreateOrConnectWithoutGenreInput | ImpressionCreateOrConnectWithoutGenreInput[]
    createMany?: ImpressionCreateManyGenreInputEnvelope
    connect?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
  }

  export type ImpressionUncheckedCreateNestedManyWithoutGenreInput = {
    create?: XOR<ImpressionCreateWithoutGenreInput, ImpressionUncheckedCreateWithoutGenreInput> | ImpressionCreateWithoutGenreInput[] | ImpressionUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: ImpressionCreateOrConnectWithoutGenreInput | ImpressionCreateOrConnectWithoutGenreInput[]
    createMany?: ImpressionCreateManyGenreInputEnvelope
    connect?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
  }

  export type ImpressionUpdateManyWithoutGenreNestedInput = {
    create?: XOR<ImpressionCreateWithoutGenreInput, ImpressionUncheckedCreateWithoutGenreInput> | ImpressionCreateWithoutGenreInput[] | ImpressionUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: ImpressionCreateOrConnectWithoutGenreInput | ImpressionCreateOrConnectWithoutGenreInput[]
    upsert?: ImpressionUpsertWithWhereUniqueWithoutGenreInput | ImpressionUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: ImpressionCreateManyGenreInputEnvelope
    set?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
    disconnect?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
    delete?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
    connect?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
    update?: ImpressionUpdateWithWhereUniqueWithoutGenreInput | ImpressionUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: ImpressionUpdateManyWithWhereWithoutGenreInput | ImpressionUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: ImpressionScalarWhereInput | ImpressionScalarWhereInput[]
  }

  export type ImpressionUncheckedUpdateManyWithoutGenreNestedInput = {
    create?: XOR<ImpressionCreateWithoutGenreInput, ImpressionUncheckedCreateWithoutGenreInput> | ImpressionCreateWithoutGenreInput[] | ImpressionUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: ImpressionCreateOrConnectWithoutGenreInput | ImpressionCreateOrConnectWithoutGenreInput[]
    upsert?: ImpressionUpsertWithWhereUniqueWithoutGenreInput | ImpressionUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: ImpressionCreateManyGenreInputEnvelope
    set?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
    disconnect?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
    delete?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
    connect?: ImpressionWhereUniqueInput | ImpressionWhereUniqueInput[]
    update?: ImpressionUpdateWithWhereUniqueWithoutGenreInput | ImpressionUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: ImpressionUpdateManyWithWhereWithoutGenreInput | ImpressionUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: ImpressionScalarWhereInput | ImpressionScalarWhereInput[]
  }

  export type FormatCreateNestedOneWithoutImpressionInput = {
    create?: XOR<FormatCreateWithoutImpressionInput, FormatUncheckedCreateWithoutImpressionInput>
    connectOrCreate?: FormatCreateOrConnectWithoutImpressionInput
    connect?: FormatWhereUniqueInput
  }

  export type GenreCreateNestedOneWithoutImpressionInput = {
    create?: XOR<GenreCreateWithoutImpressionInput, GenreUncheckedCreateWithoutImpressionInput>
    connectOrCreate?: GenreCreateOrConnectWithoutImpressionInput
    connect?: GenreWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutImpressionInput = {
    create?: XOR<MediaCreateWithoutImpressionInput, MediaUncheckedCreateWithoutImpressionInput>
    connectOrCreate?: MediaCreateOrConnectWithoutImpressionInput
    connect?: MediaWhereUniqueInput
  }

  export type FormatUpdateOneWithoutImpressionNestedInput = {
    create?: XOR<FormatCreateWithoutImpressionInput, FormatUncheckedCreateWithoutImpressionInput>
    connectOrCreate?: FormatCreateOrConnectWithoutImpressionInput
    upsert?: FormatUpsertWithoutImpressionInput
    disconnect?: FormatWhereInput | boolean
    delete?: FormatWhereInput | boolean
    connect?: FormatWhereUniqueInput
    update?: XOR<XOR<FormatUpdateToOneWithWhereWithoutImpressionInput, FormatUpdateWithoutImpressionInput>, FormatUncheckedUpdateWithoutImpressionInput>
  }

  export type GenreUpdateOneWithoutImpressionNestedInput = {
    create?: XOR<GenreCreateWithoutImpressionInput, GenreUncheckedCreateWithoutImpressionInput>
    connectOrCreate?: GenreCreateOrConnectWithoutImpressionInput
    upsert?: GenreUpsertWithoutImpressionInput
    disconnect?: GenreWhereInput | boolean
    delete?: GenreWhereInput | boolean
    connect?: GenreWhereUniqueInput
    update?: XOR<XOR<GenreUpdateToOneWithWhereWithoutImpressionInput, GenreUpdateWithoutImpressionInput>, GenreUncheckedUpdateWithoutImpressionInput>
  }

  export type MediaUpdateOneWithoutImpressionNestedInput = {
    create?: XOR<MediaCreateWithoutImpressionInput, MediaUncheckedCreateWithoutImpressionInput>
    connectOrCreate?: MediaCreateOrConnectWithoutImpressionInput
    upsert?: MediaUpsertWithoutImpressionInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutImpressionInput, MediaUpdateWithoutImpressionInput>, MediaUncheckedUpdateWithoutImpressionInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type EnumSocialKeyFieldUpdateOperationsInput = {
    set?: $Enums.SocialKey
  }

  export type EnumSocialEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.SocialEntityType
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumWidgetSectionFilter<$PrismaModel = never> = {
    equals?: $Enums.WidgetSection | EnumWidgetSectionFieldRefInput<$PrismaModel>
    in?: $Enums.WidgetSection[] | ListEnumWidgetSectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.WidgetSection[] | ListEnumWidgetSectionFieldRefInput<$PrismaModel>
    not?: NestedEnumWidgetSectionFilter<$PrismaModel> | $Enums.WidgetSection
  }

  export type NestedEnumWidgetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WidgetType | EnumWidgetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WidgetType[] | ListEnumWidgetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WidgetType[] | ListEnumWidgetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWidgetTypeFilter<$PrismaModel> | $Enums.WidgetType
  }

  export type NestedEnumWidgetSectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WidgetSection | EnumWidgetSectionFieldRefInput<$PrismaModel>
    in?: $Enums.WidgetSection[] | ListEnumWidgetSectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.WidgetSection[] | ListEnumWidgetSectionFieldRefInput<$PrismaModel>
    not?: NestedEnumWidgetSectionWithAggregatesFilter<$PrismaModel> | $Enums.WidgetSection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWidgetSectionFilter<$PrismaModel>
    _max?: NestedEnumWidgetSectionFilter<$PrismaModel>
  }

  export type NestedEnumWidgetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WidgetType | EnumWidgetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WidgetType[] | ListEnumWidgetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WidgetType[] | ListEnumWidgetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWidgetTypeWithAggregatesFilter<$PrismaModel> | $Enums.WidgetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWidgetTypeFilter<$PrismaModel>
    _max?: NestedEnumWidgetTypeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type NestedEnumContentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContentStatusFilter<$PrismaModel> | $Enums.ContentStatus
  }

  export type NestedEnumEditorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EditorType | EnumEditorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EditorType[] | ListEnumEditorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EditorType[] | ListEnumEditorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEditorTypeFilter<$PrismaModel> | $Enums.EditorType
  }

  export type NestedEnumContentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentStatusFilter<$PrismaModel>
    _max?: NestedEnumContentStatusFilter<$PrismaModel>
  }

  export type NestedEnumEditorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EditorType | EnumEditorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EditorType[] | ListEnumEditorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EditorType[] | ListEnumEditorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEditorTypeWithAggregatesFilter<$PrismaModel> | $Enums.EditorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEditorTypeFilter<$PrismaModel>
    _max?: NestedEnumEditorTypeFilter<$PrismaModel>
  }

  export type NestedEnumEmailProviderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailProvider | EnumEmailProviderFieldRefInput<$PrismaModel> | null
    in?: $Enums.EmailProvider[] | ListEnumEmailProviderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EmailProvider[] | ListEnumEmailProviderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEmailProviderNullableFilter<$PrismaModel> | $Enums.EmailProvider | null
  }

  export type NestedEnumEmailProviderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailProvider | EnumEmailProviderFieldRefInput<$PrismaModel> | null
    in?: $Enums.EmailProvider[] | ListEnumEmailProviderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EmailProvider[] | ListEnumEmailProviderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEmailProviderNullableWithAggregatesFilter<$PrismaModel> | $Enums.EmailProvider | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEmailProviderNullableFilter<$PrismaModel>
    _max?: NestedEnumEmailProviderNullableFilter<$PrismaModel>
  }

  export type NestedEnumAudienceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AudienceType | EnumAudienceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AudienceType[] | ListEnumAudienceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AudienceType[] | ListEnumAudienceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAudienceTypeFilter<$PrismaModel> | $Enums.AudienceType
  }

  export type NestedEnumAudienceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AudienceType | EnumAudienceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AudienceType[] | ListEnumAudienceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AudienceType[] | ListEnumAudienceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAudienceTypeWithAggregatesFilter<$PrismaModel> | $Enums.AudienceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAudienceTypeFilter<$PrismaModel>
    _max?: NestedEnumAudienceTypeFilter<$PrismaModel>
  }

  export type NestedEnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type NestedEnumProductAcquisitionModeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductAcquisitionMode | EnumProductAcquisitionModeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductAcquisitionMode[] | ListEnumProductAcquisitionModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductAcquisitionMode[] | ListEnumProductAcquisitionModeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductAcquisitionModeFilter<$PrismaModel> | $Enums.ProductAcquisitionMode
  }

  export type NestedEnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type NestedEnumProductAcquisitionModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductAcquisitionMode | EnumProductAcquisitionModeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductAcquisitionMode[] | ListEnumProductAcquisitionModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductAcquisitionMode[] | ListEnumProductAcquisitionModeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductAcquisitionModeWithAggregatesFilter<$PrismaModel> | $Enums.ProductAcquisitionMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductAcquisitionModeFilter<$PrismaModel>
    _max?: NestedEnumProductAcquisitionModeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumAdLayoutTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdLayoutType | EnumAdLayoutTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdLayoutType[] | ListEnumAdLayoutTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdLayoutType[] | ListEnumAdLayoutTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdLayoutTypeFilter<$PrismaModel> | $Enums.AdLayoutType
  }

  export type NestedEnumAdPositionPlacementFilter<$PrismaModel = never> = {
    equals?: $Enums.AdPositionPlacement | EnumAdPositionPlacementFieldRefInput<$PrismaModel>
    in?: $Enums.AdPositionPlacement[] | ListEnumAdPositionPlacementFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdPositionPlacement[] | ListEnumAdPositionPlacementFieldRefInput<$PrismaModel>
    not?: NestedEnumAdPositionPlacementFilter<$PrismaModel> | $Enums.AdPositionPlacement
  }

  export type NestedEnumAdPositionReferenceFilter<$PrismaModel = never> = {
    equals?: $Enums.AdPositionReference | EnumAdPositionReferenceFieldRefInput<$PrismaModel>
    in?: $Enums.AdPositionReference[] | ListEnumAdPositionReferenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdPositionReference[] | ListEnumAdPositionReferenceFieldRefInput<$PrismaModel>
    not?: NestedEnumAdPositionReferenceFilter<$PrismaModel> | $Enums.AdPositionReference
  }

  export type NestedEnumAdLayoutTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdLayoutType | EnumAdLayoutTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdLayoutType[] | ListEnumAdLayoutTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdLayoutType[] | ListEnumAdLayoutTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdLayoutTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdLayoutType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdLayoutTypeFilter<$PrismaModel>
    _max?: NestedEnumAdLayoutTypeFilter<$PrismaModel>
  }

  export type NestedEnumAdPositionPlacementWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdPositionPlacement | EnumAdPositionPlacementFieldRefInput<$PrismaModel>
    in?: $Enums.AdPositionPlacement[] | ListEnumAdPositionPlacementFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdPositionPlacement[] | ListEnumAdPositionPlacementFieldRefInput<$PrismaModel>
    not?: NestedEnumAdPositionPlacementWithAggregatesFilter<$PrismaModel> | $Enums.AdPositionPlacement
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdPositionPlacementFilter<$PrismaModel>
    _max?: NestedEnumAdPositionPlacementFilter<$PrismaModel>
  }

  export type NestedEnumAdPositionReferenceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdPositionReference | EnumAdPositionReferenceFieldRefInput<$PrismaModel>
    in?: $Enums.AdPositionReference[] | ListEnumAdPositionReferenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdPositionReference[] | ListEnumAdPositionReferenceFieldRefInput<$PrismaModel>
    not?: NestedEnumAdPositionReferenceWithAggregatesFilter<$PrismaModel> | $Enums.AdPositionReference
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdPositionReferenceFilter<$PrismaModel>
    _max?: NestedEnumAdPositionReferenceFilter<$PrismaModel>
  }

  export type NestedEnumAdItemSourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdItemSourceType | EnumAdItemSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdItemSourceType[] | ListEnumAdItemSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdItemSourceType[] | ListEnumAdItemSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdItemSourceTypeFilter<$PrismaModel> | $Enums.AdItemSourceType
  }

  export type NestedEnumAdItemSourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdItemSourceType | EnumAdItemSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdItemSourceType[] | ListEnumAdItemSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdItemSourceType[] | ListEnumAdItemSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdItemSourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdItemSourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdItemSourceTypeFilter<$PrismaModel>
    _max?: NestedEnumAdItemSourceTypeFilter<$PrismaModel>
  }

  export type NestedEnumSocialKeyFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialKey | EnumSocialKeyFieldRefInput<$PrismaModel>
    in?: $Enums.SocialKey[] | ListEnumSocialKeyFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialKey[] | ListEnumSocialKeyFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialKeyFilter<$PrismaModel> | $Enums.SocialKey
  }

  export type NestedEnumSocialEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialEntityType | EnumSocialEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SocialEntityType[] | ListEnumSocialEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialEntityType[] | ListEnumSocialEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialEntityTypeFilter<$PrismaModel> | $Enums.SocialEntityType
  }

  export type NestedEnumSocialKeyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialKey | EnumSocialKeyFieldRefInput<$PrismaModel>
    in?: $Enums.SocialKey[] | ListEnumSocialKeyFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialKey[] | ListEnumSocialKeyFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialKeyWithAggregatesFilter<$PrismaModel> | $Enums.SocialKey
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSocialKeyFilter<$PrismaModel>
    _max?: NestedEnumSocialKeyFilter<$PrismaModel>
  }

  export type NestedEnumSocialEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialEntityType | EnumSocialEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SocialEntityType[] | ListEnumSocialEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialEntityType[] | ListEnumSocialEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.SocialEntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSocialEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumSocialEntityTypeFilter<$PrismaModel>
  }

  export type SeoCreateWithoutSettingsInput = {
    id?: string
    title: string
    description?: string | null
    canonicalUrl?: string | null
    version: number
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: string | null
    ogTwitterTitle?: string | null
    ogTwitterDescription?: string | null
    ogTwitterLocale?: string | null
    ogTwitterUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ogTwitterImage?: MediaCreateNestedOneWithoutSeoInput
    root?: SeoCreateNestedOneWithoutRootChildrenInput
    rootChildren?: SeoCreateNestedManyWithoutRootInput
    posts?: PostCreateNestedManyWithoutSeoInput
    categories?: CategoryCreateNestedManyWithoutSeoInput
    tags?: TagCreateNestedManyWithoutSeoInput
    products?: ProductCreateNestedManyWithoutSeoInput
    productCategories?: ProductCategoryCreateNestedManyWithoutSeoInput
  }

  export type SeoUncheckedCreateWithoutSettingsInput = {
    id?: string
    title: string
    description?: string | null
    canonicalUrl?: string | null
    version: number
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: string | null
    ogTwitterTitle?: string | null
    ogTwitterDescription?: string | null
    ogTwitterImageId?: string | null
    ogTwitterLocale?: string | null
    ogTwitterUrl?: string | null
    rootId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: SeoUncheckedCreateNestedManyWithoutRootInput
    posts?: PostUncheckedCreateNestedManyWithoutSeoInput
    categories?: CategoryUncheckedCreateNestedManyWithoutSeoInput
    tags?: TagUncheckedCreateNestedManyWithoutSeoInput
    products?: ProductUncheckedCreateNestedManyWithoutSeoInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutSeoInput
  }

  export type SeoCreateOrConnectWithoutSettingsInput = {
    where: SeoWhereUniqueInput
    create: XOR<SeoCreateWithoutSettingsInput, SeoUncheckedCreateWithoutSettingsInput>
  }

  export type SeoUpsertWithoutSettingsInput = {
    update: XOR<SeoUpdateWithoutSettingsInput, SeoUncheckedUpdateWithoutSettingsInput>
    create: XOR<SeoCreateWithoutSettingsInput, SeoUncheckedCreateWithoutSettingsInput>
    where?: SeoWhereInput
  }

  export type SeoUpdateToOneWithWhereWithoutSettingsInput = {
    where?: SeoWhereInput
    data: XOR<SeoUpdateWithoutSettingsInput, SeoUncheckedUpdateWithoutSettingsInput>
  }

  export type SeoUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    ogTwitterType?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterLocale?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ogTwitterImage?: MediaUpdateOneWithoutSeoNestedInput
    root?: SeoUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: SeoUpdateManyWithoutRootNestedInput
    posts?: PostUpdateManyWithoutSeoNestedInput
    categories?: CategoryUpdateManyWithoutSeoNestedInput
    tags?: TagUpdateManyWithoutSeoNestedInput
    products?: ProductUpdateManyWithoutSeoNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutSeoNestedInput
  }

  export type SeoUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    ogTwitterType?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterImageId?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterLocale?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: SeoUncheckedUpdateManyWithoutRootNestedInput
    posts?: PostUncheckedUpdateManyWithoutSeoNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutSeoNestedInput
    tags?: TagUncheckedUpdateManyWithoutSeoNestedInput
    products?: ProductUncheckedUpdateManyWithoutSeoNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutSeoNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    bio?: string | null
    imageUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    profileImage?: MediaCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    postAuthors?: PostAuthorCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    profileImageId?: string | null
    bio?: string | null
    imageUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    postAuthors?: PostAuthorUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: MediaUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    postAuthors?: PostAuthorUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageId?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    postAuthors?: PostAuthorUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MediaCreateWithoutUserInput = {
    id?: string
    name: string
    key?: string | null
    url: string
    size?: number | null
    type?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    post?: PostCreateNestedManyWithoutImageCoverInput
    seo?: SeoCreateNestedManyWithoutOgTwitterImageInput
    product?: ProductCreateNestedManyWithoutImageCoverInput
    impression?: ImpressionCreateNestedOneWithoutFileInput
    products?: ProductGalleryCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    key?: string | null
    url: string
    size?: number | null
    type?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    post?: PostUncheckedCreateNestedManyWithoutImageCoverInput
    seo?: SeoUncheckedCreateNestedManyWithoutOgTwitterImageInput
    product?: ProductUncheckedCreateNestedManyWithoutImageCoverInput
    impression?: ImpressionUncheckedCreateNestedOneWithoutFileInput
    products?: ProductGalleryUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutUserInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutUserInput, MediaUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scope?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scope?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutUserInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    editorType?: $Enums.EditorType
    bodyData:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    root?: PostCreateNestedOneWithoutRootChildrenInput
    rootChildren?: PostCreateNestedManyWithoutRootInput
    imageCover?: MediaCreateNestedOneWithoutPostInput
    postCategories?: PostCategoryCreateNestedManyWithoutPostInput
    tags?: TagCreateNestedManyWithoutPostsInput
    seo?: SeoCreateNestedOneWithoutPostsInput
    postAuthors?: PostAuthorCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    editorType?: $Enums.EditorType
    bodyData:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: string | null
    imageCoverId?: string | null
    seoId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: PostUncheckedCreateNestedManyWithoutRootInput
    postCategories?: PostCategoryUncheckedCreateNestedManyWithoutPostInput
    tags?: TagUncheckedCreateNestedManyWithoutPostsInput
    postAuthors?: PostAuthorUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutUserInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostCreateManyUserInputEnvelope = {
    data: PostCreateManyUserInput | PostCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PostAuthorCreateWithoutUserInput = {
    sort: number
    post: PostCreateNestedOneWithoutPostAuthorsInput
  }

  export type PostAuthorUncheckedCreateWithoutUserInput = {
    postId: string
    sort: number
  }

  export type PostAuthorCreateOrConnectWithoutUserInput = {
    where: PostAuthorWhereUniqueInput
    create: XOR<PostAuthorCreateWithoutUserInput, PostAuthorUncheckedCreateWithoutUserInput>
  }

  export type PostAuthorCreateManyUserInputEnvelope = {
    data: PostAuthorCreateManyUserInput | PostAuthorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutUserInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: Date | string
    updatedAt?: Date | string
    imageCover?: MediaCreateNestedOneWithoutProductInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    extras?: ProductExtraCreateNestedManyWithoutProductInput
    form?: FormCreateNestedOneWithoutProductsInput
    root?: ProductCreateNestedOneWithoutRootChildrenInput
    rootChildren?: ProductCreateNestedManyWithoutRootInput
    gallery?: ProductGalleryCreateNestedManyWithoutProductInput
    faqs?: ProductFAQCreateNestedManyWithoutProductInput
    purchases?: PurchaseCreateNestedManyWithoutProductInput
    seo?: SeoCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    imageCoverId?: string | null
    categoryId?: string | null
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: string | null
    rootId?: string | null
    seoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    extras?: ProductExtraUncheckedCreateNestedManyWithoutProductInput
    rootChildren?: ProductUncheckedCreateNestedManyWithoutRootInput
    gallery?: ProductGalleryUncheckedCreateNestedManyWithoutProductInput
    faqs?: ProductFAQUncheckedCreateNestedManyWithoutProductInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutUserInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput>
  }

  export type ProductCreateManyUserInputEnvelope = {
    data: ProductCreateManyUserInput | ProductCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MediaUpsertWithoutUserInput = {
    update: XOR<MediaUpdateWithoutUserInput, MediaUncheckedUpdateWithoutUserInput>
    create: XOR<MediaCreateWithoutUserInput, MediaUncheckedCreateWithoutUserInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutUserInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutUserInput, MediaUncheckedUpdateWithoutUserInput>
  }

  export type MediaUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateManyWithoutImageCoverNestedInput
    seo?: SeoUpdateManyWithoutOgTwitterImageNestedInput
    product?: ProductUpdateManyWithoutImageCoverNestedInput
    impression?: ImpressionUpdateOneWithoutFileNestedInput
    products?: ProductGalleryUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUncheckedUpdateManyWithoutImageCoverNestedInput
    seo?: SeoUncheckedUpdateManyWithoutOgTwitterImageNestedInput
    product?: ProductUncheckedUpdateManyWithoutImageCoverNestedInput
    impression?: ImpressionUncheckedUpdateOneWithoutFileNestedInput
    products?: ProductGalleryUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    scope?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
  }

  export type PostUpsertWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostUpdateWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
  }

  export type PostUpdateManyWithWhereWithoutUserInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutUserInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: StringFilter<"Post"> | string
    title?: StringFilter<"Post"> | string
    slug?: StringFilter<"Post"> | string
    description?: StringNullableFilter<"Post"> | string | null
    version?: IntFilter<"Post"> | number
    status?: EnumContentStatusFilter<"Post"> | $Enums.ContentStatus
    isLatest?: BoolFilter<"Post"> | boolean
    editorType?: EnumEditorTypeFilter<"Post"> | $Enums.EditorType
    bodyData?: JsonFilter<"Post">
    tiptapBodyData?: JsonNullableFilter<"Post">
    rootId?: StringNullableFilter<"Post"> | string | null
    imageCoverId?: StringNullableFilter<"Post"> | string | null
    seoId?: StringNullableFilter<"Post"> | string | null
    userId?: StringNullableFilter<"Post"> | string | null
    firstPublishedAt?: DateTimeFilter<"Post"> | Date | string
    publishedAt?: DateTimeFilter<"Post"> | Date | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
  }

  export type PostAuthorUpsertWithWhereUniqueWithoutUserInput = {
    where: PostAuthorWhereUniqueInput
    update: XOR<PostAuthorUpdateWithoutUserInput, PostAuthorUncheckedUpdateWithoutUserInput>
    create: XOR<PostAuthorCreateWithoutUserInput, PostAuthorUncheckedCreateWithoutUserInput>
  }

  export type PostAuthorUpdateWithWhereUniqueWithoutUserInput = {
    where: PostAuthorWhereUniqueInput
    data: XOR<PostAuthorUpdateWithoutUserInput, PostAuthorUncheckedUpdateWithoutUserInput>
  }

  export type PostAuthorUpdateManyWithWhereWithoutUserInput = {
    where: PostAuthorScalarWhereInput
    data: XOR<PostAuthorUpdateManyMutationInput, PostAuthorUncheckedUpdateManyWithoutUserInput>
  }

  export type PostAuthorScalarWhereInput = {
    AND?: PostAuthorScalarWhereInput | PostAuthorScalarWhereInput[]
    OR?: PostAuthorScalarWhereInput[]
    NOT?: PostAuthorScalarWhereInput | PostAuthorScalarWhereInput[]
    postId?: StringFilter<"PostAuthor"> | string
    userId?: StringFilter<"PostAuthor"> | string
    sort?: IntFilter<"PostAuthor"> | number
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutUserInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutUserInput, ProductUncheckedUpdateWithoutUserInput>
    create: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutUserInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutUserInput, ProductUncheckedUpdateWithoutUserInput>
  }

  export type ProductUpdateManyWithWhereWithoutUserInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutUserInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    title?: StringFilter<"Product"> | string
    slug?: StringFilter<"Product"> | string
    description?: JsonFilter<"Product">
    tiptapDescription?: JsonNullableFilter<"Product">
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    version?: IntFilter<"Product"> | number
    status?: EnumContentStatusFilter<"Product"> | $Enums.ContentStatus
    isLatest?: BoolFilter<"Product"> | boolean
    imageCoverId?: StringNullableFilter<"Product"> | string | null
    categoryId?: StringNullableFilter<"Product"> | string | null
    acquisitionMode?: EnumProductAcquisitionModeFilter<"Product"> | $Enums.ProductAcquisitionMode
    price?: FloatNullableFilter<"Product"> | number | null
    discountedPrice?: FloatNullableFilter<"Product"> | number | null
    isFree?: BoolFilter<"Product"> | boolean
    metadata?: JsonNullableFilter<"Product">
    formId?: StringNullableFilter<"Product"> | string | null
    rootId?: StringNullableFilter<"Product"> | string | null
    seoId?: StringNullableFilter<"Product"> | string | null
    userId?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    bio?: string | null
    imageUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    profileImage?: MediaCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    postAuthors?: PostAuthorCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    profileImageId?: string | null
    bio?: string | null
    imageUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    postAuthors?: PostAuthorUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: MediaUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    postAuthors?: PostAuthorUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageId?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    postAuthors?: PostAuthorUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PostCreateWithoutImageCoverInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    editorType?: $Enums.EditorType
    bodyData:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    root?: PostCreateNestedOneWithoutRootChildrenInput
    rootChildren?: PostCreateNestedManyWithoutRootInput
    postCategories?: PostCategoryCreateNestedManyWithoutPostInput
    tags?: TagCreateNestedManyWithoutPostsInput
    seo?: SeoCreateNestedOneWithoutPostsInput
    postAuthors?: PostAuthorCreateNestedManyWithoutPostInput
    user?: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutImageCoverInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    editorType?: $Enums.EditorType
    bodyData:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: string | null
    seoId?: string | null
    userId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: PostUncheckedCreateNestedManyWithoutRootInput
    postCategories?: PostCategoryUncheckedCreateNestedManyWithoutPostInput
    tags?: TagUncheckedCreateNestedManyWithoutPostsInput
    postAuthors?: PostAuthorUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutImageCoverInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutImageCoverInput, PostUncheckedCreateWithoutImageCoverInput>
  }

  export type PostCreateManyImageCoverInputEnvelope = {
    data: PostCreateManyImageCoverInput | PostCreateManyImageCoverInput[]
    skipDuplicates?: boolean
  }

  export type SeoCreateWithoutOgTwitterImageInput = {
    id?: string
    title: string
    description?: string | null
    canonicalUrl?: string | null
    version: number
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: string | null
    ogTwitterTitle?: string | null
    ogTwitterDescription?: string | null
    ogTwitterLocale?: string | null
    ogTwitterUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    root?: SeoCreateNestedOneWithoutRootChildrenInput
    rootChildren?: SeoCreateNestedManyWithoutRootInput
    settings?: SettingsCreateNestedManyWithoutSeoInput
    posts?: PostCreateNestedManyWithoutSeoInput
    categories?: CategoryCreateNestedManyWithoutSeoInput
    tags?: TagCreateNestedManyWithoutSeoInput
    products?: ProductCreateNestedManyWithoutSeoInput
    productCategories?: ProductCategoryCreateNestedManyWithoutSeoInput
  }

  export type SeoUncheckedCreateWithoutOgTwitterImageInput = {
    id?: string
    title: string
    description?: string | null
    canonicalUrl?: string | null
    version: number
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: string | null
    ogTwitterTitle?: string | null
    ogTwitterDescription?: string | null
    ogTwitterLocale?: string | null
    ogTwitterUrl?: string | null
    rootId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: SeoUncheckedCreateNestedManyWithoutRootInput
    settings?: SettingsUncheckedCreateNestedManyWithoutSeoInput
    posts?: PostUncheckedCreateNestedManyWithoutSeoInput
    categories?: CategoryUncheckedCreateNestedManyWithoutSeoInput
    tags?: TagUncheckedCreateNestedManyWithoutSeoInput
    products?: ProductUncheckedCreateNestedManyWithoutSeoInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutSeoInput
  }

  export type SeoCreateOrConnectWithoutOgTwitterImageInput = {
    where: SeoWhereUniqueInput
    create: XOR<SeoCreateWithoutOgTwitterImageInput, SeoUncheckedCreateWithoutOgTwitterImageInput>
  }

  export type SeoCreateManyOgTwitterImageInputEnvelope = {
    data: SeoCreateManyOgTwitterImageInput | SeoCreateManyOgTwitterImageInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutImageCoverInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    extras?: ProductExtraCreateNestedManyWithoutProductInput
    form?: FormCreateNestedOneWithoutProductsInput
    root?: ProductCreateNestedOneWithoutRootChildrenInput
    rootChildren?: ProductCreateNestedManyWithoutRootInput
    gallery?: ProductGalleryCreateNestedManyWithoutProductInput
    faqs?: ProductFAQCreateNestedManyWithoutProductInput
    purchases?: PurchaseCreateNestedManyWithoutProductInput
    seo?: SeoCreateNestedOneWithoutProductsInput
    user?: UserCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutImageCoverInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    categoryId?: string | null
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: string | null
    rootId?: string | null
    seoId?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    extras?: ProductExtraUncheckedCreateNestedManyWithoutProductInput
    rootChildren?: ProductUncheckedCreateNestedManyWithoutRootInput
    gallery?: ProductGalleryUncheckedCreateNestedManyWithoutProductInput
    faqs?: ProductFAQUncheckedCreateNestedManyWithoutProductInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutImageCoverInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutImageCoverInput, ProductUncheckedCreateWithoutImageCoverInput>
  }

  export type ProductCreateManyImageCoverInputEnvelope = {
    data: ProductCreateManyImageCoverInput | ProductCreateManyImageCoverInput[]
    skipDuplicates?: boolean
  }

  export type ImpressionCreateWithoutFileInput = {
    id?: string
    title: string
    firstName?: string | null
    lastName?: string | null
    email: string
    pageCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    format?: FormatCreateNestedOneWithoutImpressionInput
    genre?: GenreCreateNestedOneWithoutImpressionInput
  }

  export type ImpressionUncheckedCreateWithoutFileInput = {
    id?: string
    title: string
    firstName?: string | null
    lastName?: string | null
    email: string
    pageCount?: number | null
    formatId?: string | null
    genreId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImpressionCreateOrConnectWithoutFileInput = {
    where: ImpressionWhereUniqueInput
    create: XOR<ImpressionCreateWithoutFileInput, ImpressionUncheckedCreateWithoutFileInput>
  }

  export type ProductGalleryCreateWithoutMediaInput = {
    id?: string
    sort: number
    product: ProductCreateNestedOneWithoutGalleryInput
  }

  export type ProductGalleryUncheckedCreateWithoutMediaInput = {
    id?: string
    sort: number
    productId: string
  }

  export type ProductGalleryCreateOrConnectWithoutMediaInput = {
    where: ProductGalleryWhereUniqueInput
    create: XOR<ProductGalleryCreateWithoutMediaInput, ProductGalleryUncheckedCreateWithoutMediaInput>
  }

  export type ProductGalleryCreateManyMediaInputEnvelope = {
    data: ProductGalleryCreateManyMediaInput | ProductGalleryCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutProfileImageInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    bio?: string | null
    imageUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    postAuthors?: PostAuthorCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileImageInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    bio?: string | null
    imageUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    postAuthors?: PostAuthorUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileImageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileImageInput, UserUncheckedCreateWithoutProfileImageInput>
  }

  export type UserCreateManyProfileImageInputEnvelope = {
    data: UserCreateManyProfileImageInput | UserCreateManyProfileImageInput[]
    skipDuplicates?: boolean
  }

  export type PostUpsertWithWhereUniqueWithoutImageCoverInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutImageCoverInput, PostUncheckedUpdateWithoutImageCoverInput>
    create: XOR<PostCreateWithoutImageCoverInput, PostUncheckedCreateWithoutImageCoverInput>
  }

  export type PostUpdateWithWhereUniqueWithoutImageCoverInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutImageCoverInput, PostUncheckedUpdateWithoutImageCoverInput>
  }

  export type PostUpdateManyWithWhereWithoutImageCoverInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutImageCoverInput>
  }

  export type SeoUpsertWithWhereUniqueWithoutOgTwitterImageInput = {
    where: SeoWhereUniqueInput
    update: XOR<SeoUpdateWithoutOgTwitterImageInput, SeoUncheckedUpdateWithoutOgTwitterImageInput>
    create: XOR<SeoCreateWithoutOgTwitterImageInput, SeoUncheckedCreateWithoutOgTwitterImageInput>
  }

  export type SeoUpdateWithWhereUniqueWithoutOgTwitterImageInput = {
    where: SeoWhereUniqueInput
    data: XOR<SeoUpdateWithoutOgTwitterImageInput, SeoUncheckedUpdateWithoutOgTwitterImageInput>
  }

  export type SeoUpdateManyWithWhereWithoutOgTwitterImageInput = {
    where: SeoScalarWhereInput
    data: XOR<SeoUpdateManyMutationInput, SeoUncheckedUpdateManyWithoutOgTwitterImageInput>
  }

  export type SeoScalarWhereInput = {
    AND?: SeoScalarWhereInput | SeoScalarWhereInput[]
    OR?: SeoScalarWhereInput[]
    NOT?: SeoScalarWhereInput | SeoScalarWhereInput[]
    id?: StringFilter<"Seo"> | string
    title?: StringFilter<"Seo"> | string
    description?: StringNullableFilter<"Seo"> | string | null
    canonicalUrl?: StringNullableFilter<"Seo"> | string | null
    version?: IntFilter<"Seo"> | number
    noIndex?: BoolFilter<"Seo"> | boolean
    noFollow?: BoolFilter<"Seo"> | boolean
    ogTwitterType?: StringNullableFilter<"Seo"> | string | null
    ogTwitterTitle?: StringNullableFilter<"Seo"> | string | null
    ogTwitterDescription?: StringNullableFilter<"Seo"> | string | null
    ogTwitterImageId?: StringNullableFilter<"Seo"> | string | null
    ogTwitterLocale?: StringNullableFilter<"Seo"> | string | null
    ogTwitterUrl?: StringNullableFilter<"Seo"> | string | null
    rootId?: StringNullableFilter<"Seo"> | string | null
    createdAt?: DateTimeFilter<"Seo"> | Date | string
    updatedAt?: DateTimeFilter<"Seo"> | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutImageCoverInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutImageCoverInput, ProductUncheckedUpdateWithoutImageCoverInput>
    create: XOR<ProductCreateWithoutImageCoverInput, ProductUncheckedCreateWithoutImageCoverInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutImageCoverInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutImageCoverInput, ProductUncheckedUpdateWithoutImageCoverInput>
  }

  export type ProductUpdateManyWithWhereWithoutImageCoverInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutImageCoverInput>
  }

  export type ImpressionUpsertWithoutFileInput = {
    update: XOR<ImpressionUpdateWithoutFileInput, ImpressionUncheckedUpdateWithoutFileInput>
    create: XOR<ImpressionCreateWithoutFileInput, ImpressionUncheckedCreateWithoutFileInput>
    where?: ImpressionWhereInput
  }

  export type ImpressionUpdateToOneWithWhereWithoutFileInput = {
    where?: ImpressionWhereInput
    data: XOR<ImpressionUpdateWithoutFileInput, ImpressionUncheckedUpdateWithoutFileInput>
  }

  export type ImpressionUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    format?: FormatUpdateOneWithoutImpressionNestedInput
    genre?: GenreUpdateOneWithoutImpressionNestedInput
  }

  export type ImpressionUncheckedUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    formatId?: NullableStringFieldUpdateOperationsInput | string | null
    genreId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductGalleryUpsertWithWhereUniqueWithoutMediaInput = {
    where: ProductGalleryWhereUniqueInput
    update: XOR<ProductGalleryUpdateWithoutMediaInput, ProductGalleryUncheckedUpdateWithoutMediaInput>
    create: XOR<ProductGalleryCreateWithoutMediaInput, ProductGalleryUncheckedCreateWithoutMediaInput>
  }

  export type ProductGalleryUpdateWithWhereUniqueWithoutMediaInput = {
    where: ProductGalleryWhereUniqueInput
    data: XOR<ProductGalleryUpdateWithoutMediaInput, ProductGalleryUncheckedUpdateWithoutMediaInput>
  }

  export type ProductGalleryUpdateManyWithWhereWithoutMediaInput = {
    where: ProductGalleryScalarWhereInput
    data: XOR<ProductGalleryUpdateManyMutationInput, ProductGalleryUncheckedUpdateManyWithoutMediaInput>
  }

  export type ProductGalleryScalarWhereInput = {
    AND?: ProductGalleryScalarWhereInput | ProductGalleryScalarWhereInput[]
    OR?: ProductGalleryScalarWhereInput[]
    NOT?: ProductGalleryScalarWhereInput | ProductGalleryScalarWhereInput[]
    id?: StringFilter<"ProductGallery"> | string
    sort?: IntFilter<"ProductGallery"> | number
    productId?: StringFilter<"ProductGallery"> | string
    mediaId?: StringFilter<"ProductGallery"> | string
  }

  export type UserUpsertWithWhereUniqueWithoutProfileImageInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutProfileImageInput, UserUncheckedUpdateWithoutProfileImageInput>
    create: XOR<UserCreateWithoutProfileImageInput, UserUncheckedCreateWithoutProfileImageInput>
  }

  export type UserUpdateWithWhereUniqueWithoutProfileImageInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutProfileImageInput, UserUncheckedUpdateWithoutProfileImageInput>
  }

  export type UserUpdateManyWithWhereWithoutProfileImageInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutProfileImageInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    profileImageId?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    imageUrl?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type MediaCreateWithoutSeoInput = {
    id?: string
    name: string
    key?: string | null
    url: string
    size?: number | null
    type?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    post?: PostCreateNestedManyWithoutImageCoverInput
    product?: ProductCreateNestedManyWithoutImageCoverInput
    impression?: ImpressionCreateNestedOneWithoutFileInput
    products?: ProductGalleryCreateNestedManyWithoutMediaInput
    user?: UserCreateNestedManyWithoutProfileImageInput
  }

  export type MediaUncheckedCreateWithoutSeoInput = {
    id?: string
    name: string
    key?: string | null
    url: string
    size?: number | null
    type?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    post?: PostUncheckedCreateNestedManyWithoutImageCoverInput
    product?: ProductUncheckedCreateNestedManyWithoutImageCoverInput
    impression?: ImpressionUncheckedCreateNestedOneWithoutFileInput
    products?: ProductGalleryUncheckedCreateNestedManyWithoutMediaInput
    user?: UserUncheckedCreateNestedManyWithoutProfileImageInput
  }

  export type MediaCreateOrConnectWithoutSeoInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutSeoInput, MediaUncheckedCreateWithoutSeoInput>
  }

  export type SeoCreateWithoutRootChildrenInput = {
    id?: string
    title: string
    description?: string | null
    canonicalUrl?: string | null
    version: number
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: string | null
    ogTwitterTitle?: string | null
    ogTwitterDescription?: string | null
    ogTwitterLocale?: string | null
    ogTwitterUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ogTwitterImage?: MediaCreateNestedOneWithoutSeoInput
    root?: SeoCreateNestedOneWithoutRootChildrenInput
    settings?: SettingsCreateNestedManyWithoutSeoInput
    posts?: PostCreateNestedManyWithoutSeoInput
    categories?: CategoryCreateNestedManyWithoutSeoInput
    tags?: TagCreateNestedManyWithoutSeoInput
    products?: ProductCreateNestedManyWithoutSeoInput
    productCategories?: ProductCategoryCreateNestedManyWithoutSeoInput
  }

  export type SeoUncheckedCreateWithoutRootChildrenInput = {
    id?: string
    title: string
    description?: string | null
    canonicalUrl?: string | null
    version: number
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: string | null
    ogTwitterTitle?: string | null
    ogTwitterDescription?: string | null
    ogTwitterImageId?: string | null
    ogTwitterLocale?: string | null
    ogTwitterUrl?: string | null
    rootId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: SettingsUncheckedCreateNestedManyWithoutSeoInput
    posts?: PostUncheckedCreateNestedManyWithoutSeoInput
    categories?: CategoryUncheckedCreateNestedManyWithoutSeoInput
    tags?: TagUncheckedCreateNestedManyWithoutSeoInput
    products?: ProductUncheckedCreateNestedManyWithoutSeoInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutSeoInput
  }

  export type SeoCreateOrConnectWithoutRootChildrenInput = {
    where: SeoWhereUniqueInput
    create: XOR<SeoCreateWithoutRootChildrenInput, SeoUncheckedCreateWithoutRootChildrenInput>
  }

  export type SeoCreateWithoutRootInput = {
    id?: string
    title: string
    description?: string | null
    canonicalUrl?: string | null
    version: number
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: string | null
    ogTwitterTitle?: string | null
    ogTwitterDescription?: string | null
    ogTwitterLocale?: string | null
    ogTwitterUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ogTwitterImage?: MediaCreateNestedOneWithoutSeoInput
    rootChildren?: SeoCreateNestedManyWithoutRootInput
    settings?: SettingsCreateNestedManyWithoutSeoInput
    posts?: PostCreateNestedManyWithoutSeoInput
    categories?: CategoryCreateNestedManyWithoutSeoInput
    tags?: TagCreateNestedManyWithoutSeoInput
    products?: ProductCreateNestedManyWithoutSeoInput
    productCategories?: ProductCategoryCreateNestedManyWithoutSeoInput
  }

  export type SeoUncheckedCreateWithoutRootInput = {
    id?: string
    title: string
    description?: string | null
    canonicalUrl?: string | null
    version: number
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: string | null
    ogTwitterTitle?: string | null
    ogTwitterDescription?: string | null
    ogTwitterImageId?: string | null
    ogTwitterLocale?: string | null
    ogTwitterUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: SeoUncheckedCreateNestedManyWithoutRootInput
    settings?: SettingsUncheckedCreateNestedManyWithoutSeoInput
    posts?: PostUncheckedCreateNestedManyWithoutSeoInput
    categories?: CategoryUncheckedCreateNestedManyWithoutSeoInput
    tags?: TagUncheckedCreateNestedManyWithoutSeoInput
    products?: ProductUncheckedCreateNestedManyWithoutSeoInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutSeoInput
  }

  export type SeoCreateOrConnectWithoutRootInput = {
    where: SeoWhereUniqueInput
    create: XOR<SeoCreateWithoutRootInput, SeoUncheckedCreateWithoutRootInput>
  }

  export type SeoCreateManyRootInputEnvelope = {
    data: SeoCreateManyRootInput | SeoCreateManyRootInput[]
    skipDuplicates?: boolean
  }

  export type SettingsCreateWithoutSeoInput = {
    id?: string
    siteName?: string | null
    siteUrl?: string | null
    deployWebhookUrl?: string | null
    logoUrl?: string | null
    scripts?:PrismaJson.Scripts
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingsUncheckedCreateWithoutSeoInput = {
    id?: string
    siteName?: string | null
    siteUrl?: string | null
    deployWebhookUrl?: string | null
    logoUrl?: string | null
    scripts?:PrismaJson.Scripts
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingsCreateOrConnectWithoutSeoInput = {
    where: SettingsWhereUniqueInput
    create: XOR<SettingsCreateWithoutSeoInput, SettingsUncheckedCreateWithoutSeoInput>
  }

  export type SettingsCreateManySeoInputEnvelope = {
    data: SettingsCreateManySeoInput | SettingsCreateManySeoInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutSeoInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    editorType?: $Enums.EditorType
    bodyData:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    root?: PostCreateNestedOneWithoutRootChildrenInput
    rootChildren?: PostCreateNestedManyWithoutRootInput
    imageCover?: MediaCreateNestedOneWithoutPostInput
    postCategories?: PostCategoryCreateNestedManyWithoutPostInput
    tags?: TagCreateNestedManyWithoutPostsInput
    postAuthors?: PostAuthorCreateNestedManyWithoutPostInput
    user?: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutSeoInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    editorType?: $Enums.EditorType
    bodyData:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: string | null
    imageCoverId?: string | null
    userId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: PostUncheckedCreateNestedManyWithoutRootInput
    postCategories?: PostCategoryUncheckedCreateNestedManyWithoutPostInput
    tags?: TagUncheckedCreateNestedManyWithoutPostsInput
    postAuthors?: PostAuthorUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutSeoInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutSeoInput, PostUncheckedCreateWithoutSeoInput>
  }

  export type PostCreateManySeoInputEnvelope = {
    data: PostCreateManySeoInput | PostCreateManySeoInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutSeoInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    root?: CategoryCreateNestedOneWithoutRootChildrenInput
    rootChildren?: CategoryCreateNestedManyWithoutRootInput
    postCategories?: PostCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutSeoInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    rootId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: CategoryUncheckedCreateNestedManyWithoutRootInput
    postCategories?: PostCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutSeoInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutSeoInput, CategoryUncheckedCreateWithoutSeoInput>
  }

  export type CategoryCreateManySeoInputEnvelope = {
    data: CategoryCreateManySeoInput | CategoryCreateManySeoInput[]
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutSeoInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    root?: TagCreateNestedOneWithoutRootChildrenInput
    rootChildren?: TagCreateNestedManyWithoutRootInput
    posts?: PostCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutSeoInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    rootId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: TagUncheckedCreateNestedManyWithoutRootInput
    posts?: PostUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutSeoInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutSeoInput, TagUncheckedCreateWithoutSeoInput>
  }

  export type TagCreateManySeoInputEnvelope = {
    data: TagCreateManySeoInput | TagCreateManySeoInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutSeoInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: Date | string
    updatedAt?: Date | string
    imageCover?: MediaCreateNestedOneWithoutProductInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    extras?: ProductExtraCreateNestedManyWithoutProductInput
    form?: FormCreateNestedOneWithoutProductsInput
    root?: ProductCreateNestedOneWithoutRootChildrenInput
    rootChildren?: ProductCreateNestedManyWithoutRootInput
    gallery?: ProductGalleryCreateNestedManyWithoutProductInput
    faqs?: ProductFAQCreateNestedManyWithoutProductInput
    purchases?: PurchaseCreateNestedManyWithoutProductInput
    user?: UserCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutSeoInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    imageCoverId?: string | null
    categoryId?: string | null
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: string | null
    rootId?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    extras?: ProductExtraUncheckedCreateNestedManyWithoutProductInput
    rootChildren?: ProductUncheckedCreateNestedManyWithoutRootInput
    gallery?: ProductGalleryUncheckedCreateNestedManyWithoutProductInput
    faqs?: ProductFAQUncheckedCreateNestedManyWithoutProductInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSeoInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSeoInput, ProductUncheckedCreateWithoutSeoInput>
  }

  export type ProductCreateManySeoInputEnvelope = {
    data: ProductCreateManySeoInput | ProductCreateManySeoInput[]
    skipDuplicates?: boolean
  }

  export type ProductCategoryCreateWithoutSeoInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    root?: ProductCategoryCreateNestedOneWithoutRootChildrenInput
    rootChildren?: ProductCategoryCreateNestedManyWithoutRootInput
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutSeoInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    rootId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: ProductCategoryUncheckedCreateNestedManyWithoutRootInput
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutSeoInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutSeoInput, ProductCategoryUncheckedCreateWithoutSeoInput>
  }

  export type ProductCategoryCreateManySeoInputEnvelope = {
    data: ProductCategoryCreateManySeoInput | ProductCategoryCreateManySeoInput[]
    skipDuplicates?: boolean
  }

  export type MediaUpsertWithoutSeoInput = {
    update: XOR<MediaUpdateWithoutSeoInput, MediaUncheckedUpdateWithoutSeoInput>
    create: XOR<MediaCreateWithoutSeoInput, MediaUncheckedCreateWithoutSeoInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutSeoInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutSeoInput, MediaUncheckedUpdateWithoutSeoInput>
  }

  export type MediaUpdateWithoutSeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateManyWithoutImageCoverNestedInput
    product?: ProductUpdateManyWithoutImageCoverNestedInput
    impression?: ImpressionUpdateOneWithoutFileNestedInput
    products?: ProductGalleryUpdateManyWithoutMediaNestedInput
    user?: UserUpdateManyWithoutProfileImageNestedInput
  }

  export type MediaUncheckedUpdateWithoutSeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUncheckedUpdateManyWithoutImageCoverNestedInput
    product?: ProductUncheckedUpdateManyWithoutImageCoverNestedInput
    impression?: ImpressionUncheckedUpdateOneWithoutFileNestedInput
    products?: ProductGalleryUncheckedUpdateManyWithoutMediaNestedInput
    user?: UserUncheckedUpdateManyWithoutProfileImageNestedInput
  }

  export type SeoUpsertWithoutRootChildrenInput = {
    update: XOR<SeoUpdateWithoutRootChildrenInput, SeoUncheckedUpdateWithoutRootChildrenInput>
    create: XOR<SeoCreateWithoutRootChildrenInput, SeoUncheckedCreateWithoutRootChildrenInput>
    where?: SeoWhereInput
  }

  export type SeoUpdateToOneWithWhereWithoutRootChildrenInput = {
    where?: SeoWhereInput
    data: XOR<SeoUpdateWithoutRootChildrenInput, SeoUncheckedUpdateWithoutRootChildrenInput>
  }

  export type SeoUpdateWithoutRootChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    ogTwitterType?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterLocale?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ogTwitterImage?: MediaUpdateOneWithoutSeoNestedInput
    root?: SeoUpdateOneWithoutRootChildrenNestedInput
    settings?: SettingsUpdateManyWithoutSeoNestedInput
    posts?: PostUpdateManyWithoutSeoNestedInput
    categories?: CategoryUpdateManyWithoutSeoNestedInput
    tags?: TagUpdateManyWithoutSeoNestedInput
    products?: ProductUpdateManyWithoutSeoNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutSeoNestedInput
  }

  export type SeoUncheckedUpdateWithoutRootChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    ogTwitterType?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterImageId?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterLocale?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: SettingsUncheckedUpdateManyWithoutSeoNestedInput
    posts?: PostUncheckedUpdateManyWithoutSeoNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutSeoNestedInput
    tags?: TagUncheckedUpdateManyWithoutSeoNestedInput
    products?: ProductUncheckedUpdateManyWithoutSeoNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutSeoNestedInput
  }

  export type SeoUpsertWithWhereUniqueWithoutRootInput = {
    where: SeoWhereUniqueInput
    update: XOR<SeoUpdateWithoutRootInput, SeoUncheckedUpdateWithoutRootInput>
    create: XOR<SeoCreateWithoutRootInput, SeoUncheckedCreateWithoutRootInput>
  }

  export type SeoUpdateWithWhereUniqueWithoutRootInput = {
    where: SeoWhereUniqueInput
    data: XOR<SeoUpdateWithoutRootInput, SeoUncheckedUpdateWithoutRootInput>
  }

  export type SeoUpdateManyWithWhereWithoutRootInput = {
    where: SeoScalarWhereInput
    data: XOR<SeoUpdateManyMutationInput, SeoUncheckedUpdateManyWithoutRootInput>
  }

  export type SettingsUpsertWithWhereUniqueWithoutSeoInput = {
    where: SettingsWhereUniqueInput
    update: XOR<SettingsUpdateWithoutSeoInput, SettingsUncheckedUpdateWithoutSeoInput>
    create: XOR<SettingsCreateWithoutSeoInput, SettingsUncheckedCreateWithoutSeoInput>
  }

  export type SettingsUpdateWithWhereUniqueWithoutSeoInput = {
    where: SettingsWhereUniqueInput
    data: XOR<SettingsUpdateWithoutSeoInput, SettingsUncheckedUpdateWithoutSeoInput>
  }

  export type SettingsUpdateManyWithWhereWithoutSeoInput = {
    where: SettingsScalarWhereInput
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyWithoutSeoInput>
  }

  export type SettingsScalarWhereInput = {
    AND?: SettingsScalarWhereInput | SettingsScalarWhereInput[]
    OR?: SettingsScalarWhereInput[]
    NOT?: SettingsScalarWhereInput | SettingsScalarWhereInput[]
    id?: StringFilter<"Settings"> | string
    siteName?: StringNullableFilter<"Settings"> | string | null
    siteUrl?: StringNullableFilter<"Settings"> | string | null
    deployWebhookUrl?: StringNullableFilter<"Settings"> | string | null
    logoUrl?: StringNullableFilter<"Settings"> | string | null
    scripts?: JsonFilter<"Settings">
    seoId?: StringNullableFilter<"Settings"> | string | null
    createdAt?: DateTimeFilter<"Settings"> | Date | string
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
  }

  export type PostUpsertWithWhereUniqueWithoutSeoInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutSeoInput, PostUncheckedUpdateWithoutSeoInput>
    create: XOR<PostCreateWithoutSeoInput, PostUncheckedCreateWithoutSeoInput>
  }

  export type PostUpdateWithWhereUniqueWithoutSeoInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutSeoInput, PostUncheckedUpdateWithoutSeoInput>
  }

  export type PostUpdateManyWithWhereWithoutSeoInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutSeoInput>
  }

  export type CategoryUpsertWithWhereUniqueWithoutSeoInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutSeoInput, CategoryUncheckedUpdateWithoutSeoInput>
    create: XOR<CategoryCreateWithoutSeoInput, CategoryUncheckedCreateWithoutSeoInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutSeoInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutSeoInput, CategoryUncheckedUpdateWithoutSeoInput>
  }

  export type CategoryUpdateManyWithWhereWithoutSeoInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutSeoInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    title?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    version?: IntFilter<"Category"> | number
    status?: EnumContentStatusFilter<"Category"> | $Enums.ContentStatus
    isLatest?: BoolFilter<"Category"> | boolean
    rootId?: StringNullableFilter<"Category"> | string | null
    seoId?: StringNullableFilter<"Category"> | string | null
    firstPublishedAt?: DateTimeFilter<"Category"> | Date | string
    publishedAt?: DateTimeFilter<"Category"> | Date | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
  }

  export type TagUpsertWithWhereUniqueWithoutSeoInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutSeoInput, TagUncheckedUpdateWithoutSeoInput>
    create: XOR<TagCreateWithoutSeoInput, TagUncheckedCreateWithoutSeoInput>
  }

  export type TagUpdateWithWhereUniqueWithoutSeoInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutSeoInput, TagUncheckedUpdateWithoutSeoInput>
  }

  export type TagUpdateManyWithWhereWithoutSeoInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutSeoInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: StringFilter<"Tag"> | string
    title?: StringFilter<"Tag"> | string
    slug?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    version?: IntFilter<"Tag"> | number
    status?: EnumContentStatusFilter<"Tag"> | $Enums.ContentStatus
    isLatest?: BoolFilter<"Tag"> | boolean
    rootId?: StringNullableFilter<"Tag"> | string | null
    seoId?: StringNullableFilter<"Tag"> | string | null
    firstPublishedAt?: DateTimeFilter<"Tag"> | Date | string
    publishedAt?: DateTimeFilter<"Tag"> | Date | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutSeoInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutSeoInput, ProductUncheckedUpdateWithoutSeoInput>
    create: XOR<ProductCreateWithoutSeoInput, ProductUncheckedCreateWithoutSeoInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutSeoInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutSeoInput, ProductUncheckedUpdateWithoutSeoInput>
  }

  export type ProductUpdateManyWithWhereWithoutSeoInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutSeoInput>
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutSeoInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutSeoInput, ProductCategoryUncheckedUpdateWithoutSeoInput>
    create: XOR<ProductCategoryCreateWithoutSeoInput, ProductCategoryUncheckedCreateWithoutSeoInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutSeoInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutSeoInput, ProductCategoryUncheckedUpdateWithoutSeoInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutSeoInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutSeoInput>
  }

  export type ProductCategoryScalarWhereInput = {
    AND?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    OR?: ProductCategoryScalarWhereInput[]
    NOT?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    id?: StringFilter<"ProductCategory"> | string
    title?: StringFilter<"ProductCategory"> | string
    slug?: StringFilter<"ProductCategory"> | string
    description?: StringNullableFilter<"ProductCategory"> | string | null
    version?: IntFilter<"ProductCategory"> | number
    status?: EnumContentStatusFilter<"ProductCategory"> | $Enums.ContentStatus
    isLatest?: BoolFilter<"ProductCategory"> | boolean
    rootId?: StringNullableFilter<"ProductCategory"> | string | null
    seoId?: StringNullableFilter<"ProductCategory"> | string | null
    firstPublishedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    publishedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
  }

  export type PostCreateWithoutRootChildrenInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    editorType?: $Enums.EditorType
    bodyData:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    root?: PostCreateNestedOneWithoutRootChildrenInput
    imageCover?: MediaCreateNestedOneWithoutPostInput
    postCategories?: PostCategoryCreateNestedManyWithoutPostInput
    tags?: TagCreateNestedManyWithoutPostsInput
    seo?: SeoCreateNestedOneWithoutPostsInput
    postAuthors?: PostAuthorCreateNestedManyWithoutPostInput
    user?: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutRootChildrenInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    editorType?: $Enums.EditorType
    bodyData:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: string | null
    imageCoverId?: string | null
    seoId?: string | null
    userId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    postCategories?: PostCategoryUncheckedCreateNestedManyWithoutPostInput
    tags?: TagUncheckedCreateNestedManyWithoutPostsInput
    postAuthors?: PostAuthorUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutRootChildrenInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutRootChildrenInput, PostUncheckedCreateWithoutRootChildrenInput>
  }

  export type PostCreateWithoutRootInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    editorType?: $Enums.EditorType
    bodyData:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: PostCreateNestedManyWithoutRootInput
    imageCover?: MediaCreateNestedOneWithoutPostInput
    postCategories?: PostCategoryCreateNestedManyWithoutPostInput
    tags?: TagCreateNestedManyWithoutPostsInput
    seo?: SeoCreateNestedOneWithoutPostsInput
    postAuthors?: PostAuthorCreateNestedManyWithoutPostInput
    user?: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutRootInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    editorType?: $Enums.EditorType
    bodyData:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    imageCoverId?: string | null
    seoId?: string | null
    userId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: PostUncheckedCreateNestedManyWithoutRootInput
    postCategories?: PostCategoryUncheckedCreateNestedManyWithoutPostInput
    tags?: TagUncheckedCreateNestedManyWithoutPostsInput
    postAuthors?: PostAuthorUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutRootInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutRootInput, PostUncheckedCreateWithoutRootInput>
  }

  export type PostCreateManyRootInputEnvelope = {
    data: PostCreateManyRootInput | PostCreateManyRootInput[]
    skipDuplicates?: boolean
  }

  export type MediaCreateWithoutPostInput = {
    id?: string
    name: string
    key?: string | null
    url: string
    size?: number | null
    type?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seo?: SeoCreateNestedManyWithoutOgTwitterImageInput
    product?: ProductCreateNestedManyWithoutImageCoverInput
    impression?: ImpressionCreateNestedOneWithoutFileInput
    products?: ProductGalleryCreateNestedManyWithoutMediaInput
    user?: UserCreateNestedManyWithoutProfileImageInput
  }

  export type MediaUncheckedCreateWithoutPostInput = {
    id?: string
    name: string
    key?: string | null
    url: string
    size?: number | null
    type?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seo?: SeoUncheckedCreateNestedManyWithoutOgTwitterImageInput
    product?: ProductUncheckedCreateNestedManyWithoutImageCoverInput
    impression?: ImpressionUncheckedCreateNestedOneWithoutFileInput
    products?: ProductGalleryUncheckedCreateNestedManyWithoutMediaInput
    user?: UserUncheckedCreateNestedManyWithoutProfileImageInput
  }

  export type MediaCreateOrConnectWithoutPostInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutPostInput, MediaUncheckedCreateWithoutPostInput>
  }

  export type PostCategoryCreateWithoutPostInput = {
    sort: number
    category: CategoryCreateNestedOneWithoutPostCategoriesInput
  }

  export type PostCategoryUncheckedCreateWithoutPostInput = {
    categoryId: string
    sort: number
  }

  export type PostCategoryCreateOrConnectWithoutPostInput = {
    where: PostCategoryWhereUniqueInput
    create: XOR<PostCategoryCreateWithoutPostInput, PostCategoryUncheckedCreateWithoutPostInput>
  }

  export type PostCategoryCreateManyPostInputEnvelope = {
    data: PostCategoryCreateManyPostInput | PostCategoryCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutPostsInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    root?: TagCreateNestedOneWithoutRootChildrenInput
    rootChildren?: TagCreateNestedManyWithoutRootInput
    seo?: SeoCreateNestedOneWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutPostsInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    rootId?: string | null
    seoId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: TagUncheckedCreateNestedManyWithoutRootInput
  }

  export type TagCreateOrConnectWithoutPostsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
  }

  export type SeoCreateWithoutPostsInput = {
    id?: string
    title: string
    description?: string | null
    canonicalUrl?: string | null
    version: number
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: string | null
    ogTwitterTitle?: string | null
    ogTwitterDescription?: string | null
    ogTwitterLocale?: string | null
    ogTwitterUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ogTwitterImage?: MediaCreateNestedOneWithoutSeoInput
    root?: SeoCreateNestedOneWithoutRootChildrenInput
    rootChildren?: SeoCreateNestedManyWithoutRootInput
    settings?: SettingsCreateNestedManyWithoutSeoInput
    categories?: CategoryCreateNestedManyWithoutSeoInput
    tags?: TagCreateNestedManyWithoutSeoInput
    products?: ProductCreateNestedManyWithoutSeoInput
    productCategories?: ProductCategoryCreateNestedManyWithoutSeoInput
  }

  export type SeoUncheckedCreateWithoutPostsInput = {
    id?: string
    title: string
    description?: string | null
    canonicalUrl?: string | null
    version: number
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: string | null
    ogTwitterTitle?: string | null
    ogTwitterDescription?: string | null
    ogTwitterImageId?: string | null
    ogTwitterLocale?: string | null
    ogTwitterUrl?: string | null
    rootId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: SeoUncheckedCreateNestedManyWithoutRootInput
    settings?: SettingsUncheckedCreateNestedManyWithoutSeoInput
    categories?: CategoryUncheckedCreateNestedManyWithoutSeoInput
    tags?: TagUncheckedCreateNestedManyWithoutSeoInput
    products?: ProductUncheckedCreateNestedManyWithoutSeoInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutSeoInput
  }

  export type SeoCreateOrConnectWithoutPostsInput = {
    where: SeoWhereUniqueInput
    create: XOR<SeoCreateWithoutPostsInput, SeoUncheckedCreateWithoutPostsInput>
  }

  export type PostAuthorCreateWithoutPostInput = {
    sort: number
    user: UserCreateNestedOneWithoutPostAuthorsInput
  }

  export type PostAuthorUncheckedCreateWithoutPostInput = {
    userId: string
    sort: number
  }

  export type PostAuthorCreateOrConnectWithoutPostInput = {
    where: PostAuthorWhereUniqueInput
    create: XOR<PostAuthorCreateWithoutPostInput, PostAuthorUncheckedCreateWithoutPostInput>
  }

  export type PostAuthorCreateManyPostInputEnvelope = {
    data: PostAuthorCreateManyPostInput | PostAuthorCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutPostsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    bio?: string | null
    imageUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    profileImage?: MediaCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    postAuthors?: PostAuthorCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    profileImageId?: string | null
    bio?: string | null
    imageUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    postAuthors?: PostAuthorUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type PostUpsertWithoutRootChildrenInput = {
    update: XOR<PostUpdateWithoutRootChildrenInput, PostUncheckedUpdateWithoutRootChildrenInput>
    create: XOR<PostCreateWithoutRootChildrenInput, PostUncheckedCreateWithoutRootChildrenInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutRootChildrenInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutRootChildrenInput, PostUncheckedUpdateWithoutRootChildrenInput>
  }

  export type PostUpdateWithoutRootChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    root?: PostUpdateOneWithoutRootChildrenNestedInput
    imageCover?: MediaUpdateOneWithoutPostNestedInput
    postCategories?: PostCategoryUpdateManyWithoutPostNestedInput
    tags?: TagUpdateManyWithoutPostsNestedInput
    seo?: SeoUpdateOneWithoutPostsNestedInput
    postAuthors?: PostAuthorUpdateManyWithoutPostNestedInput
    user?: UserUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutRootChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postCategories?: PostCategoryUncheckedUpdateManyWithoutPostNestedInput
    tags?: TagUncheckedUpdateManyWithoutPostsNestedInput
    postAuthors?: PostAuthorUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUpsertWithWhereUniqueWithoutRootInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutRootInput, PostUncheckedUpdateWithoutRootInput>
    create: XOR<PostCreateWithoutRootInput, PostUncheckedCreateWithoutRootInput>
  }

  export type PostUpdateWithWhereUniqueWithoutRootInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutRootInput, PostUncheckedUpdateWithoutRootInput>
  }

  export type PostUpdateManyWithWhereWithoutRootInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutRootInput>
  }

  export type MediaUpsertWithoutPostInput = {
    update: XOR<MediaUpdateWithoutPostInput, MediaUncheckedUpdateWithoutPostInput>
    create: XOR<MediaCreateWithoutPostInput, MediaUncheckedCreateWithoutPostInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutPostInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutPostInput, MediaUncheckedUpdateWithoutPostInput>
  }

  export type MediaUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seo?: SeoUpdateManyWithoutOgTwitterImageNestedInput
    product?: ProductUpdateManyWithoutImageCoverNestedInput
    impression?: ImpressionUpdateOneWithoutFileNestedInput
    products?: ProductGalleryUpdateManyWithoutMediaNestedInput
    user?: UserUpdateManyWithoutProfileImageNestedInput
  }

  export type MediaUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seo?: SeoUncheckedUpdateManyWithoutOgTwitterImageNestedInput
    product?: ProductUncheckedUpdateManyWithoutImageCoverNestedInput
    impression?: ImpressionUncheckedUpdateOneWithoutFileNestedInput
    products?: ProductGalleryUncheckedUpdateManyWithoutMediaNestedInput
    user?: UserUncheckedUpdateManyWithoutProfileImageNestedInput
  }

  export type PostCategoryUpsertWithWhereUniqueWithoutPostInput = {
    where: PostCategoryWhereUniqueInput
    update: XOR<PostCategoryUpdateWithoutPostInput, PostCategoryUncheckedUpdateWithoutPostInput>
    create: XOR<PostCategoryCreateWithoutPostInput, PostCategoryUncheckedCreateWithoutPostInput>
  }

  export type PostCategoryUpdateWithWhereUniqueWithoutPostInput = {
    where: PostCategoryWhereUniqueInput
    data: XOR<PostCategoryUpdateWithoutPostInput, PostCategoryUncheckedUpdateWithoutPostInput>
  }

  export type PostCategoryUpdateManyWithWhereWithoutPostInput = {
    where: PostCategoryScalarWhereInput
    data: XOR<PostCategoryUpdateManyMutationInput, PostCategoryUncheckedUpdateManyWithoutPostInput>
  }

  export type PostCategoryScalarWhereInput = {
    AND?: PostCategoryScalarWhereInput | PostCategoryScalarWhereInput[]
    OR?: PostCategoryScalarWhereInput[]
    NOT?: PostCategoryScalarWhereInput | PostCategoryScalarWhereInput[]
    postId?: StringFilter<"PostCategory"> | string
    categoryId?: StringFilter<"PostCategory"> | string
    sort?: IntFilter<"PostCategory"> | number
  }

  export type TagUpsertWithWhereUniqueWithoutPostsInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutPostsInput, TagUncheckedUpdateWithoutPostsInput>
    create: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
  }

  export type TagUpdateWithWhereUniqueWithoutPostsInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutPostsInput, TagUncheckedUpdateWithoutPostsInput>
  }

  export type TagUpdateManyWithWhereWithoutPostsInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutPostsInput>
  }

  export type SeoUpsertWithoutPostsInput = {
    update: XOR<SeoUpdateWithoutPostsInput, SeoUncheckedUpdateWithoutPostsInput>
    create: XOR<SeoCreateWithoutPostsInput, SeoUncheckedCreateWithoutPostsInput>
    where?: SeoWhereInput
  }

  export type SeoUpdateToOneWithWhereWithoutPostsInput = {
    where?: SeoWhereInput
    data: XOR<SeoUpdateWithoutPostsInput, SeoUncheckedUpdateWithoutPostsInput>
  }

  export type SeoUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    ogTwitterType?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterLocale?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ogTwitterImage?: MediaUpdateOneWithoutSeoNestedInput
    root?: SeoUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: SeoUpdateManyWithoutRootNestedInput
    settings?: SettingsUpdateManyWithoutSeoNestedInput
    categories?: CategoryUpdateManyWithoutSeoNestedInput
    tags?: TagUpdateManyWithoutSeoNestedInput
    products?: ProductUpdateManyWithoutSeoNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutSeoNestedInput
  }

  export type SeoUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    ogTwitterType?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterImageId?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterLocale?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: SeoUncheckedUpdateManyWithoutRootNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutSeoNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutSeoNestedInput
    tags?: TagUncheckedUpdateManyWithoutSeoNestedInput
    products?: ProductUncheckedUpdateManyWithoutSeoNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutSeoNestedInput
  }

  export type PostAuthorUpsertWithWhereUniqueWithoutPostInput = {
    where: PostAuthorWhereUniqueInput
    update: XOR<PostAuthorUpdateWithoutPostInput, PostAuthorUncheckedUpdateWithoutPostInput>
    create: XOR<PostAuthorCreateWithoutPostInput, PostAuthorUncheckedCreateWithoutPostInput>
  }

  export type PostAuthorUpdateWithWhereUniqueWithoutPostInput = {
    where: PostAuthorWhereUniqueInput
    data: XOR<PostAuthorUpdateWithoutPostInput, PostAuthorUncheckedUpdateWithoutPostInput>
  }

  export type PostAuthorUpdateManyWithWhereWithoutPostInput = {
    where: PostAuthorScalarWhereInput
    data: XOR<PostAuthorUpdateManyMutationInput, PostAuthorUncheckedUpdateManyWithoutPostInput>
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: MediaUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    postAuthors?: PostAuthorUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageId?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    postAuthors?: PostAuthorUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PostCreateWithoutPostAuthorsInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    editorType?: $Enums.EditorType
    bodyData:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    root?: PostCreateNestedOneWithoutRootChildrenInput
    rootChildren?: PostCreateNestedManyWithoutRootInput
    imageCover?: MediaCreateNestedOneWithoutPostInput
    postCategories?: PostCategoryCreateNestedManyWithoutPostInput
    tags?: TagCreateNestedManyWithoutPostsInput
    seo?: SeoCreateNestedOneWithoutPostsInput
    user?: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutPostAuthorsInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    editorType?: $Enums.EditorType
    bodyData:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: string | null
    imageCoverId?: string | null
    seoId?: string | null
    userId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: PostUncheckedCreateNestedManyWithoutRootInput
    postCategories?: PostCategoryUncheckedCreateNestedManyWithoutPostInput
    tags?: TagUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostCreateOrConnectWithoutPostAuthorsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutPostAuthorsInput, PostUncheckedCreateWithoutPostAuthorsInput>
  }

  export type UserCreateWithoutPostAuthorsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    bio?: string | null
    imageUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    profileImage?: MediaCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostAuthorsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    profileImageId?: string | null
    bio?: string | null
    imageUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostAuthorsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostAuthorsInput, UserUncheckedCreateWithoutPostAuthorsInput>
  }

  export type PostUpsertWithoutPostAuthorsInput = {
    update: XOR<PostUpdateWithoutPostAuthorsInput, PostUncheckedUpdateWithoutPostAuthorsInput>
    create: XOR<PostCreateWithoutPostAuthorsInput, PostUncheckedCreateWithoutPostAuthorsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutPostAuthorsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutPostAuthorsInput, PostUncheckedUpdateWithoutPostAuthorsInput>
  }

  export type PostUpdateWithoutPostAuthorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    root?: PostUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: PostUpdateManyWithoutRootNestedInput
    imageCover?: MediaUpdateOneWithoutPostNestedInput
    postCategories?: PostCategoryUpdateManyWithoutPostNestedInput
    tags?: TagUpdateManyWithoutPostsNestedInput
    seo?: SeoUpdateOneWithoutPostsNestedInput
    user?: UserUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutPostAuthorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: PostUncheckedUpdateManyWithoutRootNestedInput
    postCategories?: PostCategoryUncheckedUpdateManyWithoutPostNestedInput
    tags?: TagUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type UserUpsertWithoutPostAuthorsInput = {
    update: XOR<UserUpdateWithoutPostAuthorsInput, UserUncheckedUpdateWithoutPostAuthorsInput>
    create: XOR<UserCreateWithoutPostAuthorsInput, UserUncheckedCreateWithoutPostAuthorsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostAuthorsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostAuthorsInput, UserUncheckedUpdateWithoutPostAuthorsInput>
  }

  export type UserUpdateWithoutPostAuthorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: MediaUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostAuthorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageId?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CategoryCreateWithoutRootChildrenInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    root?: CategoryCreateNestedOneWithoutRootChildrenInput
    postCategories?: PostCategoryCreateNestedManyWithoutCategoryInput
    seo?: SeoCreateNestedOneWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateWithoutRootChildrenInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    rootId?: string | null
    seoId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    postCategories?: PostCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutRootChildrenInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutRootChildrenInput, CategoryUncheckedCreateWithoutRootChildrenInput>
  }

  export type CategoryCreateWithoutRootInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: CategoryCreateNestedManyWithoutRootInput
    postCategories?: PostCategoryCreateNestedManyWithoutCategoryInput
    seo?: SeoCreateNestedOneWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateWithoutRootInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    seoId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: CategoryUncheckedCreateNestedManyWithoutRootInput
    postCategories?: PostCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutRootInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutRootInput, CategoryUncheckedCreateWithoutRootInput>
  }

  export type CategoryCreateManyRootInputEnvelope = {
    data: CategoryCreateManyRootInput | CategoryCreateManyRootInput[]
    skipDuplicates?: boolean
  }

  export type PostCategoryCreateWithoutCategoryInput = {
    sort: number
    post: PostCreateNestedOneWithoutPostCategoriesInput
  }

  export type PostCategoryUncheckedCreateWithoutCategoryInput = {
    postId: string
    sort: number
  }

  export type PostCategoryCreateOrConnectWithoutCategoryInput = {
    where: PostCategoryWhereUniqueInput
    create: XOR<PostCategoryCreateWithoutCategoryInput, PostCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type PostCategoryCreateManyCategoryInputEnvelope = {
    data: PostCategoryCreateManyCategoryInput | PostCategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type SeoCreateWithoutCategoriesInput = {
    id?: string
    title: string
    description?: string | null
    canonicalUrl?: string | null
    version: number
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: string | null
    ogTwitterTitle?: string | null
    ogTwitterDescription?: string | null
    ogTwitterLocale?: string | null
    ogTwitterUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ogTwitterImage?: MediaCreateNestedOneWithoutSeoInput
    root?: SeoCreateNestedOneWithoutRootChildrenInput
    rootChildren?: SeoCreateNestedManyWithoutRootInput
    settings?: SettingsCreateNestedManyWithoutSeoInput
    posts?: PostCreateNestedManyWithoutSeoInput
    tags?: TagCreateNestedManyWithoutSeoInput
    products?: ProductCreateNestedManyWithoutSeoInput
    productCategories?: ProductCategoryCreateNestedManyWithoutSeoInput
  }

  export type SeoUncheckedCreateWithoutCategoriesInput = {
    id?: string
    title: string
    description?: string | null
    canonicalUrl?: string | null
    version: number
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: string | null
    ogTwitterTitle?: string | null
    ogTwitterDescription?: string | null
    ogTwitterImageId?: string | null
    ogTwitterLocale?: string | null
    ogTwitterUrl?: string | null
    rootId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: SeoUncheckedCreateNestedManyWithoutRootInput
    settings?: SettingsUncheckedCreateNestedManyWithoutSeoInput
    posts?: PostUncheckedCreateNestedManyWithoutSeoInput
    tags?: TagUncheckedCreateNestedManyWithoutSeoInput
    products?: ProductUncheckedCreateNestedManyWithoutSeoInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutSeoInput
  }

  export type SeoCreateOrConnectWithoutCategoriesInput = {
    where: SeoWhereUniqueInput
    create: XOR<SeoCreateWithoutCategoriesInput, SeoUncheckedCreateWithoutCategoriesInput>
  }

  export type CategoryUpsertWithoutRootChildrenInput = {
    update: XOR<CategoryUpdateWithoutRootChildrenInput, CategoryUncheckedUpdateWithoutRootChildrenInput>
    create: XOR<CategoryCreateWithoutRootChildrenInput, CategoryUncheckedCreateWithoutRootChildrenInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutRootChildrenInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutRootChildrenInput, CategoryUncheckedUpdateWithoutRootChildrenInput>
  }

  export type CategoryUpdateWithoutRootChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    root?: CategoryUpdateOneWithoutRootChildrenNestedInput
    postCategories?: PostCategoryUpdateManyWithoutCategoryNestedInput
    seo?: SeoUpdateOneWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateWithoutRootChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postCategories?: PostCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutRootInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutRootInput, CategoryUncheckedUpdateWithoutRootInput>
    create: XOR<CategoryCreateWithoutRootInput, CategoryUncheckedCreateWithoutRootInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutRootInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutRootInput, CategoryUncheckedUpdateWithoutRootInput>
  }

  export type CategoryUpdateManyWithWhereWithoutRootInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutRootInput>
  }

  export type PostCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: PostCategoryWhereUniqueInput
    update: XOR<PostCategoryUpdateWithoutCategoryInput, PostCategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<PostCategoryCreateWithoutCategoryInput, PostCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type PostCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: PostCategoryWhereUniqueInput
    data: XOR<PostCategoryUpdateWithoutCategoryInput, PostCategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type PostCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: PostCategoryScalarWhereInput
    data: XOR<PostCategoryUpdateManyMutationInput, PostCategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type SeoUpsertWithoutCategoriesInput = {
    update: XOR<SeoUpdateWithoutCategoriesInput, SeoUncheckedUpdateWithoutCategoriesInput>
    create: XOR<SeoCreateWithoutCategoriesInput, SeoUncheckedCreateWithoutCategoriesInput>
    where?: SeoWhereInput
  }

  export type SeoUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: SeoWhereInput
    data: XOR<SeoUpdateWithoutCategoriesInput, SeoUncheckedUpdateWithoutCategoriesInput>
  }

  export type SeoUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    ogTwitterType?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterLocale?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ogTwitterImage?: MediaUpdateOneWithoutSeoNestedInput
    root?: SeoUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: SeoUpdateManyWithoutRootNestedInput
    settings?: SettingsUpdateManyWithoutSeoNestedInput
    posts?: PostUpdateManyWithoutSeoNestedInput
    tags?: TagUpdateManyWithoutSeoNestedInput
    products?: ProductUpdateManyWithoutSeoNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutSeoNestedInput
  }

  export type SeoUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    ogTwitterType?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterImageId?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterLocale?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: SeoUncheckedUpdateManyWithoutRootNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutSeoNestedInput
    posts?: PostUncheckedUpdateManyWithoutSeoNestedInput
    tags?: TagUncheckedUpdateManyWithoutSeoNestedInput
    products?: ProductUncheckedUpdateManyWithoutSeoNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutSeoNestedInput
  }

  export type PostCreateWithoutPostCategoriesInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    editorType?: $Enums.EditorType
    bodyData:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    root?: PostCreateNestedOneWithoutRootChildrenInput
    rootChildren?: PostCreateNestedManyWithoutRootInput
    imageCover?: MediaCreateNestedOneWithoutPostInput
    tags?: TagCreateNestedManyWithoutPostsInput
    seo?: SeoCreateNestedOneWithoutPostsInput
    postAuthors?: PostAuthorCreateNestedManyWithoutPostInput
    user?: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutPostCategoriesInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    editorType?: $Enums.EditorType
    bodyData:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: string | null
    imageCoverId?: string | null
    seoId?: string | null
    userId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: PostUncheckedCreateNestedManyWithoutRootInput
    tags?: TagUncheckedCreateNestedManyWithoutPostsInput
    postAuthors?: PostAuthorUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutPostCategoriesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutPostCategoriesInput, PostUncheckedCreateWithoutPostCategoriesInput>
  }

  export type CategoryCreateWithoutPostCategoriesInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    root?: CategoryCreateNestedOneWithoutRootChildrenInput
    rootChildren?: CategoryCreateNestedManyWithoutRootInput
    seo?: SeoCreateNestedOneWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateWithoutPostCategoriesInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    rootId?: string | null
    seoId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: CategoryUncheckedCreateNestedManyWithoutRootInput
  }

  export type CategoryCreateOrConnectWithoutPostCategoriesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutPostCategoriesInput, CategoryUncheckedCreateWithoutPostCategoriesInput>
  }

  export type PostUpsertWithoutPostCategoriesInput = {
    update: XOR<PostUpdateWithoutPostCategoriesInput, PostUncheckedUpdateWithoutPostCategoriesInput>
    create: XOR<PostCreateWithoutPostCategoriesInput, PostUncheckedCreateWithoutPostCategoriesInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutPostCategoriesInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutPostCategoriesInput, PostUncheckedUpdateWithoutPostCategoriesInput>
  }

  export type PostUpdateWithoutPostCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    root?: PostUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: PostUpdateManyWithoutRootNestedInput
    imageCover?: MediaUpdateOneWithoutPostNestedInput
    tags?: TagUpdateManyWithoutPostsNestedInput
    seo?: SeoUpdateOneWithoutPostsNestedInput
    postAuthors?: PostAuthorUpdateManyWithoutPostNestedInput
    user?: UserUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutPostCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: PostUncheckedUpdateManyWithoutRootNestedInput
    tags?: TagUncheckedUpdateManyWithoutPostsNestedInput
    postAuthors?: PostAuthorUncheckedUpdateManyWithoutPostNestedInput
  }

  export type CategoryUpsertWithoutPostCategoriesInput = {
    update: XOR<CategoryUpdateWithoutPostCategoriesInput, CategoryUncheckedUpdateWithoutPostCategoriesInput>
    create: XOR<CategoryCreateWithoutPostCategoriesInput, CategoryUncheckedCreateWithoutPostCategoriesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutPostCategoriesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutPostCategoriesInput, CategoryUncheckedUpdateWithoutPostCategoriesInput>
  }

  export type CategoryUpdateWithoutPostCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    root?: CategoryUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: CategoryUpdateManyWithoutRootNestedInput
    seo?: SeoUpdateOneWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateWithoutPostCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: CategoryUncheckedUpdateManyWithoutRootNestedInput
  }

  export type TagCreateWithoutRootChildrenInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    root?: TagCreateNestedOneWithoutRootChildrenInput
    posts?: PostCreateNestedManyWithoutTagsInput
    seo?: SeoCreateNestedOneWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutRootChildrenInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    rootId?: string | null
    seoId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutRootChildrenInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutRootChildrenInput, TagUncheckedCreateWithoutRootChildrenInput>
  }

  export type TagCreateWithoutRootInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: TagCreateNestedManyWithoutRootInput
    posts?: PostCreateNestedManyWithoutTagsInput
    seo?: SeoCreateNestedOneWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutRootInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    seoId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: TagUncheckedCreateNestedManyWithoutRootInput
    posts?: PostUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutRootInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutRootInput, TagUncheckedCreateWithoutRootInput>
  }

  export type TagCreateManyRootInputEnvelope = {
    data: TagCreateManyRootInput | TagCreateManyRootInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutTagsInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    editorType?: $Enums.EditorType
    bodyData:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    root?: PostCreateNestedOneWithoutRootChildrenInput
    rootChildren?: PostCreateNestedManyWithoutRootInput
    imageCover?: MediaCreateNestedOneWithoutPostInput
    postCategories?: PostCategoryCreateNestedManyWithoutPostInput
    seo?: SeoCreateNestedOneWithoutPostsInput
    postAuthors?: PostAuthorCreateNestedManyWithoutPostInput
    user?: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutTagsInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    editorType?: $Enums.EditorType
    bodyData:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: string | null
    imageCoverId?: string | null
    seoId?: string | null
    userId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: PostUncheckedCreateNestedManyWithoutRootInput
    postCategories?: PostCategoryUncheckedCreateNestedManyWithoutPostInput
    postAuthors?: PostAuthorUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutTagsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput>
  }

  export type SeoCreateWithoutTagsInput = {
    id?: string
    title: string
    description?: string | null
    canonicalUrl?: string | null
    version: number
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: string | null
    ogTwitterTitle?: string | null
    ogTwitterDescription?: string | null
    ogTwitterLocale?: string | null
    ogTwitterUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ogTwitterImage?: MediaCreateNestedOneWithoutSeoInput
    root?: SeoCreateNestedOneWithoutRootChildrenInput
    rootChildren?: SeoCreateNestedManyWithoutRootInput
    settings?: SettingsCreateNestedManyWithoutSeoInput
    posts?: PostCreateNestedManyWithoutSeoInput
    categories?: CategoryCreateNestedManyWithoutSeoInput
    products?: ProductCreateNestedManyWithoutSeoInput
    productCategories?: ProductCategoryCreateNestedManyWithoutSeoInput
  }

  export type SeoUncheckedCreateWithoutTagsInput = {
    id?: string
    title: string
    description?: string | null
    canonicalUrl?: string | null
    version: number
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: string | null
    ogTwitterTitle?: string | null
    ogTwitterDescription?: string | null
    ogTwitterImageId?: string | null
    ogTwitterLocale?: string | null
    ogTwitterUrl?: string | null
    rootId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: SeoUncheckedCreateNestedManyWithoutRootInput
    settings?: SettingsUncheckedCreateNestedManyWithoutSeoInput
    posts?: PostUncheckedCreateNestedManyWithoutSeoInput
    categories?: CategoryUncheckedCreateNestedManyWithoutSeoInput
    products?: ProductUncheckedCreateNestedManyWithoutSeoInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutSeoInput
  }

  export type SeoCreateOrConnectWithoutTagsInput = {
    where: SeoWhereUniqueInput
    create: XOR<SeoCreateWithoutTagsInput, SeoUncheckedCreateWithoutTagsInput>
  }

  export type TagUpsertWithoutRootChildrenInput = {
    update: XOR<TagUpdateWithoutRootChildrenInput, TagUncheckedUpdateWithoutRootChildrenInput>
    create: XOR<TagCreateWithoutRootChildrenInput, TagUncheckedCreateWithoutRootChildrenInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutRootChildrenInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutRootChildrenInput, TagUncheckedUpdateWithoutRootChildrenInput>
  }

  export type TagUpdateWithoutRootChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    root?: TagUpdateOneWithoutRootChildrenNestedInput
    posts?: PostUpdateManyWithoutTagsNestedInput
    seo?: SeoUpdateOneWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutRootChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUpsertWithWhereUniqueWithoutRootInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutRootInput, TagUncheckedUpdateWithoutRootInput>
    create: XOR<TagCreateWithoutRootInput, TagUncheckedCreateWithoutRootInput>
  }

  export type TagUpdateWithWhereUniqueWithoutRootInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutRootInput, TagUncheckedUpdateWithoutRootInput>
  }

  export type TagUpdateManyWithWhereWithoutRootInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutRootInput>
  }

  export type PostUpsertWithWhereUniqueWithoutTagsInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutTagsInput, PostUncheckedUpdateWithoutTagsInput>
    create: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput>
  }

  export type PostUpdateWithWhereUniqueWithoutTagsInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutTagsInput, PostUncheckedUpdateWithoutTagsInput>
  }

  export type PostUpdateManyWithWhereWithoutTagsInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutTagsInput>
  }

  export type SeoUpsertWithoutTagsInput = {
    update: XOR<SeoUpdateWithoutTagsInput, SeoUncheckedUpdateWithoutTagsInput>
    create: XOR<SeoCreateWithoutTagsInput, SeoUncheckedCreateWithoutTagsInput>
    where?: SeoWhereInput
  }

  export type SeoUpdateToOneWithWhereWithoutTagsInput = {
    where?: SeoWhereInput
    data: XOR<SeoUpdateWithoutTagsInput, SeoUncheckedUpdateWithoutTagsInput>
  }

  export type SeoUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    ogTwitterType?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterLocale?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ogTwitterImage?: MediaUpdateOneWithoutSeoNestedInput
    root?: SeoUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: SeoUpdateManyWithoutRootNestedInput
    settings?: SettingsUpdateManyWithoutSeoNestedInput
    posts?: PostUpdateManyWithoutSeoNestedInput
    categories?: CategoryUpdateManyWithoutSeoNestedInput
    products?: ProductUpdateManyWithoutSeoNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutSeoNestedInput
  }

  export type SeoUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    ogTwitterType?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterImageId?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterLocale?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: SeoUncheckedUpdateManyWithoutRootNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutSeoNestedInput
    posts?: PostUncheckedUpdateManyWithoutSeoNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutSeoNestedInput
    products?: ProductUncheckedUpdateManyWithoutSeoNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutSeoNestedInput
  }

  export type EmailTemplateCreateWithoutEmailSettingSubscriptionInput = {
    id?: string
    name: string
    description?: string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailSettingFreeEbook?: EmailSettingCreateNestedManyWithoutFreeEbookTemplateInput
    emailSettingWebinar?: EmailSettingCreateNestedManyWithoutWebinarTemplateInput
  }

  export type EmailTemplateUncheckedCreateWithoutEmailSettingSubscriptionInput = {
    id?: string
    name: string
    description?: string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailSettingFreeEbook?: EmailSettingUncheckedCreateNestedManyWithoutFreeEbookTemplateInput
    emailSettingWebinar?: EmailSettingUncheckedCreateNestedManyWithoutWebinarTemplateInput
  }

  export type EmailTemplateCreateOrConnectWithoutEmailSettingSubscriptionInput = {
    where: EmailTemplateWhereUniqueInput
    create: XOR<EmailTemplateCreateWithoutEmailSettingSubscriptionInput, EmailTemplateUncheckedCreateWithoutEmailSettingSubscriptionInput>
  }

  export type EmailTemplateCreateWithoutEmailSettingFreeEbookInput = {
    id?: string
    name: string
    description?: string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailSettingSubscription?: EmailSettingCreateNestedManyWithoutSubscriptionTemplateInput
    emailSettingWebinar?: EmailSettingCreateNestedManyWithoutWebinarTemplateInput
  }

  export type EmailTemplateUncheckedCreateWithoutEmailSettingFreeEbookInput = {
    id?: string
    name: string
    description?: string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailSettingSubscription?: EmailSettingUncheckedCreateNestedManyWithoutSubscriptionTemplateInput
    emailSettingWebinar?: EmailSettingUncheckedCreateNestedManyWithoutWebinarTemplateInput
  }

  export type EmailTemplateCreateOrConnectWithoutEmailSettingFreeEbookInput = {
    where: EmailTemplateWhereUniqueInput
    create: XOR<EmailTemplateCreateWithoutEmailSettingFreeEbookInput, EmailTemplateUncheckedCreateWithoutEmailSettingFreeEbookInput>
  }

  export type EmailTemplateCreateWithoutEmailSettingWebinarInput = {
    id?: string
    name: string
    description?: string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailSettingSubscription?: EmailSettingCreateNestedManyWithoutSubscriptionTemplateInput
    emailSettingFreeEbook?: EmailSettingCreateNestedManyWithoutFreeEbookTemplateInput
  }

  export type EmailTemplateUncheckedCreateWithoutEmailSettingWebinarInput = {
    id?: string
    name: string
    description?: string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailSettingSubscription?: EmailSettingUncheckedCreateNestedManyWithoutSubscriptionTemplateInput
    emailSettingFreeEbook?: EmailSettingUncheckedCreateNestedManyWithoutFreeEbookTemplateInput
  }

  export type EmailTemplateCreateOrConnectWithoutEmailSettingWebinarInput = {
    where: EmailTemplateWhereUniqueInput
    create: XOR<EmailTemplateCreateWithoutEmailSettingWebinarInput, EmailTemplateUncheckedCreateWithoutEmailSettingWebinarInput>
  }

  export type EmailTemplateUpsertWithoutEmailSettingSubscriptionInput = {
    update: XOR<EmailTemplateUpdateWithoutEmailSettingSubscriptionInput, EmailTemplateUncheckedUpdateWithoutEmailSettingSubscriptionInput>
    create: XOR<EmailTemplateCreateWithoutEmailSettingSubscriptionInput, EmailTemplateUncheckedCreateWithoutEmailSettingSubscriptionInput>
    where?: EmailTemplateWhereInput
  }

  export type EmailTemplateUpdateToOneWithWhereWithoutEmailSettingSubscriptionInput = {
    where?: EmailTemplateWhereInput
    data: XOR<EmailTemplateUpdateWithoutEmailSettingSubscriptionInput, EmailTemplateUncheckedUpdateWithoutEmailSettingSubscriptionInput>
  }

  export type EmailTemplateUpdateWithoutEmailSettingSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailSettingFreeEbook?: EmailSettingUpdateManyWithoutFreeEbookTemplateNestedInput
    emailSettingWebinar?: EmailSettingUpdateManyWithoutWebinarTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateWithoutEmailSettingSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailSettingFreeEbook?: EmailSettingUncheckedUpdateManyWithoutFreeEbookTemplateNestedInput
    emailSettingWebinar?: EmailSettingUncheckedUpdateManyWithoutWebinarTemplateNestedInput
  }

  export type EmailTemplateUpsertWithoutEmailSettingFreeEbookInput = {
    update: XOR<EmailTemplateUpdateWithoutEmailSettingFreeEbookInput, EmailTemplateUncheckedUpdateWithoutEmailSettingFreeEbookInput>
    create: XOR<EmailTemplateCreateWithoutEmailSettingFreeEbookInput, EmailTemplateUncheckedCreateWithoutEmailSettingFreeEbookInput>
    where?: EmailTemplateWhereInput
  }

  export type EmailTemplateUpdateToOneWithWhereWithoutEmailSettingFreeEbookInput = {
    where?: EmailTemplateWhereInput
    data: XOR<EmailTemplateUpdateWithoutEmailSettingFreeEbookInput, EmailTemplateUncheckedUpdateWithoutEmailSettingFreeEbookInput>
  }

  export type EmailTemplateUpdateWithoutEmailSettingFreeEbookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailSettingSubscription?: EmailSettingUpdateManyWithoutSubscriptionTemplateNestedInput
    emailSettingWebinar?: EmailSettingUpdateManyWithoutWebinarTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateWithoutEmailSettingFreeEbookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailSettingSubscription?: EmailSettingUncheckedUpdateManyWithoutSubscriptionTemplateNestedInput
    emailSettingWebinar?: EmailSettingUncheckedUpdateManyWithoutWebinarTemplateNestedInput
  }

  export type EmailTemplateUpsertWithoutEmailSettingWebinarInput = {
    update: XOR<EmailTemplateUpdateWithoutEmailSettingWebinarInput, EmailTemplateUncheckedUpdateWithoutEmailSettingWebinarInput>
    create: XOR<EmailTemplateCreateWithoutEmailSettingWebinarInput, EmailTemplateUncheckedCreateWithoutEmailSettingWebinarInput>
    where?: EmailTemplateWhereInput
  }

  export type EmailTemplateUpdateToOneWithWhereWithoutEmailSettingWebinarInput = {
    where?: EmailTemplateWhereInput
    data: XOR<EmailTemplateUpdateWithoutEmailSettingWebinarInput, EmailTemplateUncheckedUpdateWithoutEmailSettingWebinarInput>
  }

  export type EmailTemplateUpdateWithoutEmailSettingWebinarInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailSettingSubscription?: EmailSettingUpdateManyWithoutSubscriptionTemplateNestedInput
    emailSettingFreeEbook?: EmailSettingUpdateManyWithoutFreeEbookTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateWithoutEmailSettingWebinarInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailSettingSubscription?: EmailSettingUncheckedUpdateManyWithoutSubscriptionTemplateNestedInput
    emailSettingFreeEbook?: EmailSettingUncheckedUpdateManyWithoutFreeEbookTemplateNestedInput
  }

  export type EmailSettingCreateWithoutSubscriptionTemplateInput = {
    id?: string
    emailSender?: string | null
    emailSenderName?: string | null
    emailResponse?: string | null
    emailProvider?: $Enums.EmailProvider | null
    emailApiKey?: string | null
    maxEmailsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    freeEbookTemplate?: EmailTemplateCreateNestedOneWithoutEmailSettingFreeEbookInput
    webinarTemplate?: EmailTemplateCreateNestedOneWithoutEmailSettingWebinarInput
  }

  export type EmailSettingUncheckedCreateWithoutSubscriptionTemplateInput = {
    id?: string
    emailSender?: string | null
    emailSenderName?: string | null
    emailResponse?: string | null
    emailProvider?: $Enums.EmailProvider | null
    emailApiKey?: string | null
    maxEmailsPerDay?: number | null
    freeEbookTemplateId?: string | null
    webinarTemplateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailSettingCreateOrConnectWithoutSubscriptionTemplateInput = {
    where: EmailSettingWhereUniqueInput
    create: XOR<EmailSettingCreateWithoutSubscriptionTemplateInput, EmailSettingUncheckedCreateWithoutSubscriptionTemplateInput>
  }

  export type EmailSettingCreateManySubscriptionTemplateInputEnvelope = {
    data: EmailSettingCreateManySubscriptionTemplateInput | EmailSettingCreateManySubscriptionTemplateInput[]
    skipDuplicates?: boolean
  }

  export type EmailSettingCreateWithoutFreeEbookTemplateInput = {
    id?: string
    emailSender?: string | null
    emailSenderName?: string | null
    emailResponse?: string | null
    emailProvider?: $Enums.EmailProvider | null
    emailApiKey?: string | null
    maxEmailsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionTemplate?: EmailTemplateCreateNestedOneWithoutEmailSettingSubscriptionInput
    webinarTemplate?: EmailTemplateCreateNestedOneWithoutEmailSettingWebinarInput
  }

  export type EmailSettingUncheckedCreateWithoutFreeEbookTemplateInput = {
    id?: string
    emailSender?: string | null
    emailSenderName?: string | null
    emailResponse?: string | null
    emailProvider?: $Enums.EmailProvider | null
    emailApiKey?: string | null
    maxEmailsPerDay?: number | null
    subscriptionTemplateId?: string | null
    webinarTemplateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailSettingCreateOrConnectWithoutFreeEbookTemplateInput = {
    where: EmailSettingWhereUniqueInput
    create: XOR<EmailSettingCreateWithoutFreeEbookTemplateInput, EmailSettingUncheckedCreateWithoutFreeEbookTemplateInput>
  }

  export type EmailSettingCreateManyFreeEbookTemplateInputEnvelope = {
    data: EmailSettingCreateManyFreeEbookTemplateInput | EmailSettingCreateManyFreeEbookTemplateInput[]
    skipDuplicates?: boolean
  }

  export type EmailSettingCreateWithoutWebinarTemplateInput = {
    id?: string
    emailSender?: string | null
    emailSenderName?: string | null
    emailResponse?: string | null
    emailProvider?: $Enums.EmailProvider | null
    emailApiKey?: string | null
    maxEmailsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionTemplate?: EmailTemplateCreateNestedOneWithoutEmailSettingSubscriptionInput
    freeEbookTemplate?: EmailTemplateCreateNestedOneWithoutEmailSettingFreeEbookInput
  }

  export type EmailSettingUncheckedCreateWithoutWebinarTemplateInput = {
    id?: string
    emailSender?: string | null
    emailSenderName?: string | null
    emailResponse?: string | null
    emailProvider?: $Enums.EmailProvider | null
    emailApiKey?: string | null
    maxEmailsPerDay?: number | null
    subscriptionTemplateId?: string | null
    freeEbookTemplateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailSettingCreateOrConnectWithoutWebinarTemplateInput = {
    where: EmailSettingWhereUniqueInput
    create: XOR<EmailSettingCreateWithoutWebinarTemplateInput, EmailSettingUncheckedCreateWithoutWebinarTemplateInput>
  }

  export type EmailSettingCreateManyWebinarTemplateInputEnvelope = {
    data: EmailSettingCreateManyWebinarTemplateInput | EmailSettingCreateManyWebinarTemplateInput[]
    skipDuplicates?: boolean
  }

  export type EmailSettingUpsertWithWhereUniqueWithoutSubscriptionTemplateInput = {
    where: EmailSettingWhereUniqueInput
    update: XOR<EmailSettingUpdateWithoutSubscriptionTemplateInput, EmailSettingUncheckedUpdateWithoutSubscriptionTemplateInput>
    create: XOR<EmailSettingCreateWithoutSubscriptionTemplateInput, EmailSettingUncheckedCreateWithoutSubscriptionTemplateInput>
  }

  export type EmailSettingUpdateWithWhereUniqueWithoutSubscriptionTemplateInput = {
    where: EmailSettingWhereUniqueInput
    data: XOR<EmailSettingUpdateWithoutSubscriptionTemplateInput, EmailSettingUncheckedUpdateWithoutSubscriptionTemplateInput>
  }

  export type EmailSettingUpdateManyWithWhereWithoutSubscriptionTemplateInput = {
    where: EmailSettingScalarWhereInput
    data: XOR<EmailSettingUpdateManyMutationInput, EmailSettingUncheckedUpdateManyWithoutSubscriptionTemplateInput>
  }

  export type EmailSettingScalarWhereInput = {
    AND?: EmailSettingScalarWhereInput | EmailSettingScalarWhereInput[]
    OR?: EmailSettingScalarWhereInput[]
    NOT?: EmailSettingScalarWhereInput | EmailSettingScalarWhereInput[]
    id?: StringFilter<"EmailSetting"> | string
    emailSender?: StringNullableFilter<"EmailSetting"> | string | null
    emailSenderName?: StringNullableFilter<"EmailSetting"> | string | null
    emailResponse?: StringNullableFilter<"EmailSetting"> | string | null
    emailProvider?: EnumEmailProviderNullableFilter<"EmailSetting"> | $Enums.EmailProvider | null
    emailApiKey?: StringNullableFilter<"EmailSetting"> | string | null
    maxEmailsPerDay?: IntNullableFilter<"EmailSetting"> | number | null
    subscriptionTemplateId?: StringNullableFilter<"EmailSetting"> | string | null
    freeEbookTemplateId?: StringNullableFilter<"EmailSetting"> | string | null
    webinarTemplateId?: StringNullableFilter<"EmailSetting"> | string | null
    createdAt?: DateTimeFilter<"EmailSetting"> | Date | string
    updatedAt?: DateTimeFilter<"EmailSetting"> | Date | string
  }

  export type EmailSettingUpsertWithWhereUniqueWithoutFreeEbookTemplateInput = {
    where: EmailSettingWhereUniqueInput
    update: XOR<EmailSettingUpdateWithoutFreeEbookTemplateInput, EmailSettingUncheckedUpdateWithoutFreeEbookTemplateInput>
    create: XOR<EmailSettingCreateWithoutFreeEbookTemplateInput, EmailSettingUncheckedCreateWithoutFreeEbookTemplateInput>
  }

  export type EmailSettingUpdateWithWhereUniqueWithoutFreeEbookTemplateInput = {
    where: EmailSettingWhereUniqueInput
    data: XOR<EmailSettingUpdateWithoutFreeEbookTemplateInput, EmailSettingUncheckedUpdateWithoutFreeEbookTemplateInput>
  }

  export type EmailSettingUpdateManyWithWhereWithoutFreeEbookTemplateInput = {
    where: EmailSettingScalarWhereInput
    data: XOR<EmailSettingUpdateManyMutationInput, EmailSettingUncheckedUpdateManyWithoutFreeEbookTemplateInput>
  }

  export type EmailSettingUpsertWithWhereUniqueWithoutWebinarTemplateInput = {
    where: EmailSettingWhereUniqueInput
    update: XOR<EmailSettingUpdateWithoutWebinarTemplateInput, EmailSettingUncheckedUpdateWithoutWebinarTemplateInput>
    create: XOR<EmailSettingCreateWithoutWebinarTemplateInput, EmailSettingUncheckedCreateWithoutWebinarTemplateInput>
  }

  export type EmailSettingUpdateWithWhereUniqueWithoutWebinarTemplateInput = {
    where: EmailSettingWhereUniqueInput
    data: XOR<EmailSettingUpdateWithoutWebinarTemplateInput, EmailSettingUncheckedUpdateWithoutWebinarTemplateInput>
  }

  export type EmailSettingUpdateManyWithWhereWithoutWebinarTemplateInput = {
    where: EmailSettingScalarWhereInput
    data: XOR<EmailSettingUpdateManyMutationInput, EmailSettingUncheckedUpdateManyWithoutWebinarTemplateInput>
  }

  export type EmailContactCreateWithoutAudiencesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    isSubscriber?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: EmailContactInteractionCreateNestedManyWithoutContactInput
    emailSingleSendLogs?: EmailSingleSendLogCreateNestedManyWithoutContactInput
  }

  export type EmailContactUncheckedCreateWithoutAudiencesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    isSubscriber?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: EmailContactInteractionUncheckedCreateNestedManyWithoutContactInput
    emailSingleSendLogs?: EmailSingleSendLogUncheckedCreateNestedManyWithoutContactInput
  }

  export type EmailContactCreateOrConnectWithoutAudiencesInput = {
    where: EmailContactWhereUniqueInput
    create: XOR<EmailContactCreateWithoutAudiencesInput, EmailContactUncheckedCreateWithoutAudiencesInput>
  }

  export type EmailSingleSendCreateWithoutAudiencesInput = {
    id?: string
    name: string
    subject?: string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailSingleSendLogs?: EmailSingleSendLogCreateNestedManyWithoutSingleSendInput
  }

  export type EmailSingleSendUncheckedCreateWithoutAudiencesInput = {
    id?: string
    name: string
    subject?: string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailSingleSendLogs?: EmailSingleSendLogUncheckedCreateNestedManyWithoutSingleSendInput
  }

  export type EmailSingleSendCreateOrConnectWithoutAudiencesInput = {
    where: EmailSingleSendWhereUniqueInput
    create: XOR<EmailSingleSendCreateWithoutAudiencesInput, EmailSingleSendUncheckedCreateWithoutAudiencesInput>
  }

  export type EmailContactUpsertWithWhereUniqueWithoutAudiencesInput = {
    where: EmailContactWhereUniqueInput
    update: XOR<EmailContactUpdateWithoutAudiencesInput, EmailContactUncheckedUpdateWithoutAudiencesInput>
    create: XOR<EmailContactCreateWithoutAudiencesInput, EmailContactUncheckedCreateWithoutAudiencesInput>
  }

  export type EmailContactUpdateWithWhereUniqueWithoutAudiencesInput = {
    where: EmailContactWhereUniqueInput
    data: XOR<EmailContactUpdateWithoutAudiencesInput, EmailContactUncheckedUpdateWithoutAudiencesInput>
  }

  export type EmailContactUpdateManyWithWhereWithoutAudiencesInput = {
    where: EmailContactScalarWhereInput
    data: XOR<EmailContactUpdateManyMutationInput, EmailContactUncheckedUpdateManyWithoutAudiencesInput>
  }

  export type EmailContactScalarWhereInput = {
    AND?: EmailContactScalarWhereInput | EmailContactScalarWhereInput[]
    OR?: EmailContactScalarWhereInput[]
    NOT?: EmailContactScalarWhereInput | EmailContactScalarWhereInput[]
    id?: StringFilter<"EmailContact"> | string
    firstName?: StringNullableFilter<"EmailContact"> | string | null
    lastName?: StringNullableFilter<"EmailContact"> | string | null
    email?: StringFilter<"EmailContact"> | string
    emailVerified?: DateTimeNullableFilter<"EmailContact"> | Date | string | null
    isSubscriber?: BoolFilter<"EmailContact"> | boolean
    createdAt?: DateTimeFilter<"EmailContact"> | Date | string
    updatedAt?: DateTimeFilter<"EmailContact"> | Date | string
  }

  export type EmailSingleSendUpsertWithWhereUniqueWithoutAudiencesInput = {
    where: EmailSingleSendWhereUniqueInput
    update: XOR<EmailSingleSendUpdateWithoutAudiencesInput, EmailSingleSendUncheckedUpdateWithoutAudiencesInput>
    create: XOR<EmailSingleSendCreateWithoutAudiencesInput, EmailSingleSendUncheckedCreateWithoutAudiencesInput>
  }

  export type EmailSingleSendUpdateWithWhereUniqueWithoutAudiencesInput = {
    where: EmailSingleSendWhereUniqueInput
    data: XOR<EmailSingleSendUpdateWithoutAudiencesInput, EmailSingleSendUncheckedUpdateWithoutAudiencesInput>
  }

  export type EmailSingleSendUpdateManyWithWhereWithoutAudiencesInput = {
    where: EmailSingleSendScalarWhereInput
    data: XOR<EmailSingleSendUpdateManyMutationInput, EmailSingleSendUncheckedUpdateManyWithoutAudiencesInput>
  }

  export type EmailSingleSendScalarWhereInput = {
    AND?: EmailSingleSendScalarWhereInput | EmailSingleSendScalarWhereInput[]
    OR?: EmailSingleSendScalarWhereInput[]
    NOT?: EmailSingleSendScalarWhereInput | EmailSingleSendScalarWhereInput[]
    id?: StringFilter<"EmailSingleSend"> | string
    name?: StringFilter<"EmailSingleSend"> | string
    subject?: StringNullableFilter<"EmailSingleSend"> | string | null
    designData?: JsonNullableFilter<"EmailSingleSend">
    bodyHtml?: StringNullableFilter<"EmailSingleSend"> | string | null
    createdAt?: DateTimeFilter<"EmailSingleSend"> | Date | string
    updatedAt?: DateTimeFilter<"EmailSingleSend"> | Date | string
  }

  export type EmailAudienceCreateWithoutContactsInput = {
    id?: string
    name: string
    type?: $Enums.AudienceType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailSingleSends?: EmailSingleSendCreateNestedManyWithoutAudiencesInput
  }

  export type EmailAudienceUncheckedCreateWithoutContactsInput = {
    id?: string
    name: string
    type?: $Enums.AudienceType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailSingleSends?: EmailSingleSendUncheckedCreateNestedManyWithoutAudiencesInput
  }

  export type EmailAudienceCreateOrConnectWithoutContactsInput = {
    where: EmailAudienceWhereUniqueInput
    create: XOR<EmailAudienceCreateWithoutContactsInput, EmailAudienceUncheckedCreateWithoutContactsInput>
  }

  export type EmailContactInteractionCreateWithoutContactInput = {
    id?: string
    interactionType: string
    interactionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailContactInteractionUncheckedCreateWithoutContactInput = {
    id?: string
    interactionType: string
    interactionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailContactInteractionCreateOrConnectWithoutContactInput = {
    where: EmailContactInteractionWhereUniqueInput
    create: XOR<EmailContactInteractionCreateWithoutContactInput, EmailContactInteractionUncheckedCreateWithoutContactInput>
  }

  export type EmailContactInteractionCreateManyContactInputEnvelope = {
    data: EmailContactInteractionCreateManyContactInput | EmailContactInteractionCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type EmailSingleSendLogCreateWithoutContactInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    singleSend: EmailSingleSendCreateNestedOneWithoutEmailSingleSendLogsInput
  }

  export type EmailSingleSendLogUncheckedCreateWithoutContactInput = {
    id?: string
    singleSendId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailSingleSendLogCreateOrConnectWithoutContactInput = {
    where: EmailSingleSendLogWhereUniqueInput
    create: XOR<EmailSingleSendLogCreateWithoutContactInput, EmailSingleSendLogUncheckedCreateWithoutContactInput>
  }

  export type EmailSingleSendLogCreateManyContactInputEnvelope = {
    data: EmailSingleSendLogCreateManyContactInput | EmailSingleSendLogCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type EmailAudienceUpsertWithWhereUniqueWithoutContactsInput = {
    where: EmailAudienceWhereUniqueInput
    update: XOR<EmailAudienceUpdateWithoutContactsInput, EmailAudienceUncheckedUpdateWithoutContactsInput>
    create: XOR<EmailAudienceCreateWithoutContactsInput, EmailAudienceUncheckedCreateWithoutContactsInput>
  }

  export type EmailAudienceUpdateWithWhereUniqueWithoutContactsInput = {
    where: EmailAudienceWhereUniqueInput
    data: XOR<EmailAudienceUpdateWithoutContactsInput, EmailAudienceUncheckedUpdateWithoutContactsInput>
  }

  export type EmailAudienceUpdateManyWithWhereWithoutContactsInput = {
    where: EmailAudienceScalarWhereInput
    data: XOR<EmailAudienceUpdateManyMutationInput, EmailAudienceUncheckedUpdateManyWithoutContactsInput>
  }

  export type EmailAudienceScalarWhereInput = {
    AND?: EmailAudienceScalarWhereInput | EmailAudienceScalarWhereInput[]
    OR?: EmailAudienceScalarWhereInput[]
    NOT?: EmailAudienceScalarWhereInput | EmailAudienceScalarWhereInput[]
    id?: StringFilter<"EmailAudience"> | string
    name?: StringFilter<"EmailAudience"> | string
    type?: EnumAudienceTypeFilter<"EmailAudience"> | $Enums.AudienceType
    description?: StringNullableFilter<"EmailAudience"> | string | null
    createdAt?: DateTimeFilter<"EmailAudience"> | Date | string
    updatedAt?: DateTimeFilter<"EmailAudience"> | Date | string
  }

  export type EmailContactInteractionUpsertWithWhereUniqueWithoutContactInput = {
    where: EmailContactInteractionWhereUniqueInput
    update: XOR<EmailContactInteractionUpdateWithoutContactInput, EmailContactInteractionUncheckedUpdateWithoutContactInput>
    create: XOR<EmailContactInteractionCreateWithoutContactInput, EmailContactInteractionUncheckedCreateWithoutContactInput>
  }

  export type EmailContactInteractionUpdateWithWhereUniqueWithoutContactInput = {
    where: EmailContactInteractionWhereUniqueInput
    data: XOR<EmailContactInteractionUpdateWithoutContactInput, EmailContactInteractionUncheckedUpdateWithoutContactInput>
  }

  export type EmailContactInteractionUpdateManyWithWhereWithoutContactInput = {
    where: EmailContactInteractionScalarWhereInput
    data: XOR<EmailContactInteractionUpdateManyMutationInput, EmailContactInteractionUncheckedUpdateManyWithoutContactInput>
  }

  export type EmailContactInteractionScalarWhereInput = {
    AND?: EmailContactInteractionScalarWhereInput | EmailContactInteractionScalarWhereInput[]
    OR?: EmailContactInteractionScalarWhereInput[]
    NOT?: EmailContactInteractionScalarWhereInput | EmailContactInteractionScalarWhereInput[]
    id?: StringFilter<"EmailContactInteraction"> | string
    interactionType?: StringFilter<"EmailContactInteraction"> | string
    interactionDate?: DateTimeFilter<"EmailContactInteraction"> | Date | string
    contactId?: StringFilter<"EmailContactInteraction"> | string
    createdAt?: DateTimeFilter<"EmailContactInteraction"> | Date | string
    updatedAt?: DateTimeFilter<"EmailContactInteraction"> | Date | string
  }

  export type EmailSingleSendLogUpsertWithWhereUniqueWithoutContactInput = {
    where: EmailSingleSendLogWhereUniqueInput
    update: XOR<EmailSingleSendLogUpdateWithoutContactInput, EmailSingleSendLogUncheckedUpdateWithoutContactInput>
    create: XOR<EmailSingleSendLogCreateWithoutContactInput, EmailSingleSendLogUncheckedCreateWithoutContactInput>
  }

  export type EmailSingleSendLogUpdateWithWhereUniqueWithoutContactInput = {
    where: EmailSingleSendLogWhereUniqueInput
    data: XOR<EmailSingleSendLogUpdateWithoutContactInput, EmailSingleSendLogUncheckedUpdateWithoutContactInput>
  }

  export type EmailSingleSendLogUpdateManyWithWhereWithoutContactInput = {
    where: EmailSingleSendLogScalarWhereInput
    data: XOR<EmailSingleSendLogUpdateManyMutationInput, EmailSingleSendLogUncheckedUpdateManyWithoutContactInput>
  }

  export type EmailSingleSendLogScalarWhereInput = {
    AND?: EmailSingleSendLogScalarWhereInput | EmailSingleSendLogScalarWhereInput[]
    OR?: EmailSingleSendLogScalarWhereInput[]
    NOT?: EmailSingleSendLogScalarWhereInput | EmailSingleSendLogScalarWhereInput[]
    id?: StringFilter<"EmailSingleSendLog"> | string
    contactId?: StringFilter<"EmailSingleSendLog"> | string
    singleSendId?: StringFilter<"EmailSingleSendLog"> | string
    createdAt?: DateTimeFilter<"EmailSingleSendLog"> | Date | string
    updatedAt?: DateTimeFilter<"EmailSingleSendLog"> | Date | string
  }

  export type EmailContactCreateWithoutInteractionsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    isSubscriber?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    audiences?: EmailAudienceCreateNestedManyWithoutContactsInput
    emailSingleSendLogs?: EmailSingleSendLogCreateNestedManyWithoutContactInput
  }

  export type EmailContactUncheckedCreateWithoutInteractionsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    isSubscriber?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    audiences?: EmailAudienceUncheckedCreateNestedManyWithoutContactsInput
    emailSingleSendLogs?: EmailSingleSendLogUncheckedCreateNestedManyWithoutContactInput
  }

  export type EmailContactCreateOrConnectWithoutInteractionsInput = {
    where: EmailContactWhereUniqueInput
    create: XOR<EmailContactCreateWithoutInteractionsInput, EmailContactUncheckedCreateWithoutInteractionsInput>
  }

  export type EmailContactUpsertWithoutInteractionsInput = {
    update: XOR<EmailContactUpdateWithoutInteractionsInput, EmailContactUncheckedUpdateWithoutInteractionsInput>
    create: XOR<EmailContactCreateWithoutInteractionsInput, EmailContactUncheckedCreateWithoutInteractionsInput>
    where?: EmailContactWhereInput
  }

  export type EmailContactUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: EmailContactWhereInput
    data: XOR<EmailContactUpdateWithoutInteractionsInput, EmailContactUncheckedUpdateWithoutInteractionsInput>
  }

  export type EmailContactUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscriber?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audiences?: EmailAudienceUpdateManyWithoutContactsNestedInput
    emailSingleSendLogs?: EmailSingleSendLogUpdateManyWithoutContactNestedInput
  }

  export type EmailContactUncheckedUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscriber?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audiences?: EmailAudienceUncheckedUpdateManyWithoutContactsNestedInput
    emailSingleSendLogs?: EmailSingleSendLogUncheckedUpdateManyWithoutContactNestedInput
  }

  export type EmailAudienceCreateWithoutEmailSingleSendsInput = {
    id?: string
    name: string
    type?: $Enums.AudienceType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: EmailContactCreateNestedManyWithoutAudiencesInput
  }

  export type EmailAudienceUncheckedCreateWithoutEmailSingleSendsInput = {
    id?: string
    name: string
    type?: $Enums.AudienceType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: EmailContactUncheckedCreateNestedManyWithoutAudiencesInput
  }

  export type EmailAudienceCreateOrConnectWithoutEmailSingleSendsInput = {
    where: EmailAudienceWhereUniqueInput
    create: XOR<EmailAudienceCreateWithoutEmailSingleSendsInput, EmailAudienceUncheckedCreateWithoutEmailSingleSendsInput>
  }

  export type EmailSingleSendLogCreateWithoutSingleSendInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: EmailContactCreateNestedOneWithoutEmailSingleSendLogsInput
  }

  export type EmailSingleSendLogUncheckedCreateWithoutSingleSendInput = {
    id?: string
    contactId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailSingleSendLogCreateOrConnectWithoutSingleSendInput = {
    where: EmailSingleSendLogWhereUniqueInput
    create: XOR<EmailSingleSendLogCreateWithoutSingleSendInput, EmailSingleSendLogUncheckedCreateWithoutSingleSendInput>
  }

  export type EmailSingleSendLogCreateManySingleSendInputEnvelope = {
    data: EmailSingleSendLogCreateManySingleSendInput | EmailSingleSendLogCreateManySingleSendInput[]
    skipDuplicates?: boolean
  }

  export type EmailAudienceUpsertWithWhereUniqueWithoutEmailSingleSendsInput = {
    where: EmailAudienceWhereUniqueInput
    update: XOR<EmailAudienceUpdateWithoutEmailSingleSendsInput, EmailAudienceUncheckedUpdateWithoutEmailSingleSendsInput>
    create: XOR<EmailAudienceCreateWithoutEmailSingleSendsInput, EmailAudienceUncheckedCreateWithoutEmailSingleSendsInput>
  }

  export type EmailAudienceUpdateWithWhereUniqueWithoutEmailSingleSendsInput = {
    where: EmailAudienceWhereUniqueInput
    data: XOR<EmailAudienceUpdateWithoutEmailSingleSendsInput, EmailAudienceUncheckedUpdateWithoutEmailSingleSendsInput>
  }

  export type EmailAudienceUpdateManyWithWhereWithoutEmailSingleSendsInput = {
    where: EmailAudienceScalarWhereInput
    data: XOR<EmailAudienceUpdateManyMutationInput, EmailAudienceUncheckedUpdateManyWithoutEmailSingleSendsInput>
  }

  export type EmailSingleSendLogUpsertWithWhereUniqueWithoutSingleSendInput = {
    where: EmailSingleSendLogWhereUniqueInput
    update: XOR<EmailSingleSendLogUpdateWithoutSingleSendInput, EmailSingleSendLogUncheckedUpdateWithoutSingleSendInput>
    create: XOR<EmailSingleSendLogCreateWithoutSingleSendInput, EmailSingleSendLogUncheckedCreateWithoutSingleSendInput>
  }

  export type EmailSingleSendLogUpdateWithWhereUniqueWithoutSingleSendInput = {
    where: EmailSingleSendLogWhereUniqueInput
    data: XOR<EmailSingleSendLogUpdateWithoutSingleSendInput, EmailSingleSendLogUncheckedUpdateWithoutSingleSendInput>
  }

  export type EmailSingleSendLogUpdateManyWithWhereWithoutSingleSendInput = {
    where: EmailSingleSendLogScalarWhereInput
    data: XOR<EmailSingleSendLogUpdateManyMutationInput, EmailSingleSendLogUncheckedUpdateManyWithoutSingleSendInput>
  }

  export type EmailContactCreateWithoutEmailSingleSendLogsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    isSubscriber?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    audiences?: EmailAudienceCreateNestedManyWithoutContactsInput
    interactions?: EmailContactInteractionCreateNestedManyWithoutContactInput
  }

  export type EmailContactUncheckedCreateWithoutEmailSingleSendLogsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    isSubscriber?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    audiences?: EmailAudienceUncheckedCreateNestedManyWithoutContactsInput
    interactions?: EmailContactInteractionUncheckedCreateNestedManyWithoutContactInput
  }

  export type EmailContactCreateOrConnectWithoutEmailSingleSendLogsInput = {
    where: EmailContactWhereUniqueInput
    create: XOR<EmailContactCreateWithoutEmailSingleSendLogsInput, EmailContactUncheckedCreateWithoutEmailSingleSendLogsInput>
  }

  export type EmailSingleSendCreateWithoutEmailSingleSendLogsInput = {
    id?: string
    name: string
    subject?: string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audiences?: EmailAudienceCreateNestedManyWithoutEmailSingleSendsInput
  }

  export type EmailSingleSendUncheckedCreateWithoutEmailSingleSendLogsInput = {
    id?: string
    name: string
    subject?: string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audiences?: EmailAudienceUncheckedCreateNestedManyWithoutEmailSingleSendsInput
  }

  export type EmailSingleSendCreateOrConnectWithoutEmailSingleSendLogsInput = {
    where: EmailSingleSendWhereUniqueInput
    create: XOR<EmailSingleSendCreateWithoutEmailSingleSendLogsInput, EmailSingleSendUncheckedCreateWithoutEmailSingleSendLogsInput>
  }

  export type EmailContactUpsertWithoutEmailSingleSendLogsInput = {
    update: XOR<EmailContactUpdateWithoutEmailSingleSendLogsInput, EmailContactUncheckedUpdateWithoutEmailSingleSendLogsInput>
    create: XOR<EmailContactCreateWithoutEmailSingleSendLogsInput, EmailContactUncheckedCreateWithoutEmailSingleSendLogsInput>
    where?: EmailContactWhereInput
  }

  export type EmailContactUpdateToOneWithWhereWithoutEmailSingleSendLogsInput = {
    where?: EmailContactWhereInput
    data: XOR<EmailContactUpdateWithoutEmailSingleSendLogsInput, EmailContactUncheckedUpdateWithoutEmailSingleSendLogsInput>
  }

  export type EmailContactUpdateWithoutEmailSingleSendLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscriber?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audiences?: EmailAudienceUpdateManyWithoutContactsNestedInput
    interactions?: EmailContactInteractionUpdateManyWithoutContactNestedInput
  }

  export type EmailContactUncheckedUpdateWithoutEmailSingleSendLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscriber?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audiences?: EmailAudienceUncheckedUpdateManyWithoutContactsNestedInput
    interactions?: EmailContactInteractionUncheckedUpdateManyWithoutContactNestedInput
  }

  export type EmailSingleSendUpsertWithoutEmailSingleSendLogsInput = {
    update: XOR<EmailSingleSendUpdateWithoutEmailSingleSendLogsInput, EmailSingleSendUncheckedUpdateWithoutEmailSingleSendLogsInput>
    create: XOR<EmailSingleSendCreateWithoutEmailSingleSendLogsInput, EmailSingleSendUncheckedCreateWithoutEmailSingleSendLogsInput>
    where?: EmailSingleSendWhereInput
  }

  export type EmailSingleSendUpdateToOneWithWhereWithoutEmailSingleSendLogsInput = {
    where?: EmailSingleSendWhereInput
    data: XOR<EmailSingleSendUpdateWithoutEmailSingleSendLogsInput, EmailSingleSendUncheckedUpdateWithoutEmailSingleSendLogsInput>
  }

  export type EmailSingleSendUpdateWithoutEmailSingleSendLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audiences?: EmailAudienceUpdateManyWithoutEmailSingleSendsNestedInput
  }

  export type EmailSingleSendUncheckedUpdateWithoutEmailSingleSendLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audiences?: EmailAudienceUncheckedUpdateManyWithoutEmailSingleSendsNestedInput
  }

  export type MediaCreateWithoutProductInput = {
    id?: string
    name: string
    key?: string | null
    url: string
    size?: number | null
    type?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    post?: PostCreateNestedManyWithoutImageCoverInput
    seo?: SeoCreateNestedManyWithoutOgTwitterImageInput
    impression?: ImpressionCreateNestedOneWithoutFileInput
    products?: ProductGalleryCreateNestedManyWithoutMediaInput
    user?: UserCreateNestedManyWithoutProfileImageInput
  }

  export type MediaUncheckedCreateWithoutProductInput = {
    id?: string
    name: string
    key?: string | null
    url: string
    size?: number | null
    type?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    post?: PostUncheckedCreateNestedManyWithoutImageCoverInput
    seo?: SeoUncheckedCreateNestedManyWithoutOgTwitterImageInput
    impression?: ImpressionUncheckedCreateNestedOneWithoutFileInput
    products?: ProductGalleryUncheckedCreateNestedManyWithoutMediaInput
    user?: UserUncheckedCreateNestedManyWithoutProfileImageInput
  }

  export type MediaCreateOrConnectWithoutProductInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutProductInput, MediaUncheckedCreateWithoutProductInput>
  }

  export type ProductCategoryCreateWithoutProductsInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    root?: ProductCategoryCreateNestedOneWithoutRootChildrenInput
    rootChildren?: ProductCategoryCreateNestedManyWithoutRootInput
    seo?: SeoCreateNestedOneWithoutProductCategoriesInput
  }

  export type ProductCategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    rootId?: string | null
    seoId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: ProductCategoryUncheckedCreateNestedManyWithoutRootInput
  }

  export type ProductCategoryCreateOrConnectWithoutProductsInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
  }

  export type ProductExtraCreateWithoutProductInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductExtraUncheckedCreateWithoutProductInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductExtraCreateOrConnectWithoutProductInput = {
    where: ProductExtraWhereUniqueInput
    create: XOR<ProductExtraCreateWithoutProductInput, ProductExtraUncheckedCreateWithoutProductInput>
  }

  export type ProductExtraCreateManyProductInputEnvelope = {
    data: ProductExtraCreateManyProductInput | ProductExtraCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type FormCreateWithoutProductsInput = {
    id?: string
    name: string
    fields?:PrismaJson.FormFields | NullableJsonNullValueInput
    submitLabel?: string | null
    gtmEventName?: string | null
    gtmCategory?: string | null
    gtmLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    submissions?: FormSubmissionCreateNestedManyWithoutFormInput
  }

  export type FormUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    fields?:PrismaJson.FormFields | NullableJsonNullValueInput
    submitLabel?: string | null
    gtmEventName?: string | null
    gtmCategory?: string | null
    gtmLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    submissions?: FormSubmissionUncheckedCreateNestedManyWithoutFormInput
  }

  export type FormCreateOrConnectWithoutProductsInput = {
    where: FormWhereUniqueInput
    create: XOR<FormCreateWithoutProductsInput, FormUncheckedCreateWithoutProductsInput>
  }

  export type ProductCreateWithoutRootChildrenInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: Date | string
    updatedAt?: Date | string
    imageCover?: MediaCreateNestedOneWithoutProductInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    extras?: ProductExtraCreateNestedManyWithoutProductInput
    form?: FormCreateNestedOneWithoutProductsInput
    root?: ProductCreateNestedOneWithoutRootChildrenInput
    gallery?: ProductGalleryCreateNestedManyWithoutProductInput
    faqs?: ProductFAQCreateNestedManyWithoutProductInput
    purchases?: PurchaseCreateNestedManyWithoutProductInput
    seo?: SeoCreateNestedOneWithoutProductsInput
    user?: UserCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutRootChildrenInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    imageCoverId?: string | null
    categoryId?: string | null
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: string | null
    rootId?: string | null
    seoId?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    extras?: ProductExtraUncheckedCreateNestedManyWithoutProductInput
    gallery?: ProductGalleryUncheckedCreateNestedManyWithoutProductInput
    faqs?: ProductFAQUncheckedCreateNestedManyWithoutProductInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutRootChildrenInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutRootChildrenInput, ProductUncheckedCreateWithoutRootChildrenInput>
  }

  export type ProductCreateWithoutRootInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: Date | string
    updatedAt?: Date | string
    imageCover?: MediaCreateNestedOneWithoutProductInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    extras?: ProductExtraCreateNestedManyWithoutProductInput
    form?: FormCreateNestedOneWithoutProductsInput
    rootChildren?: ProductCreateNestedManyWithoutRootInput
    gallery?: ProductGalleryCreateNestedManyWithoutProductInput
    faqs?: ProductFAQCreateNestedManyWithoutProductInput
    purchases?: PurchaseCreateNestedManyWithoutProductInput
    seo?: SeoCreateNestedOneWithoutProductsInput
    user?: UserCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutRootInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    imageCoverId?: string | null
    categoryId?: string | null
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: string | null
    seoId?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    extras?: ProductExtraUncheckedCreateNestedManyWithoutProductInput
    rootChildren?: ProductUncheckedCreateNestedManyWithoutRootInput
    gallery?: ProductGalleryUncheckedCreateNestedManyWithoutProductInput
    faqs?: ProductFAQUncheckedCreateNestedManyWithoutProductInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutRootInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutRootInput, ProductUncheckedCreateWithoutRootInput>
  }

  export type ProductCreateManyRootInputEnvelope = {
    data: ProductCreateManyRootInput | ProductCreateManyRootInput[]
    skipDuplicates?: boolean
  }

  export type ProductGalleryCreateWithoutProductInput = {
    id?: string
    sort: number
    media: MediaCreateNestedOneWithoutProductsInput
  }

  export type ProductGalleryUncheckedCreateWithoutProductInput = {
    id?: string
    sort: number
    mediaId: string
  }

  export type ProductGalleryCreateOrConnectWithoutProductInput = {
    where: ProductGalleryWhereUniqueInput
    create: XOR<ProductGalleryCreateWithoutProductInput, ProductGalleryUncheckedCreateWithoutProductInput>
  }

  export type ProductGalleryCreateManyProductInputEnvelope = {
    data: ProductGalleryCreateManyProductInput | ProductGalleryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductFAQCreateWithoutProductInput = {
    id?: string
    question: string
    answer: string
    sort: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductFAQUncheckedCreateWithoutProductInput = {
    id?: string
    question: string
    answer: string
    sort: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductFAQCreateOrConnectWithoutProductInput = {
    where: ProductFAQWhereUniqueInput
    create: XOR<ProductFAQCreateWithoutProductInput, ProductFAQUncheckedCreateWithoutProductInput>
  }

  export type ProductFAQCreateManyProductInputEnvelope = {
    data: ProductFAQCreateManyProductInput | ProductFAQCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseCreateWithoutProductInput = {
    id?: string
    email: string
    productRootId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseUncheckedCreateWithoutProductInput = {
    id?: string
    email: string
    productRootId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseCreateOrConnectWithoutProductInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutProductInput, PurchaseUncheckedCreateWithoutProductInput>
  }

  export type PurchaseCreateManyProductInputEnvelope = {
    data: PurchaseCreateManyProductInput | PurchaseCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SeoCreateWithoutProductsInput = {
    id?: string
    title: string
    description?: string | null
    canonicalUrl?: string | null
    version: number
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: string | null
    ogTwitterTitle?: string | null
    ogTwitterDescription?: string | null
    ogTwitterLocale?: string | null
    ogTwitterUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ogTwitterImage?: MediaCreateNestedOneWithoutSeoInput
    root?: SeoCreateNestedOneWithoutRootChildrenInput
    rootChildren?: SeoCreateNestedManyWithoutRootInput
    settings?: SettingsCreateNestedManyWithoutSeoInput
    posts?: PostCreateNestedManyWithoutSeoInput
    categories?: CategoryCreateNestedManyWithoutSeoInput
    tags?: TagCreateNestedManyWithoutSeoInput
    productCategories?: ProductCategoryCreateNestedManyWithoutSeoInput
  }

  export type SeoUncheckedCreateWithoutProductsInput = {
    id?: string
    title: string
    description?: string | null
    canonicalUrl?: string | null
    version: number
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: string | null
    ogTwitterTitle?: string | null
    ogTwitterDescription?: string | null
    ogTwitterImageId?: string | null
    ogTwitterLocale?: string | null
    ogTwitterUrl?: string | null
    rootId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: SeoUncheckedCreateNestedManyWithoutRootInput
    settings?: SettingsUncheckedCreateNestedManyWithoutSeoInput
    posts?: PostUncheckedCreateNestedManyWithoutSeoInput
    categories?: CategoryUncheckedCreateNestedManyWithoutSeoInput
    tags?: TagUncheckedCreateNestedManyWithoutSeoInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutSeoInput
  }

  export type SeoCreateOrConnectWithoutProductsInput = {
    where: SeoWhereUniqueInput
    create: XOR<SeoCreateWithoutProductsInput, SeoUncheckedCreateWithoutProductsInput>
  }

  export type UserCreateWithoutProductsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    bio?: string | null
    imageUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    profileImage?: MediaCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    postAuthors?: PostAuthorCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProductsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    profileImageId?: string | null
    bio?: string | null
    imageUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    postAuthors?: PostAuthorUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProductsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
  }

  export type MediaUpsertWithoutProductInput = {
    update: XOR<MediaUpdateWithoutProductInput, MediaUncheckedUpdateWithoutProductInput>
    create: XOR<MediaCreateWithoutProductInput, MediaUncheckedCreateWithoutProductInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutProductInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutProductInput, MediaUncheckedUpdateWithoutProductInput>
  }

  export type MediaUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateManyWithoutImageCoverNestedInput
    seo?: SeoUpdateManyWithoutOgTwitterImageNestedInput
    impression?: ImpressionUpdateOneWithoutFileNestedInput
    products?: ProductGalleryUpdateManyWithoutMediaNestedInput
    user?: UserUpdateManyWithoutProfileImageNestedInput
  }

  export type MediaUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUncheckedUpdateManyWithoutImageCoverNestedInput
    seo?: SeoUncheckedUpdateManyWithoutOgTwitterImageNestedInput
    impression?: ImpressionUncheckedUpdateOneWithoutFileNestedInput
    products?: ProductGalleryUncheckedUpdateManyWithoutMediaNestedInput
    user?: UserUncheckedUpdateManyWithoutProfileImageNestedInput
  }

  export type ProductCategoryUpsertWithoutProductsInput = {
    update: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    root?: ProductCategoryUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: ProductCategoryUpdateManyWithoutRootNestedInput
    seo?: SeoUpdateOneWithoutProductCategoriesNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: ProductCategoryUncheckedUpdateManyWithoutRootNestedInput
  }

  export type ProductExtraUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductExtraWhereUniqueInput
    update: XOR<ProductExtraUpdateWithoutProductInput, ProductExtraUncheckedUpdateWithoutProductInput>
    create: XOR<ProductExtraCreateWithoutProductInput, ProductExtraUncheckedCreateWithoutProductInput>
  }

  export type ProductExtraUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductExtraWhereUniqueInput
    data: XOR<ProductExtraUpdateWithoutProductInput, ProductExtraUncheckedUpdateWithoutProductInput>
  }

  export type ProductExtraUpdateManyWithWhereWithoutProductInput = {
    where: ProductExtraScalarWhereInput
    data: XOR<ProductExtraUpdateManyMutationInput, ProductExtraUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductExtraScalarWhereInput = {
    AND?: ProductExtraScalarWhereInput | ProductExtraScalarWhereInput[]
    OR?: ProductExtraScalarWhereInput[]
    NOT?: ProductExtraScalarWhereInput | ProductExtraScalarWhereInput[]
    id?: StringFilter<"ProductExtra"> | string
    name?: StringFilter<"ProductExtra"> | string
    description?: StringNullableFilter<"ProductExtra"> | string | null
    price?: FloatFilter<"ProductExtra"> | number
    productId?: StringFilter<"ProductExtra"> | string
    createdAt?: DateTimeFilter<"ProductExtra"> | Date | string
    updatedAt?: DateTimeFilter<"ProductExtra"> | Date | string
  }

  export type FormUpsertWithoutProductsInput = {
    update: XOR<FormUpdateWithoutProductsInput, FormUncheckedUpdateWithoutProductsInput>
    create: XOR<FormCreateWithoutProductsInput, FormUncheckedCreateWithoutProductsInput>
    where?: FormWhereInput
  }

  export type FormUpdateToOneWithWhereWithoutProductsInput = {
    where?: FormWhereInput
    data: XOR<FormUpdateWithoutProductsInput, FormUncheckedUpdateWithoutProductsInput>
  }

  export type FormUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fields?:PrismaJson.FormFields | NullableJsonNullValueInput
    submitLabel?: NullableStringFieldUpdateOperationsInput | string | null
    gtmEventName?: NullableStringFieldUpdateOperationsInput | string | null
    gtmCategory?: NullableStringFieldUpdateOperationsInput | string | null
    gtmLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissions?: FormSubmissionUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fields?:PrismaJson.FormFields | NullableJsonNullValueInput
    submitLabel?: NullableStringFieldUpdateOperationsInput | string | null
    gtmEventName?: NullableStringFieldUpdateOperationsInput | string | null
    gtmCategory?: NullableStringFieldUpdateOperationsInput | string | null
    gtmLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissions?: FormSubmissionUncheckedUpdateManyWithoutFormNestedInput
  }

  export type ProductUpsertWithoutRootChildrenInput = {
    update: XOR<ProductUpdateWithoutRootChildrenInput, ProductUncheckedUpdateWithoutRootChildrenInput>
    create: XOR<ProductCreateWithoutRootChildrenInput, ProductUncheckedCreateWithoutRootChildrenInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutRootChildrenInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutRootChildrenInput, ProductUncheckedUpdateWithoutRootChildrenInput>
  }

  export type ProductUpdateWithoutRootChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageCover?: MediaUpdateOneWithoutProductNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    extras?: ProductExtraUpdateManyWithoutProductNestedInput
    form?: FormUpdateOneWithoutProductsNestedInput
    root?: ProductUpdateOneWithoutRootChildrenNestedInput
    gallery?: ProductGalleryUpdateManyWithoutProductNestedInput
    faqs?: ProductFAQUpdateManyWithoutProductNestedInput
    purchases?: PurchaseUpdateManyWithoutProductNestedInput
    seo?: SeoUpdateOneWithoutProductsNestedInput
    user?: UserUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutRootChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extras?: ProductExtraUncheckedUpdateManyWithoutProductNestedInput
    gallery?: ProductGalleryUncheckedUpdateManyWithoutProductNestedInput
    faqs?: ProductFAQUncheckedUpdateManyWithoutProductNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUpsertWithWhereUniqueWithoutRootInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutRootInput, ProductUncheckedUpdateWithoutRootInput>
    create: XOR<ProductCreateWithoutRootInput, ProductUncheckedCreateWithoutRootInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutRootInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutRootInput, ProductUncheckedUpdateWithoutRootInput>
  }

  export type ProductUpdateManyWithWhereWithoutRootInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutRootInput>
  }

  export type ProductGalleryUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductGalleryWhereUniqueInput
    update: XOR<ProductGalleryUpdateWithoutProductInput, ProductGalleryUncheckedUpdateWithoutProductInput>
    create: XOR<ProductGalleryCreateWithoutProductInput, ProductGalleryUncheckedCreateWithoutProductInput>
  }

  export type ProductGalleryUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductGalleryWhereUniqueInput
    data: XOR<ProductGalleryUpdateWithoutProductInput, ProductGalleryUncheckedUpdateWithoutProductInput>
  }

  export type ProductGalleryUpdateManyWithWhereWithoutProductInput = {
    where: ProductGalleryScalarWhereInput
    data: XOR<ProductGalleryUpdateManyMutationInput, ProductGalleryUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductFAQUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductFAQWhereUniqueInput
    update: XOR<ProductFAQUpdateWithoutProductInput, ProductFAQUncheckedUpdateWithoutProductInput>
    create: XOR<ProductFAQCreateWithoutProductInput, ProductFAQUncheckedCreateWithoutProductInput>
  }

  export type ProductFAQUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductFAQWhereUniqueInput
    data: XOR<ProductFAQUpdateWithoutProductInput, ProductFAQUncheckedUpdateWithoutProductInput>
  }

  export type ProductFAQUpdateManyWithWhereWithoutProductInput = {
    where: ProductFAQScalarWhereInput
    data: XOR<ProductFAQUpdateManyMutationInput, ProductFAQUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductFAQScalarWhereInput = {
    AND?: ProductFAQScalarWhereInput | ProductFAQScalarWhereInput[]
    OR?: ProductFAQScalarWhereInput[]
    NOT?: ProductFAQScalarWhereInput | ProductFAQScalarWhereInput[]
    id?: StringFilter<"ProductFAQ"> | string
    question?: StringFilter<"ProductFAQ"> | string
    answer?: StringFilter<"ProductFAQ"> | string
    sort?: IntFilter<"ProductFAQ"> | number
    productId?: StringFilter<"ProductFAQ"> | string
    createdAt?: DateTimeFilter<"ProductFAQ"> | Date | string
    updatedAt?: DateTimeFilter<"ProductFAQ"> | Date | string
  }

  export type PurchaseUpsertWithWhereUniqueWithoutProductInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutProductInput, PurchaseUncheckedUpdateWithoutProductInput>
    create: XOR<PurchaseCreateWithoutProductInput, PurchaseUncheckedCreateWithoutProductInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutProductInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutProductInput, PurchaseUncheckedUpdateWithoutProductInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutProductInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutProductInput>
  }

  export type PurchaseScalarWhereInput = {
    AND?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    OR?: PurchaseScalarWhereInput[]
    NOT?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    id?: StringFilter<"Purchase"> | string
    email?: StringFilter<"Purchase"> | string
    productId?: StringFilter<"Purchase"> | string
    productRootId?: StringFilter<"Purchase"> | string
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
  }

  export type SeoUpsertWithoutProductsInput = {
    update: XOR<SeoUpdateWithoutProductsInput, SeoUncheckedUpdateWithoutProductsInput>
    create: XOR<SeoCreateWithoutProductsInput, SeoUncheckedCreateWithoutProductsInput>
    where?: SeoWhereInput
  }

  export type SeoUpdateToOneWithWhereWithoutProductsInput = {
    where?: SeoWhereInput
    data: XOR<SeoUpdateWithoutProductsInput, SeoUncheckedUpdateWithoutProductsInput>
  }

  export type SeoUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    ogTwitterType?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterLocale?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ogTwitterImage?: MediaUpdateOneWithoutSeoNestedInput
    root?: SeoUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: SeoUpdateManyWithoutRootNestedInput
    settings?: SettingsUpdateManyWithoutSeoNestedInput
    posts?: PostUpdateManyWithoutSeoNestedInput
    categories?: CategoryUpdateManyWithoutSeoNestedInput
    tags?: TagUpdateManyWithoutSeoNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutSeoNestedInput
  }

  export type SeoUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    ogTwitterType?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterImageId?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterLocale?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: SeoUncheckedUpdateManyWithoutRootNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutSeoNestedInput
    posts?: PostUncheckedUpdateManyWithoutSeoNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutSeoNestedInput
    tags?: TagUncheckedUpdateManyWithoutSeoNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutSeoNestedInput
  }

  export type UserUpsertWithoutProductsInput = {
    update: XOR<UserUpdateWithoutProductsInput, UserUncheckedUpdateWithoutProductsInput>
    create: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductsInput, UserUncheckedUpdateWithoutProductsInput>
  }

  export type UserUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: MediaUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    postAuthors?: PostAuthorUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageId?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    postAuthors?: PostAuthorUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductCategoryCreateWithoutRootChildrenInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    root?: ProductCategoryCreateNestedOneWithoutRootChildrenInput
    products?: ProductCreateNestedManyWithoutCategoryInput
    seo?: SeoCreateNestedOneWithoutProductCategoriesInput
  }

  export type ProductCategoryUncheckedCreateWithoutRootChildrenInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    rootId?: string | null
    seoId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutRootChildrenInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutRootChildrenInput, ProductCategoryUncheckedCreateWithoutRootChildrenInput>
  }

  export type ProductCategoryCreateWithoutRootInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: ProductCategoryCreateNestedManyWithoutRootInput
    products?: ProductCreateNestedManyWithoutCategoryInput
    seo?: SeoCreateNestedOneWithoutProductCategoriesInput
  }

  export type ProductCategoryUncheckedCreateWithoutRootInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    seoId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: ProductCategoryUncheckedCreateNestedManyWithoutRootInput
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutRootInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutRootInput, ProductCategoryUncheckedCreateWithoutRootInput>
  }

  export type ProductCategoryCreateManyRootInputEnvelope = {
    data: ProductCategoryCreateManyRootInput | ProductCategoryCreateManyRootInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutCategoryInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: Date | string
    updatedAt?: Date | string
    imageCover?: MediaCreateNestedOneWithoutProductInput
    extras?: ProductExtraCreateNestedManyWithoutProductInput
    form?: FormCreateNestedOneWithoutProductsInput
    root?: ProductCreateNestedOneWithoutRootChildrenInput
    rootChildren?: ProductCreateNestedManyWithoutRootInput
    gallery?: ProductGalleryCreateNestedManyWithoutProductInput
    faqs?: ProductFAQCreateNestedManyWithoutProductInput
    purchases?: PurchaseCreateNestedManyWithoutProductInput
    seo?: SeoCreateNestedOneWithoutProductsInput
    user?: UserCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    imageCoverId?: string | null
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: string | null
    rootId?: string | null
    seoId?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    extras?: ProductExtraUncheckedCreateNestedManyWithoutProductInput
    rootChildren?: ProductUncheckedCreateNestedManyWithoutRootInput
    gallery?: ProductGalleryUncheckedCreateNestedManyWithoutProductInput
    faqs?: ProductFAQUncheckedCreateNestedManyWithoutProductInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type SeoCreateWithoutProductCategoriesInput = {
    id?: string
    title: string
    description?: string | null
    canonicalUrl?: string | null
    version: number
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: string | null
    ogTwitterTitle?: string | null
    ogTwitterDescription?: string | null
    ogTwitterLocale?: string | null
    ogTwitterUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ogTwitterImage?: MediaCreateNestedOneWithoutSeoInput
    root?: SeoCreateNestedOneWithoutRootChildrenInput
    rootChildren?: SeoCreateNestedManyWithoutRootInput
    settings?: SettingsCreateNestedManyWithoutSeoInput
    posts?: PostCreateNestedManyWithoutSeoInput
    categories?: CategoryCreateNestedManyWithoutSeoInput
    tags?: TagCreateNestedManyWithoutSeoInput
    products?: ProductCreateNestedManyWithoutSeoInput
  }

  export type SeoUncheckedCreateWithoutProductCategoriesInput = {
    id?: string
    title: string
    description?: string | null
    canonicalUrl?: string | null
    version: number
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: string | null
    ogTwitterTitle?: string | null
    ogTwitterDescription?: string | null
    ogTwitterImageId?: string | null
    ogTwitterLocale?: string | null
    ogTwitterUrl?: string | null
    rootId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: SeoUncheckedCreateNestedManyWithoutRootInput
    settings?: SettingsUncheckedCreateNestedManyWithoutSeoInput
    posts?: PostUncheckedCreateNestedManyWithoutSeoInput
    categories?: CategoryUncheckedCreateNestedManyWithoutSeoInput
    tags?: TagUncheckedCreateNestedManyWithoutSeoInput
    products?: ProductUncheckedCreateNestedManyWithoutSeoInput
  }

  export type SeoCreateOrConnectWithoutProductCategoriesInput = {
    where: SeoWhereUniqueInput
    create: XOR<SeoCreateWithoutProductCategoriesInput, SeoUncheckedCreateWithoutProductCategoriesInput>
  }

  export type ProductCategoryUpsertWithoutRootChildrenInput = {
    update: XOR<ProductCategoryUpdateWithoutRootChildrenInput, ProductCategoryUncheckedUpdateWithoutRootChildrenInput>
    create: XOR<ProductCategoryCreateWithoutRootChildrenInput, ProductCategoryUncheckedCreateWithoutRootChildrenInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutRootChildrenInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutRootChildrenInput, ProductCategoryUncheckedUpdateWithoutRootChildrenInput>
  }

  export type ProductCategoryUpdateWithoutRootChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    root?: ProductCategoryUpdateOneWithoutRootChildrenNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
    seo?: SeoUpdateOneWithoutProductCategoriesNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutRootChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutRootInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutRootInput, ProductCategoryUncheckedUpdateWithoutRootInput>
    create: XOR<ProductCategoryCreateWithoutRootInput, ProductCategoryUncheckedCreateWithoutRootInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutRootInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutRootInput, ProductCategoryUncheckedUpdateWithoutRootInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutRootInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutRootInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type SeoUpsertWithoutProductCategoriesInput = {
    update: XOR<SeoUpdateWithoutProductCategoriesInput, SeoUncheckedUpdateWithoutProductCategoriesInput>
    create: XOR<SeoCreateWithoutProductCategoriesInput, SeoUncheckedCreateWithoutProductCategoriesInput>
    where?: SeoWhereInput
  }

  export type SeoUpdateToOneWithWhereWithoutProductCategoriesInput = {
    where?: SeoWhereInput
    data: XOR<SeoUpdateWithoutProductCategoriesInput, SeoUncheckedUpdateWithoutProductCategoriesInput>
  }

  export type SeoUpdateWithoutProductCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    ogTwitterType?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterLocale?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ogTwitterImage?: MediaUpdateOneWithoutSeoNestedInput
    root?: SeoUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: SeoUpdateManyWithoutRootNestedInput
    settings?: SettingsUpdateManyWithoutSeoNestedInput
    posts?: PostUpdateManyWithoutSeoNestedInput
    categories?: CategoryUpdateManyWithoutSeoNestedInput
    tags?: TagUpdateManyWithoutSeoNestedInput
    products?: ProductUpdateManyWithoutSeoNestedInput
  }

  export type SeoUncheckedUpdateWithoutProductCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    ogTwitterType?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterImageId?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterLocale?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: SeoUncheckedUpdateManyWithoutRootNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutSeoNestedInput
    posts?: PostUncheckedUpdateManyWithoutSeoNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutSeoNestedInput
    tags?: TagUncheckedUpdateManyWithoutSeoNestedInput
    products?: ProductUncheckedUpdateManyWithoutSeoNestedInput
  }

  export type ProductCreateWithoutGalleryInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: Date | string
    updatedAt?: Date | string
    imageCover?: MediaCreateNestedOneWithoutProductInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    extras?: ProductExtraCreateNestedManyWithoutProductInput
    form?: FormCreateNestedOneWithoutProductsInput
    root?: ProductCreateNestedOneWithoutRootChildrenInput
    rootChildren?: ProductCreateNestedManyWithoutRootInput
    faqs?: ProductFAQCreateNestedManyWithoutProductInput
    purchases?: PurchaseCreateNestedManyWithoutProductInput
    seo?: SeoCreateNestedOneWithoutProductsInput
    user?: UserCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutGalleryInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    imageCoverId?: string | null
    categoryId?: string | null
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: string | null
    rootId?: string | null
    seoId?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    extras?: ProductExtraUncheckedCreateNestedManyWithoutProductInput
    rootChildren?: ProductUncheckedCreateNestedManyWithoutRootInput
    faqs?: ProductFAQUncheckedCreateNestedManyWithoutProductInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutGalleryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutGalleryInput, ProductUncheckedCreateWithoutGalleryInput>
  }

  export type MediaCreateWithoutProductsInput = {
    id?: string
    name: string
    key?: string | null
    url: string
    size?: number | null
    type?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    post?: PostCreateNestedManyWithoutImageCoverInput
    seo?: SeoCreateNestedManyWithoutOgTwitterImageInput
    product?: ProductCreateNestedManyWithoutImageCoverInput
    impression?: ImpressionCreateNestedOneWithoutFileInput
    user?: UserCreateNestedManyWithoutProfileImageInput
  }

  export type MediaUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    key?: string | null
    url: string
    size?: number | null
    type?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    post?: PostUncheckedCreateNestedManyWithoutImageCoverInput
    seo?: SeoUncheckedCreateNestedManyWithoutOgTwitterImageInput
    product?: ProductUncheckedCreateNestedManyWithoutImageCoverInput
    impression?: ImpressionUncheckedCreateNestedOneWithoutFileInput
    user?: UserUncheckedCreateNestedManyWithoutProfileImageInput
  }

  export type MediaCreateOrConnectWithoutProductsInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutProductsInput, MediaUncheckedCreateWithoutProductsInput>
  }

  export type ProductUpsertWithoutGalleryInput = {
    update: XOR<ProductUpdateWithoutGalleryInput, ProductUncheckedUpdateWithoutGalleryInput>
    create: XOR<ProductCreateWithoutGalleryInput, ProductUncheckedCreateWithoutGalleryInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutGalleryInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutGalleryInput, ProductUncheckedUpdateWithoutGalleryInput>
  }

  export type ProductUpdateWithoutGalleryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageCover?: MediaUpdateOneWithoutProductNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    extras?: ProductExtraUpdateManyWithoutProductNestedInput
    form?: FormUpdateOneWithoutProductsNestedInput
    root?: ProductUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: ProductUpdateManyWithoutRootNestedInput
    faqs?: ProductFAQUpdateManyWithoutProductNestedInput
    purchases?: PurchaseUpdateManyWithoutProductNestedInput
    seo?: SeoUpdateOneWithoutProductsNestedInput
    user?: UserUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutGalleryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extras?: ProductExtraUncheckedUpdateManyWithoutProductNestedInput
    rootChildren?: ProductUncheckedUpdateManyWithoutRootNestedInput
    faqs?: ProductFAQUncheckedUpdateManyWithoutProductNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
  }

  export type MediaUpsertWithoutProductsInput = {
    update: XOR<MediaUpdateWithoutProductsInput, MediaUncheckedUpdateWithoutProductsInput>
    create: XOR<MediaCreateWithoutProductsInput, MediaUncheckedCreateWithoutProductsInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutProductsInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutProductsInput, MediaUncheckedUpdateWithoutProductsInput>
  }

  export type MediaUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateManyWithoutImageCoverNestedInput
    seo?: SeoUpdateManyWithoutOgTwitterImageNestedInput
    product?: ProductUpdateManyWithoutImageCoverNestedInput
    impression?: ImpressionUpdateOneWithoutFileNestedInput
    user?: UserUpdateManyWithoutProfileImageNestedInput
  }

  export type MediaUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUncheckedUpdateManyWithoutImageCoverNestedInput
    seo?: SeoUncheckedUpdateManyWithoutOgTwitterImageNestedInput
    product?: ProductUncheckedUpdateManyWithoutImageCoverNestedInput
    impression?: ImpressionUncheckedUpdateOneWithoutFileNestedInput
    user?: UserUncheckedUpdateManyWithoutProfileImageNestedInput
  }

  export type ProductCreateWithoutExtrasInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: Date | string
    updatedAt?: Date | string
    imageCover?: MediaCreateNestedOneWithoutProductInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    form?: FormCreateNestedOneWithoutProductsInput
    root?: ProductCreateNestedOneWithoutRootChildrenInput
    rootChildren?: ProductCreateNestedManyWithoutRootInput
    gallery?: ProductGalleryCreateNestedManyWithoutProductInput
    faqs?: ProductFAQCreateNestedManyWithoutProductInput
    purchases?: PurchaseCreateNestedManyWithoutProductInput
    seo?: SeoCreateNestedOneWithoutProductsInput
    user?: UserCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutExtrasInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    imageCoverId?: string | null
    categoryId?: string | null
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: string | null
    rootId?: string | null
    seoId?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rootChildren?: ProductUncheckedCreateNestedManyWithoutRootInput
    gallery?: ProductGalleryUncheckedCreateNestedManyWithoutProductInput
    faqs?: ProductFAQUncheckedCreateNestedManyWithoutProductInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutExtrasInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutExtrasInput, ProductUncheckedCreateWithoutExtrasInput>
  }

  export type ProductUpsertWithoutExtrasInput = {
    update: XOR<ProductUpdateWithoutExtrasInput, ProductUncheckedUpdateWithoutExtrasInput>
    create: XOR<ProductCreateWithoutExtrasInput, ProductUncheckedCreateWithoutExtrasInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutExtrasInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutExtrasInput, ProductUncheckedUpdateWithoutExtrasInput>
  }

  export type ProductUpdateWithoutExtrasInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageCover?: MediaUpdateOneWithoutProductNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    form?: FormUpdateOneWithoutProductsNestedInput
    root?: ProductUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: ProductUpdateManyWithoutRootNestedInput
    gallery?: ProductGalleryUpdateManyWithoutProductNestedInput
    faqs?: ProductFAQUpdateManyWithoutProductNestedInput
    purchases?: PurchaseUpdateManyWithoutProductNestedInput
    seo?: SeoUpdateOneWithoutProductsNestedInput
    user?: UserUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutExtrasInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: ProductUncheckedUpdateManyWithoutRootNestedInput
    gallery?: ProductGalleryUncheckedUpdateManyWithoutProductNestedInput
    faqs?: ProductFAQUncheckedUpdateManyWithoutProductNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateWithoutFaqsInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: Date | string
    updatedAt?: Date | string
    imageCover?: MediaCreateNestedOneWithoutProductInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    extras?: ProductExtraCreateNestedManyWithoutProductInput
    form?: FormCreateNestedOneWithoutProductsInput
    root?: ProductCreateNestedOneWithoutRootChildrenInput
    rootChildren?: ProductCreateNestedManyWithoutRootInput
    gallery?: ProductGalleryCreateNestedManyWithoutProductInput
    purchases?: PurchaseCreateNestedManyWithoutProductInput
    seo?: SeoCreateNestedOneWithoutProductsInput
    user?: UserCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutFaqsInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    imageCoverId?: string | null
    categoryId?: string | null
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: string | null
    rootId?: string | null
    seoId?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    extras?: ProductExtraUncheckedCreateNestedManyWithoutProductInput
    rootChildren?: ProductUncheckedCreateNestedManyWithoutRootInput
    gallery?: ProductGalleryUncheckedCreateNestedManyWithoutProductInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutFaqsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutFaqsInput, ProductUncheckedCreateWithoutFaqsInput>
  }

  export type ProductUpsertWithoutFaqsInput = {
    update: XOR<ProductUpdateWithoutFaqsInput, ProductUncheckedUpdateWithoutFaqsInput>
    create: XOR<ProductCreateWithoutFaqsInput, ProductUncheckedCreateWithoutFaqsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutFaqsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutFaqsInput, ProductUncheckedUpdateWithoutFaqsInput>
  }

  export type ProductUpdateWithoutFaqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageCover?: MediaUpdateOneWithoutProductNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    extras?: ProductExtraUpdateManyWithoutProductNestedInput
    form?: FormUpdateOneWithoutProductsNestedInput
    root?: ProductUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: ProductUpdateManyWithoutRootNestedInput
    gallery?: ProductGalleryUpdateManyWithoutProductNestedInput
    purchases?: PurchaseUpdateManyWithoutProductNestedInput
    seo?: SeoUpdateOneWithoutProductsNestedInput
    user?: UserUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutFaqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extras?: ProductExtraUncheckedUpdateManyWithoutProductNestedInput
    rootChildren?: ProductUncheckedUpdateManyWithoutRootNestedInput
    gallery?: ProductGalleryUncheckedUpdateManyWithoutProductNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
  }

  export type AdBlockCreateWithoutCampaignInput = {
    id?: string
    label: string
    layoutType: $Enums.AdLayoutType
    isActive?: boolean
    placement?: $Enums.AdPositionPlacement
    reference?: $Enums.AdPositionReference
    referenceCount?: number
    minWords?: number
    excludedPostIds?: AdBlockCreateexcludedPostIdsInput | string[]
    excludedCategoryIds?: AdBlockCreateexcludedCategoryIdsInput | string[]
    excludedTagIds?: AdBlockCreateexcludedTagIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: AdItemCreateNestedManyWithoutAdBlockInput
  }

  export type AdBlockUncheckedCreateWithoutCampaignInput = {
    id?: string
    label: string
    layoutType: $Enums.AdLayoutType
    isActive?: boolean
    placement?: $Enums.AdPositionPlacement
    reference?: $Enums.AdPositionReference
    referenceCount?: number
    minWords?: number
    excludedPostIds?: AdBlockCreateexcludedPostIdsInput | string[]
    excludedCategoryIds?: AdBlockCreateexcludedCategoryIdsInput | string[]
    excludedTagIds?: AdBlockCreateexcludedTagIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: AdItemUncheckedCreateNestedManyWithoutAdBlockInput
  }

  export type AdBlockCreateOrConnectWithoutCampaignInput = {
    where: AdBlockWhereUniqueInput
    create: XOR<AdBlockCreateWithoutCampaignInput, AdBlockUncheckedCreateWithoutCampaignInput>
  }

  export type AdBlockCreateManyCampaignInputEnvelope = {
    data: AdBlockCreateManyCampaignInput | AdBlockCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type AdBlockUpsertWithWhereUniqueWithoutCampaignInput = {
    where: AdBlockWhereUniqueInput
    update: XOR<AdBlockUpdateWithoutCampaignInput, AdBlockUncheckedUpdateWithoutCampaignInput>
    create: XOR<AdBlockCreateWithoutCampaignInput, AdBlockUncheckedCreateWithoutCampaignInput>
  }

  export type AdBlockUpdateWithWhereUniqueWithoutCampaignInput = {
    where: AdBlockWhereUniqueInput
    data: XOR<AdBlockUpdateWithoutCampaignInput, AdBlockUncheckedUpdateWithoutCampaignInput>
  }

  export type AdBlockUpdateManyWithWhereWithoutCampaignInput = {
    where: AdBlockScalarWhereInput
    data: XOR<AdBlockUpdateManyMutationInput, AdBlockUncheckedUpdateManyWithoutCampaignInput>
  }

  export type AdBlockScalarWhereInput = {
    AND?: AdBlockScalarWhereInput | AdBlockScalarWhereInput[]
    OR?: AdBlockScalarWhereInput[]
    NOT?: AdBlockScalarWhereInput | AdBlockScalarWhereInput[]
    id?: StringFilter<"AdBlock"> | string
    label?: StringFilter<"AdBlock"> | string
    layoutType?: EnumAdLayoutTypeFilter<"AdBlock"> | $Enums.AdLayoutType
    isActive?: BoolFilter<"AdBlock"> | boolean
    campaignId?: StringFilter<"AdBlock"> | string
    placement?: EnumAdPositionPlacementFilter<"AdBlock"> | $Enums.AdPositionPlacement
    reference?: EnumAdPositionReferenceFilter<"AdBlock"> | $Enums.AdPositionReference
    referenceCount?: IntFilter<"AdBlock"> | number
    minWords?: IntFilter<"AdBlock"> | number
    excludedPostIds?: StringNullableListFilter<"AdBlock">
    excludedCategoryIds?: StringNullableListFilter<"AdBlock">
    excludedTagIds?: StringNullableListFilter<"AdBlock">
    createdAt?: DateTimeFilter<"AdBlock"> | Date | string
    updatedAt?: DateTimeFilter<"AdBlock"> | Date | string
  }

  export type AdCampaignCreateWithoutBlocksInput = {
    id?: string
    name: string
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdCampaignUncheckedCreateWithoutBlocksInput = {
    id?: string
    name: string
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdCampaignCreateOrConnectWithoutBlocksInput = {
    where: AdCampaignWhereUniqueInput
    create: XOR<AdCampaignCreateWithoutBlocksInput, AdCampaignUncheckedCreateWithoutBlocksInput>
  }

  export type AdItemCreateWithoutAdBlockInput = {
    id?: string
    sourceType: $Enums.AdItemSourceType
    title?: string | null
    description?: string | null
    imageUrl?: string | null
    url?: string | null
    postRootId?: string | null
    productRootId?: string | null
    sort?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdItemUncheckedCreateWithoutAdBlockInput = {
    id?: string
    sourceType: $Enums.AdItemSourceType
    title?: string | null
    description?: string | null
    imageUrl?: string | null
    url?: string | null
    postRootId?: string | null
    productRootId?: string | null
    sort?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdItemCreateOrConnectWithoutAdBlockInput = {
    where: AdItemWhereUniqueInput
    create: XOR<AdItemCreateWithoutAdBlockInput, AdItemUncheckedCreateWithoutAdBlockInput>
  }

  export type AdItemCreateManyAdBlockInputEnvelope = {
    data: AdItemCreateManyAdBlockInput | AdItemCreateManyAdBlockInput[]
    skipDuplicates?: boolean
  }

  export type AdCampaignUpsertWithoutBlocksInput = {
    update: XOR<AdCampaignUpdateWithoutBlocksInput, AdCampaignUncheckedUpdateWithoutBlocksInput>
    create: XOR<AdCampaignCreateWithoutBlocksInput, AdCampaignUncheckedCreateWithoutBlocksInput>
    where?: AdCampaignWhereInput
  }

  export type AdCampaignUpdateToOneWithWhereWithoutBlocksInput = {
    where?: AdCampaignWhereInput
    data: XOR<AdCampaignUpdateWithoutBlocksInput, AdCampaignUncheckedUpdateWithoutBlocksInput>
  }

  export type AdCampaignUpdateWithoutBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdCampaignUncheckedUpdateWithoutBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdItemUpsertWithWhereUniqueWithoutAdBlockInput = {
    where: AdItemWhereUniqueInput
    update: XOR<AdItemUpdateWithoutAdBlockInput, AdItemUncheckedUpdateWithoutAdBlockInput>
    create: XOR<AdItemCreateWithoutAdBlockInput, AdItemUncheckedCreateWithoutAdBlockInput>
  }

  export type AdItemUpdateWithWhereUniqueWithoutAdBlockInput = {
    where: AdItemWhereUniqueInput
    data: XOR<AdItemUpdateWithoutAdBlockInput, AdItemUncheckedUpdateWithoutAdBlockInput>
  }

  export type AdItemUpdateManyWithWhereWithoutAdBlockInput = {
    where: AdItemScalarWhereInput
    data: XOR<AdItemUpdateManyMutationInput, AdItemUncheckedUpdateManyWithoutAdBlockInput>
  }

  export type AdItemScalarWhereInput = {
    AND?: AdItemScalarWhereInput | AdItemScalarWhereInput[]
    OR?: AdItemScalarWhereInput[]
    NOT?: AdItemScalarWhereInput | AdItemScalarWhereInput[]
    id?: StringFilter<"AdItem"> | string
    sourceType?: EnumAdItemSourceTypeFilter<"AdItem"> | $Enums.AdItemSourceType
    adBlockId?: StringFilter<"AdItem"> | string
    title?: StringNullableFilter<"AdItem"> | string | null
    description?: StringNullableFilter<"AdItem"> | string | null
    imageUrl?: StringNullableFilter<"AdItem"> | string | null
    url?: StringNullableFilter<"AdItem"> | string | null
    postRootId?: StringNullableFilter<"AdItem"> | string | null
    productRootId?: StringNullableFilter<"AdItem"> | string | null
    sort?: IntNullableFilter<"AdItem"> | number | null
    isActive?: BoolFilter<"AdItem"> | boolean
    createdAt?: DateTimeFilter<"AdItem"> | Date | string
    updatedAt?: DateTimeFilter<"AdItem"> | Date | string
  }

  export type AdBlockCreateWithoutItemsInput = {
    id?: string
    label: string
    layoutType: $Enums.AdLayoutType
    isActive?: boolean
    placement?: $Enums.AdPositionPlacement
    reference?: $Enums.AdPositionReference
    referenceCount?: number
    minWords?: number
    excludedPostIds?: AdBlockCreateexcludedPostIdsInput | string[]
    excludedCategoryIds?: AdBlockCreateexcludedCategoryIdsInput | string[]
    excludedTagIds?: AdBlockCreateexcludedTagIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: AdCampaignCreateNestedOneWithoutBlocksInput
  }

  export type AdBlockUncheckedCreateWithoutItemsInput = {
    id?: string
    label: string
    layoutType: $Enums.AdLayoutType
    isActive?: boolean
    campaignId: string
    placement?: $Enums.AdPositionPlacement
    reference?: $Enums.AdPositionReference
    referenceCount?: number
    minWords?: number
    excludedPostIds?: AdBlockCreateexcludedPostIdsInput | string[]
    excludedCategoryIds?: AdBlockCreateexcludedCategoryIdsInput | string[]
    excludedTagIds?: AdBlockCreateexcludedTagIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdBlockCreateOrConnectWithoutItemsInput = {
    where: AdBlockWhereUniqueInput
    create: XOR<AdBlockCreateWithoutItemsInput, AdBlockUncheckedCreateWithoutItemsInput>
  }

  export type AdBlockUpsertWithoutItemsInput = {
    update: XOR<AdBlockUpdateWithoutItemsInput, AdBlockUncheckedUpdateWithoutItemsInput>
    create: XOR<AdBlockCreateWithoutItemsInput, AdBlockUncheckedCreateWithoutItemsInput>
    where?: AdBlockWhereInput
  }

  export type AdBlockUpdateToOneWithWhereWithoutItemsInput = {
    where?: AdBlockWhereInput
    data: XOR<AdBlockUpdateWithoutItemsInput, AdBlockUncheckedUpdateWithoutItemsInput>
  }

  export type AdBlockUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    layoutType?: EnumAdLayoutTypeFieldUpdateOperationsInput | $Enums.AdLayoutType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    placement?: EnumAdPositionPlacementFieldUpdateOperationsInput | $Enums.AdPositionPlacement
    reference?: EnumAdPositionReferenceFieldUpdateOperationsInput | $Enums.AdPositionReference
    referenceCount?: IntFieldUpdateOperationsInput | number
    minWords?: IntFieldUpdateOperationsInput | number
    excludedPostIds?: AdBlockUpdateexcludedPostIdsInput | string[]
    excludedCategoryIds?: AdBlockUpdateexcludedCategoryIdsInput | string[]
    excludedTagIds?: AdBlockUpdateexcludedTagIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: AdCampaignUpdateOneRequiredWithoutBlocksNestedInput
  }

  export type AdBlockUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    layoutType?: EnumAdLayoutTypeFieldUpdateOperationsInput | $Enums.AdLayoutType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campaignId?: StringFieldUpdateOperationsInput | string
    placement?: EnumAdPositionPlacementFieldUpdateOperationsInput | $Enums.AdPositionPlacement
    reference?: EnumAdPositionReferenceFieldUpdateOperationsInput | $Enums.AdPositionReference
    referenceCount?: IntFieldUpdateOperationsInput | number
    minWords?: IntFieldUpdateOperationsInput | number
    excludedPostIds?: AdBlockUpdateexcludedPostIdsInput | string[]
    excludedCategoryIds?: AdBlockUpdateexcludedCategoryIdsInput | string[]
    excludedTagIds?: AdBlockUpdateexcludedTagIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateWithoutPurchasesInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: Date | string
    updatedAt?: Date | string
    imageCover?: MediaCreateNestedOneWithoutProductInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    extras?: ProductExtraCreateNestedManyWithoutProductInput
    form?: FormCreateNestedOneWithoutProductsInput
    root?: ProductCreateNestedOneWithoutRootChildrenInput
    rootChildren?: ProductCreateNestedManyWithoutRootInput
    gallery?: ProductGalleryCreateNestedManyWithoutProductInput
    faqs?: ProductFAQCreateNestedManyWithoutProductInput
    seo?: SeoCreateNestedOneWithoutProductsInput
    user?: UserCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutPurchasesInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    imageCoverId?: string | null
    categoryId?: string | null
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: string | null
    rootId?: string | null
    seoId?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    extras?: ProductExtraUncheckedCreateNestedManyWithoutProductInput
    rootChildren?: ProductUncheckedCreateNestedManyWithoutRootInput
    gallery?: ProductGalleryUncheckedCreateNestedManyWithoutProductInput
    faqs?: ProductFAQUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPurchasesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPurchasesInput, ProductUncheckedCreateWithoutPurchasesInput>
  }

  export type ProductUpsertWithoutPurchasesInput = {
    update: XOR<ProductUpdateWithoutPurchasesInput, ProductUncheckedUpdateWithoutPurchasesInput>
    create: XOR<ProductCreateWithoutPurchasesInput, ProductUncheckedCreateWithoutPurchasesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPurchasesInput, ProductUncheckedUpdateWithoutPurchasesInput>
  }

  export type ProductUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageCover?: MediaUpdateOneWithoutProductNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    extras?: ProductExtraUpdateManyWithoutProductNestedInput
    form?: FormUpdateOneWithoutProductsNestedInput
    root?: ProductUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: ProductUpdateManyWithoutRootNestedInput
    gallery?: ProductGalleryUpdateManyWithoutProductNestedInput
    faqs?: ProductFAQUpdateManyWithoutProductNestedInput
    seo?: SeoUpdateOneWithoutProductsNestedInput
    user?: UserUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extras?: ProductExtraUncheckedUpdateManyWithoutProductNestedInput
    rootChildren?: ProductUncheckedUpdateManyWithoutRootNestedInput
    gallery?: ProductGalleryUncheckedUpdateManyWithoutProductNestedInput
    faqs?: ProductFAQUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateWithoutFormInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: Date | string
    updatedAt?: Date | string
    imageCover?: MediaCreateNestedOneWithoutProductInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    extras?: ProductExtraCreateNestedManyWithoutProductInput
    root?: ProductCreateNestedOneWithoutRootChildrenInput
    rootChildren?: ProductCreateNestedManyWithoutRootInput
    gallery?: ProductGalleryCreateNestedManyWithoutProductInput
    faqs?: ProductFAQCreateNestedManyWithoutProductInput
    purchases?: PurchaseCreateNestedManyWithoutProductInput
    seo?: SeoCreateNestedOneWithoutProductsInput
    user?: UserCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutFormInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    imageCoverId?: string | null
    categoryId?: string | null
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    rootId?: string | null
    seoId?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    extras?: ProductExtraUncheckedCreateNestedManyWithoutProductInput
    rootChildren?: ProductUncheckedCreateNestedManyWithoutRootInput
    gallery?: ProductGalleryUncheckedCreateNestedManyWithoutProductInput
    faqs?: ProductFAQUncheckedCreateNestedManyWithoutProductInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutFormInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutFormInput, ProductUncheckedCreateWithoutFormInput>
  }

  export type ProductCreateManyFormInputEnvelope = {
    data: ProductCreateManyFormInput | ProductCreateManyFormInput[]
    skipDuplicates?: boolean
  }

  export type FormSubmissionCreateWithoutFormInput = {
    id?: string
    email?: string | null
    data:unknown
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormSubmissionUncheckedCreateWithoutFormInput = {
    id?: string
    email?: string | null
    data:unknown
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormSubmissionCreateOrConnectWithoutFormInput = {
    where: FormSubmissionWhereUniqueInput
    create: XOR<FormSubmissionCreateWithoutFormInput, FormSubmissionUncheckedCreateWithoutFormInput>
  }

  export type FormSubmissionCreateManyFormInputEnvelope = {
    data: FormSubmissionCreateManyFormInput | FormSubmissionCreateManyFormInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutFormInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutFormInput, ProductUncheckedUpdateWithoutFormInput>
    create: XOR<ProductCreateWithoutFormInput, ProductUncheckedCreateWithoutFormInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutFormInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutFormInput, ProductUncheckedUpdateWithoutFormInput>
  }

  export type ProductUpdateManyWithWhereWithoutFormInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutFormInput>
  }

  export type FormSubmissionUpsertWithWhereUniqueWithoutFormInput = {
    where: FormSubmissionWhereUniqueInput
    update: XOR<FormSubmissionUpdateWithoutFormInput, FormSubmissionUncheckedUpdateWithoutFormInput>
    create: XOR<FormSubmissionCreateWithoutFormInput, FormSubmissionUncheckedCreateWithoutFormInput>
  }

  export type FormSubmissionUpdateWithWhereUniqueWithoutFormInput = {
    where: FormSubmissionWhereUniqueInput
    data: XOR<FormSubmissionUpdateWithoutFormInput, FormSubmissionUncheckedUpdateWithoutFormInput>
  }

  export type FormSubmissionUpdateManyWithWhereWithoutFormInput = {
    where: FormSubmissionScalarWhereInput
    data: XOR<FormSubmissionUpdateManyMutationInput, FormSubmissionUncheckedUpdateManyWithoutFormInput>
  }

  export type FormSubmissionScalarWhereInput = {
    AND?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
    OR?: FormSubmissionScalarWhereInput[]
    NOT?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
    id?: StringFilter<"FormSubmission"> | string
    formId?: StringFilter<"FormSubmission"> | string
    email?: StringNullableFilter<"FormSubmission"> | string | null
    data?: JsonFilter<"FormSubmission">
    createdAt?: DateTimeFilter<"FormSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"FormSubmission"> | Date | string
  }

  export type FormCreateWithoutSubmissionsInput = {
    id?: string
    name: string
    fields?:PrismaJson.FormFields | NullableJsonNullValueInput
    submitLabel?: string | null
    gtmEventName?: string | null
    gtmCategory?: string | null
    gtmLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutFormInput
  }

  export type FormUncheckedCreateWithoutSubmissionsInput = {
    id?: string
    name: string
    fields?:PrismaJson.FormFields | NullableJsonNullValueInput
    submitLabel?: string | null
    gtmEventName?: string | null
    gtmCategory?: string | null
    gtmLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutFormInput
  }

  export type FormCreateOrConnectWithoutSubmissionsInput = {
    where: FormWhereUniqueInput
    create: XOR<FormCreateWithoutSubmissionsInput, FormUncheckedCreateWithoutSubmissionsInput>
  }

  export type FormUpsertWithoutSubmissionsInput = {
    update: XOR<FormUpdateWithoutSubmissionsInput, FormUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<FormCreateWithoutSubmissionsInput, FormUncheckedCreateWithoutSubmissionsInput>
    where?: FormWhereInput
  }

  export type FormUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: FormWhereInput
    data: XOR<FormUpdateWithoutSubmissionsInput, FormUncheckedUpdateWithoutSubmissionsInput>
  }

  export type FormUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fields?:PrismaJson.FormFields | NullableJsonNullValueInput
    submitLabel?: NullableStringFieldUpdateOperationsInput | string | null
    gtmEventName?: NullableStringFieldUpdateOperationsInput | string | null
    gtmCategory?: NullableStringFieldUpdateOperationsInput | string | null
    gtmLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fields?:PrismaJson.FormFields | NullableJsonNullValueInput
    submitLabel?: NullableStringFieldUpdateOperationsInput | string | null
    gtmEventName?: NullableStringFieldUpdateOperationsInput | string | null
    gtmCategory?: NullableStringFieldUpdateOperationsInput | string | null
    gtmLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutFormNestedInput
  }

  export type ImpressionCreateWithoutFormatInput = {
    id?: string
    title: string
    firstName?: string | null
    lastName?: string | null
    email: string
    pageCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    genre?: GenreCreateNestedOneWithoutImpressionInput
    file?: MediaCreateNestedOneWithoutImpressionInput
  }

  export type ImpressionUncheckedCreateWithoutFormatInput = {
    id?: string
    title: string
    firstName?: string | null
    lastName?: string | null
    email: string
    pageCount?: number | null
    genreId?: string | null
    fileId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImpressionCreateOrConnectWithoutFormatInput = {
    where: ImpressionWhereUniqueInput
    create: XOR<ImpressionCreateWithoutFormatInput, ImpressionUncheckedCreateWithoutFormatInput>
  }

  export type ImpressionCreateManyFormatInputEnvelope = {
    data: ImpressionCreateManyFormatInput | ImpressionCreateManyFormatInput[]
    skipDuplicates?: boolean
  }

  export type ImpressionUpsertWithWhereUniqueWithoutFormatInput = {
    where: ImpressionWhereUniqueInput
    update: XOR<ImpressionUpdateWithoutFormatInput, ImpressionUncheckedUpdateWithoutFormatInput>
    create: XOR<ImpressionCreateWithoutFormatInput, ImpressionUncheckedCreateWithoutFormatInput>
  }

  export type ImpressionUpdateWithWhereUniqueWithoutFormatInput = {
    where: ImpressionWhereUniqueInput
    data: XOR<ImpressionUpdateWithoutFormatInput, ImpressionUncheckedUpdateWithoutFormatInput>
  }

  export type ImpressionUpdateManyWithWhereWithoutFormatInput = {
    where: ImpressionScalarWhereInput
    data: XOR<ImpressionUpdateManyMutationInput, ImpressionUncheckedUpdateManyWithoutFormatInput>
  }

  export type ImpressionScalarWhereInput = {
    AND?: ImpressionScalarWhereInput | ImpressionScalarWhereInput[]
    OR?: ImpressionScalarWhereInput[]
    NOT?: ImpressionScalarWhereInput | ImpressionScalarWhereInput[]
    id?: StringFilter<"Impression"> | string
    title?: StringFilter<"Impression"> | string
    firstName?: StringNullableFilter<"Impression"> | string | null
    lastName?: StringNullableFilter<"Impression"> | string | null
    email?: StringFilter<"Impression"> | string
    pageCount?: IntNullableFilter<"Impression"> | number | null
    formatId?: StringNullableFilter<"Impression"> | string | null
    genreId?: StringNullableFilter<"Impression"> | string | null
    fileId?: StringNullableFilter<"Impression"> | string | null
    createdAt?: DateTimeFilter<"Impression"> | Date | string
    updatedAt?: DateTimeFilter<"Impression"> | Date | string
  }

  export type ImpressionCreateWithoutGenreInput = {
    id?: string
    title: string
    firstName?: string | null
    lastName?: string | null
    email: string
    pageCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    format?: FormatCreateNestedOneWithoutImpressionInput
    file?: MediaCreateNestedOneWithoutImpressionInput
  }

  export type ImpressionUncheckedCreateWithoutGenreInput = {
    id?: string
    title: string
    firstName?: string | null
    lastName?: string | null
    email: string
    pageCount?: number | null
    formatId?: string | null
    fileId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImpressionCreateOrConnectWithoutGenreInput = {
    where: ImpressionWhereUniqueInput
    create: XOR<ImpressionCreateWithoutGenreInput, ImpressionUncheckedCreateWithoutGenreInput>
  }

  export type ImpressionCreateManyGenreInputEnvelope = {
    data: ImpressionCreateManyGenreInput | ImpressionCreateManyGenreInput[]
    skipDuplicates?: boolean
  }

  export type ImpressionUpsertWithWhereUniqueWithoutGenreInput = {
    where: ImpressionWhereUniqueInput
    update: XOR<ImpressionUpdateWithoutGenreInput, ImpressionUncheckedUpdateWithoutGenreInput>
    create: XOR<ImpressionCreateWithoutGenreInput, ImpressionUncheckedCreateWithoutGenreInput>
  }

  export type ImpressionUpdateWithWhereUniqueWithoutGenreInput = {
    where: ImpressionWhereUniqueInput
    data: XOR<ImpressionUpdateWithoutGenreInput, ImpressionUncheckedUpdateWithoutGenreInput>
  }

  export type ImpressionUpdateManyWithWhereWithoutGenreInput = {
    where: ImpressionScalarWhereInput
    data: XOR<ImpressionUpdateManyMutationInput, ImpressionUncheckedUpdateManyWithoutGenreInput>
  }

  export type FormatCreateWithoutImpressionInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormatUncheckedCreateWithoutImpressionInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormatCreateOrConnectWithoutImpressionInput = {
    where: FormatWhereUniqueInput
    create: XOR<FormatCreateWithoutImpressionInput, FormatUncheckedCreateWithoutImpressionInput>
  }

  export type GenreCreateWithoutImpressionInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GenreUncheckedCreateWithoutImpressionInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GenreCreateOrConnectWithoutImpressionInput = {
    where: GenreWhereUniqueInput
    create: XOR<GenreCreateWithoutImpressionInput, GenreUncheckedCreateWithoutImpressionInput>
  }

  export type MediaCreateWithoutImpressionInput = {
    id?: string
    name: string
    key?: string | null
    url: string
    size?: number | null
    type?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    post?: PostCreateNestedManyWithoutImageCoverInput
    seo?: SeoCreateNestedManyWithoutOgTwitterImageInput
    product?: ProductCreateNestedManyWithoutImageCoverInput
    products?: ProductGalleryCreateNestedManyWithoutMediaInput
    user?: UserCreateNestedManyWithoutProfileImageInput
  }

  export type MediaUncheckedCreateWithoutImpressionInput = {
    id?: string
    name: string
    key?: string | null
    url: string
    size?: number | null
    type?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    post?: PostUncheckedCreateNestedManyWithoutImageCoverInput
    seo?: SeoUncheckedCreateNestedManyWithoutOgTwitterImageInput
    product?: ProductUncheckedCreateNestedManyWithoutImageCoverInput
    products?: ProductGalleryUncheckedCreateNestedManyWithoutMediaInput
    user?: UserUncheckedCreateNestedManyWithoutProfileImageInput
  }

  export type MediaCreateOrConnectWithoutImpressionInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutImpressionInput, MediaUncheckedCreateWithoutImpressionInput>
  }

  export type FormatUpsertWithoutImpressionInput = {
    update: XOR<FormatUpdateWithoutImpressionInput, FormatUncheckedUpdateWithoutImpressionInput>
    create: XOR<FormatCreateWithoutImpressionInput, FormatUncheckedCreateWithoutImpressionInput>
    where?: FormatWhereInput
  }

  export type FormatUpdateToOneWithWhereWithoutImpressionInput = {
    where?: FormatWhereInput
    data: XOR<FormatUpdateWithoutImpressionInput, FormatUncheckedUpdateWithoutImpressionInput>
  }

  export type FormatUpdateWithoutImpressionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormatUncheckedUpdateWithoutImpressionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GenreUpsertWithoutImpressionInput = {
    update: XOR<GenreUpdateWithoutImpressionInput, GenreUncheckedUpdateWithoutImpressionInput>
    create: XOR<GenreCreateWithoutImpressionInput, GenreUncheckedCreateWithoutImpressionInput>
    where?: GenreWhereInput
  }

  export type GenreUpdateToOneWithWhereWithoutImpressionInput = {
    where?: GenreWhereInput
    data: XOR<GenreUpdateWithoutImpressionInput, GenreUncheckedUpdateWithoutImpressionInput>
  }

  export type GenreUpdateWithoutImpressionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GenreUncheckedUpdateWithoutImpressionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUpsertWithoutImpressionInput = {
    update: XOR<MediaUpdateWithoutImpressionInput, MediaUncheckedUpdateWithoutImpressionInput>
    create: XOR<MediaCreateWithoutImpressionInput, MediaUncheckedCreateWithoutImpressionInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutImpressionInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutImpressionInput, MediaUncheckedUpdateWithoutImpressionInput>
  }

  export type MediaUpdateWithoutImpressionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateManyWithoutImageCoverNestedInput
    seo?: SeoUpdateManyWithoutOgTwitterImageNestedInput
    product?: ProductUpdateManyWithoutImageCoverNestedInput
    products?: ProductGalleryUpdateManyWithoutMediaNestedInput
    user?: UserUpdateManyWithoutProfileImageNestedInput
  }

  export type MediaUncheckedUpdateWithoutImpressionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUncheckedUpdateManyWithoutImageCoverNestedInput
    seo?: SeoUncheckedUpdateManyWithoutOgTwitterImageNestedInput
    product?: ProductUncheckedUpdateManyWithoutImageCoverNestedInput
    products?: ProductGalleryUncheckedUpdateManyWithoutMediaNestedInput
    user?: UserUncheckedUpdateManyWithoutProfileImageNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    bio?: string | null
    imageUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    profileImage?: MediaCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    postAuthors?: PostAuthorCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    profileImageId?: string | null
    bio?: string | null
    imageUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    postAuthors?: PostAuthorUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: MediaUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    postAuthors?: PostAuthorUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageId?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    postAuthors?: PostAuthorUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scope?: string | null
  }

  export type SessionCreateManyUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type PostCreateManyUserInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    editorType?: $Enums.EditorType
    bodyData:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: string | null
    imageCoverId?: string | null
    seoId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostAuthorCreateManyUserInput = {
    postId: string
    sort: number
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateManyUserInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    imageCoverId?: string | null
    categoryId?: string | null
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: string | null
    rootId?: string | null
    seoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    root?: PostUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: PostUpdateManyWithoutRootNestedInput
    imageCover?: MediaUpdateOneWithoutPostNestedInput
    postCategories?: PostCategoryUpdateManyWithoutPostNestedInput
    tags?: TagUpdateManyWithoutPostsNestedInput
    seo?: SeoUpdateOneWithoutPostsNestedInput
    postAuthors?: PostAuthorUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: PostUncheckedUpdateManyWithoutRootNestedInput
    postCategories?: PostCategoryUncheckedUpdateManyWithoutPostNestedInput
    tags?: TagUncheckedUpdateManyWithoutPostsNestedInput
    postAuthors?: PostAuthorUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAuthorUpdateWithoutUserInput = {
    sort?: IntFieldUpdateOperationsInput | number
    post?: PostUpdateOneRequiredWithoutPostAuthorsNestedInput
  }

  export type PostAuthorUncheckedUpdateWithoutUserInput = {
    postId?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
  }

  export type PostAuthorUncheckedUpdateManyWithoutUserInput = {
    postId?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageCover?: MediaUpdateOneWithoutProductNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    extras?: ProductExtraUpdateManyWithoutProductNestedInput
    form?: FormUpdateOneWithoutProductsNestedInput
    root?: ProductUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: ProductUpdateManyWithoutRootNestedInput
    gallery?: ProductGalleryUpdateManyWithoutProductNestedInput
    faqs?: ProductFAQUpdateManyWithoutProductNestedInput
    purchases?: PurchaseUpdateManyWithoutProductNestedInput
    seo?: SeoUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extras?: ProductExtraUncheckedUpdateManyWithoutProductNestedInput
    rootChildren?: ProductUncheckedUpdateManyWithoutRootNestedInput
    gallery?: ProductGalleryUncheckedUpdateManyWithoutProductNestedInput
    faqs?: ProductFAQUncheckedUpdateManyWithoutProductNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateManyImageCoverInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    editorType?: $Enums.EditorType
    bodyData:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: string | null
    seoId?: string | null
    userId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeoCreateManyOgTwitterImageInput = {
    id?: string
    title: string
    description?: string | null
    canonicalUrl?: string | null
    version: number
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: string | null
    ogTwitterTitle?: string | null
    ogTwitterDescription?: string | null
    ogTwitterLocale?: string | null
    ogTwitterUrl?: string | null
    rootId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateManyImageCoverInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    categoryId?: string | null
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: string | null
    rootId?: string | null
    seoId?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductGalleryCreateManyMediaInput = {
    id?: string
    sort: number
    productId: string
  }

  export type UserCreateManyProfileImageInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    bio?: string | null
    imageUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateWithoutImageCoverInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    root?: PostUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: PostUpdateManyWithoutRootNestedInput
    postCategories?: PostCategoryUpdateManyWithoutPostNestedInput
    tags?: TagUpdateManyWithoutPostsNestedInput
    seo?: SeoUpdateOneWithoutPostsNestedInput
    postAuthors?: PostAuthorUpdateManyWithoutPostNestedInput
    user?: UserUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutImageCoverInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: PostUncheckedUpdateManyWithoutRootNestedInput
    postCategories?: PostCategoryUncheckedUpdateManyWithoutPostNestedInput
    tags?: TagUncheckedUpdateManyWithoutPostsNestedInput
    postAuthors?: PostAuthorUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutImageCoverInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeoUpdateWithoutOgTwitterImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    ogTwitterType?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterLocale?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    root?: SeoUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: SeoUpdateManyWithoutRootNestedInput
    settings?: SettingsUpdateManyWithoutSeoNestedInput
    posts?: PostUpdateManyWithoutSeoNestedInput
    categories?: CategoryUpdateManyWithoutSeoNestedInput
    tags?: TagUpdateManyWithoutSeoNestedInput
    products?: ProductUpdateManyWithoutSeoNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutSeoNestedInput
  }

  export type SeoUncheckedUpdateWithoutOgTwitterImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    ogTwitterType?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterLocale?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: SeoUncheckedUpdateManyWithoutRootNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutSeoNestedInput
    posts?: PostUncheckedUpdateManyWithoutSeoNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutSeoNestedInput
    tags?: TagUncheckedUpdateManyWithoutSeoNestedInput
    products?: ProductUncheckedUpdateManyWithoutSeoNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutSeoNestedInput
  }

  export type SeoUncheckedUpdateManyWithoutOgTwitterImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    ogTwitterType?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterLocale?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutImageCoverInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    extras?: ProductExtraUpdateManyWithoutProductNestedInput
    form?: FormUpdateOneWithoutProductsNestedInput
    root?: ProductUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: ProductUpdateManyWithoutRootNestedInput
    gallery?: ProductGalleryUpdateManyWithoutProductNestedInput
    faqs?: ProductFAQUpdateManyWithoutProductNestedInput
    purchases?: PurchaseUpdateManyWithoutProductNestedInput
    seo?: SeoUpdateOneWithoutProductsNestedInput
    user?: UserUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutImageCoverInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extras?: ProductExtraUncheckedUpdateManyWithoutProductNestedInput
    rootChildren?: ProductUncheckedUpdateManyWithoutRootNestedInput
    gallery?: ProductGalleryUncheckedUpdateManyWithoutProductNestedInput
    faqs?: ProductFAQUncheckedUpdateManyWithoutProductNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutImageCoverInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductGalleryUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutGalleryNestedInput
  }

  export type ProductGalleryUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductGalleryUncheckedUpdateManyWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpdateWithoutProfileImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    postAuthors?: PostAuthorUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    postAuthors?: PostAuthorUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutProfileImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeoCreateManyRootInput = {
    id?: string
    title: string
    description?: string | null
    canonicalUrl?: string | null
    version: number
    noIndex?: boolean
    noFollow?: boolean
    ogTwitterType?: string | null
    ogTwitterTitle?: string | null
    ogTwitterDescription?: string | null
    ogTwitterImageId?: string | null
    ogTwitterLocale?: string | null
    ogTwitterUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingsCreateManySeoInput = {
    id?: string
    siteName?: string | null
    siteUrl?: string | null
    deployWebhookUrl?: string | null
    logoUrl?: string | null
    scripts?:PrismaJson.Scripts
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateManySeoInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    editorType?: $Enums.EditorType
    bodyData:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: string | null
    imageCoverId?: string | null
    userId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateManySeoInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    rootId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagCreateManySeoInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    rootId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateManySeoInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    imageCoverId?: string | null
    categoryId?: string | null
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: string | null
    rootId?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryCreateManySeoInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    rootId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeoUpdateWithoutRootInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    ogTwitterType?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterLocale?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ogTwitterImage?: MediaUpdateOneWithoutSeoNestedInput
    rootChildren?: SeoUpdateManyWithoutRootNestedInput
    settings?: SettingsUpdateManyWithoutSeoNestedInput
    posts?: PostUpdateManyWithoutSeoNestedInput
    categories?: CategoryUpdateManyWithoutSeoNestedInput
    tags?: TagUpdateManyWithoutSeoNestedInput
    products?: ProductUpdateManyWithoutSeoNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutSeoNestedInput
  }

  export type SeoUncheckedUpdateWithoutRootInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    ogTwitterType?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterImageId?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterLocale?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: SeoUncheckedUpdateManyWithoutRootNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutSeoNestedInput
    posts?: PostUncheckedUpdateManyWithoutSeoNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutSeoNestedInput
    tags?: TagUncheckedUpdateManyWithoutSeoNestedInput
    products?: ProductUncheckedUpdateManyWithoutSeoNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutSeoNestedInput
  }

  export type SeoUncheckedUpdateManyWithoutRootInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    ogTwitterType?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterImageId?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterLocale?: NullableStringFieldUpdateOperationsInput | string | null
    ogTwitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUpdateWithoutSeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    siteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deployWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scripts?:PrismaJson.Scripts
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUncheckedUpdateWithoutSeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    siteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deployWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scripts?:PrismaJson.Scripts
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUncheckedUpdateManyWithoutSeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    siteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deployWebhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scripts?:PrismaJson.Scripts
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutSeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    root?: PostUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: PostUpdateManyWithoutRootNestedInput
    imageCover?: MediaUpdateOneWithoutPostNestedInput
    postCategories?: PostCategoryUpdateManyWithoutPostNestedInput
    tags?: TagUpdateManyWithoutPostsNestedInput
    postAuthors?: PostAuthorUpdateManyWithoutPostNestedInput
    user?: UserUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutSeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: PostUncheckedUpdateManyWithoutRootNestedInput
    postCategories?: PostCategoryUncheckedUpdateManyWithoutPostNestedInput
    tags?: TagUncheckedUpdateManyWithoutPostsNestedInput
    postAuthors?: PostAuthorUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutSeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpdateWithoutSeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    root?: CategoryUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: CategoryUpdateManyWithoutRootNestedInput
    postCategories?: PostCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutSeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: CategoryUncheckedUpdateManyWithoutRootNestedInput
    postCategories?: PostCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutSeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpdateWithoutSeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    root?: TagUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: TagUpdateManyWithoutRootNestedInput
    posts?: PostUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutSeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: TagUncheckedUpdateManyWithoutRootNestedInput
    posts?: PostUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutSeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutSeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageCover?: MediaUpdateOneWithoutProductNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    extras?: ProductExtraUpdateManyWithoutProductNestedInput
    form?: FormUpdateOneWithoutProductsNestedInput
    root?: ProductUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: ProductUpdateManyWithoutRootNestedInput
    gallery?: ProductGalleryUpdateManyWithoutProductNestedInput
    faqs?: ProductFAQUpdateManyWithoutProductNestedInput
    purchases?: PurchaseUpdateManyWithoutProductNestedInput
    user?: UserUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutSeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extras?: ProductExtraUncheckedUpdateManyWithoutProductNestedInput
    rootChildren?: ProductUncheckedUpdateManyWithoutRootNestedInput
    gallery?: ProductGalleryUncheckedUpdateManyWithoutProductNestedInput
    faqs?: ProductFAQUncheckedUpdateManyWithoutProductNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutSeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUpdateWithoutSeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    root?: ProductCategoryUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: ProductCategoryUpdateManyWithoutRootNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutSeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: ProductCategoryUncheckedUpdateManyWithoutRootNestedInput
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateManyWithoutSeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateManyRootInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    editorType?: $Enums.EditorType
    bodyData:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    imageCoverId?: string | null
    seoId?: string | null
    userId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCategoryCreateManyPostInput = {
    categoryId: string
    sort: number
  }

  export type PostAuthorCreateManyPostInput = {
    userId: string
    sort: number
  }

  export type PostUpdateWithoutRootInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: PostUpdateManyWithoutRootNestedInput
    imageCover?: MediaUpdateOneWithoutPostNestedInput
    postCategories?: PostCategoryUpdateManyWithoutPostNestedInput
    tags?: TagUpdateManyWithoutPostsNestedInput
    seo?: SeoUpdateOneWithoutPostsNestedInput
    postAuthors?: PostAuthorUpdateManyWithoutPostNestedInput
    user?: UserUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutRootInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: PostUncheckedUpdateManyWithoutRootNestedInput
    postCategories?: PostCategoryUncheckedUpdateManyWithoutPostNestedInput
    tags?: TagUncheckedUpdateManyWithoutPostsNestedInput
    postAuthors?: PostAuthorUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutRootInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCategoryUpdateWithoutPostInput = {
    sort?: IntFieldUpdateOperationsInput | number
    category?: CategoryUpdateOneRequiredWithoutPostCategoriesNestedInput
  }

  export type PostCategoryUncheckedUpdateWithoutPostInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
  }

  export type PostCategoryUncheckedUpdateManyWithoutPostInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
  }

  export type TagUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    root?: TagUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: TagUpdateManyWithoutRootNestedInput
    seo?: SeoUpdateOneWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: TagUncheckedUpdateManyWithoutRootNestedInput
  }

  export type TagUncheckedUpdateManyWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAuthorUpdateWithoutPostInput = {
    sort?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutPostAuthorsNestedInput
  }

  export type PostAuthorUncheckedUpdateWithoutPostInput = {
    userId?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
  }

  export type PostAuthorUncheckedUpdateManyWithoutPostInput = {
    userId?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
  }

  export type CategoryCreateManyRootInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    seoId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCategoryCreateManyCategoryInput = {
    postId: string
    sort: number
  }

  export type CategoryUpdateWithoutRootInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: CategoryUpdateManyWithoutRootNestedInput
    postCategories?: PostCategoryUpdateManyWithoutCategoryNestedInput
    seo?: SeoUpdateOneWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateWithoutRootInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: CategoryUncheckedUpdateManyWithoutRootNestedInput
    postCategories?: PostCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutRootInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCategoryUpdateWithoutCategoryInput = {
    sort?: IntFieldUpdateOperationsInput | number
    post?: PostUpdateOneRequiredWithoutPostCategoriesNestedInput
  }

  export type PostCategoryUncheckedUpdateWithoutCategoryInput = {
    postId?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
  }

  export type PostCategoryUncheckedUpdateManyWithoutCategoryInput = {
    postId?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
  }

  export type TagCreateManyRootInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    seoId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateWithoutRootInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: TagUpdateManyWithoutRootNestedInput
    posts?: PostUpdateManyWithoutTagsNestedInput
    seo?: SeoUpdateOneWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutRootInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: TagUncheckedUpdateManyWithoutRootNestedInput
    posts?: PostUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutRootInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    root?: PostUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: PostUpdateManyWithoutRootNestedInput
    imageCover?: MediaUpdateOneWithoutPostNestedInput
    postCategories?: PostCategoryUpdateManyWithoutPostNestedInput
    seo?: SeoUpdateOneWithoutPostsNestedInput
    postAuthors?: PostAuthorUpdateManyWithoutPostNestedInput
    user?: UserUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: PostUncheckedUpdateManyWithoutRootNestedInput
    postCategories?: PostCategoryUncheckedUpdateManyWithoutPostNestedInput
    postAuthors?: PostAuthorUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    editorType?: EnumEditorTypeFieldUpdateOperationsInput | $Enums.EditorType
    bodyData?:PrismaJson.BodyData
    tiptapBodyData?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSettingCreateManySubscriptionTemplateInput = {
    id?: string
    emailSender?: string | null
    emailSenderName?: string | null
    emailResponse?: string | null
    emailProvider?: $Enums.EmailProvider | null
    emailApiKey?: string | null
    maxEmailsPerDay?: number | null
    freeEbookTemplateId?: string | null
    webinarTemplateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailSettingCreateManyFreeEbookTemplateInput = {
    id?: string
    emailSender?: string | null
    emailSenderName?: string | null
    emailResponse?: string | null
    emailProvider?: $Enums.EmailProvider | null
    emailApiKey?: string | null
    maxEmailsPerDay?: number | null
    subscriptionTemplateId?: string | null
    webinarTemplateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailSettingCreateManyWebinarTemplateInput = {
    id?: string
    emailSender?: string | null
    emailSenderName?: string | null
    emailResponse?: string | null
    emailProvider?: $Enums.EmailProvider | null
    emailApiKey?: string | null
    maxEmailsPerDay?: number | null
    subscriptionTemplateId?: string | null
    freeEbookTemplateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailSettingUpdateWithoutSubscriptionTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailSender?: NullableStringFieldUpdateOperationsInput | string | null
    emailSenderName?: NullableStringFieldUpdateOperationsInput | string | null
    emailResponse?: NullableStringFieldUpdateOperationsInput | string | null
    emailProvider?: NullableEnumEmailProviderFieldUpdateOperationsInput | $Enums.EmailProvider | null
    emailApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    maxEmailsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freeEbookTemplate?: EmailTemplateUpdateOneWithoutEmailSettingFreeEbookNestedInput
    webinarTemplate?: EmailTemplateUpdateOneWithoutEmailSettingWebinarNestedInput
  }

  export type EmailSettingUncheckedUpdateWithoutSubscriptionTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailSender?: NullableStringFieldUpdateOperationsInput | string | null
    emailSenderName?: NullableStringFieldUpdateOperationsInput | string | null
    emailResponse?: NullableStringFieldUpdateOperationsInput | string | null
    emailProvider?: NullableEnumEmailProviderFieldUpdateOperationsInput | $Enums.EmailProvider | null
    emailApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    maxEmailsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    freeEbookTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    webinarTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSettingUncheckedUpdateManyWithoutSubscriptionTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailSender?: NullableStringFieldUpdateOperationsInput | string | null
    emailSenderName?: NullableStringFieldUpdateOperationsInput | string | null
    emailResponse?: NullableStringFieldUpdateOperationsInput | string | null
    emailProvider?: NullableEnumEmailProviderFieldUpdateOperationsInput | $Enums.EmailProvider | null
    emailApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    maxEmailsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    freeEbookTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    webinarTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSettingUpdateWithoutFreeEbookTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailSender?: NullableStringFieldUpdateOperationsInput | string | null
    emailSenderName?: NullableStringFieldUpdateOperationsInput | string | null
    emailResponse?: NullableStringFieldUpdateOperationsInput | string | null
    emailProvider?: NullableEnumEmailProviderFieldUpdateOperationsInput | $Enums.EmailProvider | null
    emailApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    maxEmailsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionTemplate?: EmailTemplateUpdateOneWithoutEmailSettingSubscriptionNestedInput
    webinarTemplate?: EmailTemplateUpdateOneWithoutEmailSettingWebinarNestedInput
  }

  export type EmailSettingUncheckedUpdateWithoutFreeEbookTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailSender?: NullableStringFieldUpdateOperationsInput | string | null
    emailSenderName?: NullableStringFieldUpdateOperationsInput | string | null
    emailResponse?: NullableStringFieldUpdateOperationsInput | string | null
    emailProvider?: NullableEnumEmailProviderFieldUpdateOperationsInput | $Enums.EmailProvider | null
    emailApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    maxEmailsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    webinarTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSettingUncheckedUpdateManyWithoutFreeEbookTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailSender?: NullableStringFieldUpdateOperationsInput | string | null
    emailSenderName?: NullableStringFieldUpdateOperationsInput | string | null
    emailResponse?: NullableStringFieldUpdateOperationsInput | string | null
    emailProvider?: NullableEnumEmailProviderFieldUpdateOperationsInput | $Enums.EmailProvider | null
    emailApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    maxEmailsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    webinarTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSettingUpdateWithoutWebinarTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailSender?: NullableStringFieldUpdateOperationsInput | string | null
    emailSenderName?: NullableStringFieldUpdateOperationsInput | string | null
    emailResponse?: NullableStringFieldUpdateOperationsInput | string | null
    emailProvider?: NullableEnumEmailProviderFieldUpdateOperationsInput | $Enums.EmailProvider | null
    emailApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    maxEmailsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionTemplate?: EmailTemplateUpdateOneWithoutEmailSettingSubscriptionNestedInput
    freeEbookTemplate?: EmailTemplateUpdateOneWithoutEmailSettingFreeEbookNestedInput
  }

  export type EmailSettingUncheckedUpdateWithoutWebinarTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailSender?: NullableStringFieldUpdateOperationsInput | string | null
    emailSenderName?: NullableStringFieldUpdateOperationsInput | string | null
    emailResponse?: NullableStringFieldUpdateOperationsInput | string | null
    emailProvider?: NullableEnumEmailProviderFieldUpdateOperationsInput | $Enums.EmailProvider | null
    emailApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    maxEmailsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    freeEbookTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSettingUncheckedUpdateManyWithoutWebinarTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailSender?: NullableStringFieldUpdateOperationsInput | string | null
    emailSenderName?: NullableStringFieldUpdateOperationsInput | string | null
    emailResponse?: NullableStringFieldUpdateOperationsInput | string | null
    emailProvider?: NullableEnumEmailProviderFieldUpdateOperationsInput | $Enums.EmailProvider | null
    emailApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    maxEmailsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    freeEbookTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailContactUpdateWithoutAudiencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscriber?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: EmailContactInteractionUpdateManyWithoutContactNestedInput
    emailSingleSendLogs?: EmailSingleSendLogUpdateManyWithoutContactNestedInput
  }

  export type EmailContactUncheckedUpdateWithoutAudiencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscriber?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: EmailContactInteractionUncheckedUpdateManyWithoutContactNestedInput
    emailSingleSendLogs?: EmailSingleSendLogUncheckedUpdateManyWithoutContactNestedInput
  }

  export type EmailContactUncheckedUpdateManyWithoutAudiencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscriber?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSingleSendUpdateWithoutAudiencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailSingleSendLogs?: EmailSingleSendLogUpdateManyWithoutSingleSendNestedInput
  }

  export type EmailSingleSendUncheckedUpdateWithoutAudiencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailSingleSendLogs?: EmailSingleSendLogUncheckedUpdateManyWithoutSingleSendNestedInput
  }

  export type EmailSingleSendUncheckedUpdateManyWithoutAudiencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    designData?:PrismaJson.EmailDesignData | NullableJsonNullValueInput
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailContactInteractionCreateManyContactInput = {
    id?: string
    interactionType: string
    interactionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailSingleSendLogCreateManyContactInput = {
    id?: string
    singleSendId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailAudienceUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAudienceTypeFieldUpdateOperationsInput | $Enums.AudienceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailSingleSends?: EmailSingleSendUpdateManyWithoutAudiencesNestedInput
  }

  export type EmailAudienceUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAudienceTypeFieldUpdateOperationsInput | $Enums.AudienceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailSingleSends?: EmailSingleSendUncheckedUpdateManyWithoutAudiencesNestedInput
  }

  export type EmailAudienceUncheckedUpdateManyWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAudienceTypeFieldUpdateOperationsInput | $Enums.AudienceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailContactInteractionUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailContactInteractionUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailContactInteractionUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSingleSendLogUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    singleSend?: EmailSingleSendUpdateOneRequiredWithoutEmailSingleSendLogsNestedInput
  }

  export type EmailSingleSendLogUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    singleSendId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSingleSendLogUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    singleSendId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSingleSendLogCreateManySingleSendInput = {
    id?: string
    contactId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailAudienceUpdateWithoutEmailSingleSendsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAudienceTypeFieldUpdateOperationsInput | $Enums.AudienceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: EmailContactUpdateManyWithoutAudiencesNestedInput
  }

  export type EmailAudienceUncheckedUpdateWithoutEmailSingleSendsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAudienceTypeFieldUpdateOperationsInput | $Enums.AudienceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: EmailContactUncheckedUpdateManyWithoutAudiencesNestedInput
  }

  export type EmailAudienceUncheckedUpdateManyWithoutEmailSingleSendsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAudienceTypeFieldUpdateOperationsInput | $Enums.AudienceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSingleSendLogUpdateWithoutSingleSendInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: EmailContactUpdateOneRequiredWithoutEmailSingleSendLogsNestedInput
  }

  export type EmailSingleSendLogUncheckedUpdateWithoutSingleSendInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSingleSendLogUncheckedUpdateManyWithoutSingleSendInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductExtraCreateManyProductInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateManyRootInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    imageCoverId?: string | null
    categoryId?: string | null
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: string | null
    seoId?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductGalleryCreateManyProductInput = {
    id?: string
    sort: number
    mediaId: string
  }

  export type ProductFAQCreateManyProductInput = {
    id?: string
    question: string
    answer: string
    sort: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseCreateManyProductInput = {
    id?: string
    email: string
    productRootId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductExtraUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductExtraUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductExtraUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutRootInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageCover?: MediaUpdateOneWithoutProductNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    extras?: ProductExtraUpdateManyWithoutProductNestedInput
    form?: FormUpdateOneWithoutProductsNestedInput
    rootChildren?: ProductUpdateManyWithoutRootNestedInput
    gallery?: ProductGalleryUpdateManyWithoutProductNestedInput
    faqs?: ProductFAQUpdateManyWithoutProductNestedInput
    purchases?: PurchaseUpdateManyWithoutProductNestedInput
    seo?: SeoUpdateOneWithoutProductsNestedInput
    user?: UserUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutRootInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extras?: ProductExtraUncheckedUpdateManyWithoutProductNestedInput
    rootChildren?: ProductUncheckedUpdateManyWithoutRootNestedInput
    gallery?: ProductGalleryUncheckedUpdateManyWithoutProductNestedInput
    faqs?: ProductFAQUncheckedUpdateManyWithoutProductNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutRootInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductGalleryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
    media?: MediaUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductGalleryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
    mediaId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductGalleryUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
    mediaId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductFAQUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductFAQUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductFAQUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    sort?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    productRootId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    productRootId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    productRootId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryCreateManyRootInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    seoId?: string | null
    firstPublishedAt?: Date | string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateManyCategoryInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    imageCoverId?: string | null
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: string | null
    rootId?: string | null
    seoId?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryUpdateWithoutRootInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: ProductCategoryUpdateManyWithoutRootNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
    seo?: SeoUpdateOneWithoutProductCategoriesNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutRootInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootChildren?: ProductCategoryUncheckedUpdateManyWithoutRootNestedInput
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateManyWithoutRootInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    firstPublishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageCover?: MediaUpdateOneWithoutProductNestedInput
    extras?: ProductExtraUpdateManyWithoutProductNestedInput
    form?: FormUpdateOneWithoutProductsNestedInput
    root?: ProductUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: ProductUpdateManyWithoutRootNestedInput
    gallery?: ProductGalleryUpdateManyWithoutProductNestedInput
    faqs?: ProductFAQUpdateManyWithoutProductNestedInput
    purchases?: PurchaseUpdateManyWithoutProductNestedInput
    seo?: SeoUpdateOneWithoutProductsNestedInput
    user?: UserUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extras?: ProductExtraUncheckedUpdateManyWithoutProductNestedInput
    rootChildren?: ProductUncheckedUpdateManyWithoutRootNestedInput
    gallery?: ProductGalleryUncheckedUpdateManyWithoutProductNestedInput
    faqs?: ProductFAQUncheckedUpdateManyWithoutProductNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdBlockCreateManyCampaignInput = {
    id?: string
    label: string
    layoutType: $Enums.AdLayoutType
    isActive?: boolean
    placement?: $Enums.AdPositionPlacement
    reference?: $Enums.AdPositionReference
    referenceCount?: number
    minWords?: number
    excludedPostIds?: AdBlockCreateexcludedPostIdsInput | string[]
    excludedCategoryIds?: AdBlockCreateexcludedCategoryIdsInput | string[]
    excludedTagIds?: AdBlockCreateexcludedTagIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdBlockUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    layoutType?: EnumAdLayoutTypeFieldUpdateOperationsInput | $Enums.AdLayoutType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    placement?: EnumAdPositionPlacementFieldUpdateOperationsInput | $Enums.AdPositionPlacement
    reference?: EnumAdPositionReferenceFieldUpdateOperationsInput | $Enums.AdPositionReference
    referenceCount?: IntFieldUpdateOperationsInput | number
    minWords?: IntFieldUpdateOperationsInput | number
    excludedPostIds?: AdBlockUpdateexcludedPostIdsInput | string[]
    excludedCategoryIds?: AdBlockUpdateexcludedCategoryIdsInput | string[]
    excludedTagIds?: AdBlockUpdateexcludedTagIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: AdItemUpdateManyWithoutAdBlockNestedInput
  }

  export type AdBlockUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    layoutType?: EnumAdLayoutTypeFieldUpdateOperationsInput | $Enums.AdLayoutType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    placement?: EnumAdPositionPlacementFieldUpdateOperationsInput | $Enums.AdPositionPlacement
    reference?: EnumAdPositionReferenceFieldUpdateOperationsInput | $Enums.AdPositionReference
    referenceCount?: IntFieldUpdateOperationsInput | number
    minWords?: IntFieldUpdateOperationsInput | number
    excludedPostIds?: AdBlockUpdateexcludedPostIdsInput | string[]
    excludedCategoryIds?: AdBlockUpdateexcludedCategoryIdsInput | string[]
    excludedTagIds?: AdBlockUpdateexcludedTagIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: AdItemUncheckedUpdateManyWithoutAdBlockNestedInput
  }

  export type AdBlockUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    layoutType?: EnumAdLayoutTypeFieldUpdateOperationsInput | $Enums.AdLayoutType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    placement?: EnumAdPositionPlacementFieldUpdateOperationsInput | $Enums.AdPositionPlacement
    reference?: EnumAdPositionReferenceFieldUpdateOperationsInput | $Enums.AdPositionReference
    referenceCount?: IntFieldUpdateOperationsInput | number
    minWords?: IntFieldUpdateOperationsInput | number
    excludedPostIds?: AdBlockUpdateexcludedPostIdsInput | string[]
    excludedCategoryIds?: AdBlockUpdateexcludedCategoryIdsInput | string[]
    excludedTagIds?: AdBlockUpdateexcludedTagIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdItemCreateManyAdBlockInput = {
    id?: string
    sourceType: $Enums.AdItemSourceType
    title?: string | null
    description?: string | null
    imageUrl?: string | null
    url?: string | null
    postRootId?: string | null
    productRootId?: string | null
    sort?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdItemUpdateWithoutAdBlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumAdItemSourceTypeFieldUpdateOperationsInput | $Enums.AdItemSourceType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    postRootId?: NullableStringFieldUpdateOperationsInput | string | null
    productRootId?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdItemUncheckedUpdateWithoutAdBlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumAdItemSourceTypeFieldUpdateOperationsInput | $Enums.AdItemSourceType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    postRootId?: NullableStringFieldUpdateOperationsInput | string | null
    productRootId?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdItemUncheckedUpdateManyWithoutAdBlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumAdItemSourceTypeFieldUpdateOperationsInput | $Enums.AdItemSourceType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    postRootId?: NullableStringFieldUpdateOperationsInput | string | null
    productRootId?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyFormInput = {
    id?: string
    title: string
    slug: string
    description:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type: $Enums.ProductType
    version: number
    status?: $Enums.ContentStatus
    isLatest?: boolean
    imageCoverId?: string | null
    categoryId?: string | null
    acquisitionMode?: $Enums.ProductAcquisitionMode
    price?: number | null
    discountedPrice?: number | null
    isFree?: boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    rootId?: string | null
    seoId?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormSubmissionCreateManyFormInput = {
    id?: string
    email?: string | null
    data:unknown
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageCover?: MediaUpdateOneWithoutProductNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    extras?: ProductExtraUpdateManyWithoutProductNestedInput
    root?: ProductUpdateOneWithoutRootChildrenNestedInput
    rootChildren?: ProductUpdateManyWithoutRootNestedInput
    gallery?: ProductGalleryUpdateManyWithoutProductNestedInput
    faqs?: ProductFAQUpdateManyWithoutProductNestedInput
    purchases?: PurchaseUpdateManyWithoutProductNestedInput
    seo?: SeoUpdateOneWithoutProductsNestedInput
    user?: UserUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extras?: ProductExtraUncheckedUpdateManyWithoutProductNestedInput
    rootChildren?: ProductUncheckedUpdateManyWithoutRootNestedInput
    gallery?: ProductGalleryUncheckedUpdateManyWithoutProductNestedInput
    faqs?: ProductFAQUncheckedUpdateManyWithoutProductNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?:PrismaJson.BodyData
    tiptapDescription?:PrismaJson.TipTapBodyData | NullableJsonNullValueInput
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    imageCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionMode?: EnumProductAcquisitionModeFieldUpdateOperationsInput | $Enums.ProductAcquisitionMode
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isFree?: BoolFieldUpdateOperationsInput | boolean
    metadata?:PrismaJson.ProductMetadata | NullableJsonNullValueInput
    rootId?: NullableStringFieldUpdateOperationsInput | string | null
    seoId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    data?:unknown
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionUncheckedUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    data?:unknown
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionUncheckedUpdateManyWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    data?:unknown
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpressionCreateManyFormatInput = {
    id?: string
    title: string
    firstName?: string | null
    lastName?: string | null
    email: string
    pageCount?: number | null
    genreId?: string | null
    fileId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImpressionUpdateWithoutFormatInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    genre?: GenreUpdateOneWithoutImpressionNestedInput
    file?: MediaUpdateOneWithoutImpressionNestedInput
  }

  export type ImpressionUncheckedUpdateWithoutFormatInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    genreId?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpressionUncheckedUpdateManyWithoutFormatInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    genreId?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpressionCreateManyGenreInput = {
    id?: string
    title: string
    firstName?: string | null
    lastName?: string | null
    email: string
    pageCount?: number | null
    formatId?: string | null
    fileId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImpressionUpdateWithoutGenreInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    format?: FormatUpdateOneWithoutImpressionNestedInput
    file?: MediaUpdateOneWithoutImpressionNestedInput
  }

  export type ImpressionUncheckedUpdateWithoutGenreInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    formatId?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpressionUncheckedUpdateManyWithoutGenreInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    formatId?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}